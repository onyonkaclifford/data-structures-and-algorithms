{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Implementation of various data structures and algorithms Algorithms An algorithm is a set of steps used to solve a problem. An example problem is the task of sorting a list of numbers in ascending or descending order. The sequence of steps used to solve this problem forms an algorithm. Abstract data types An abstract data type is a logical model that declares a set of high level operations that can be performed on data, without specifying the implementation details. It provides an interface that describes the manipulation of data it contains, from which a concrete implementation can be built upon. An example of an abstract data type is the stack. It provides three main methods to manipulate data - push, pop, and peek. It's concrete implementation may rely on an underlying list, array, or any other data structure to organise the data held within itself. Data structures A data structure is a concrete implementation of the organisation of data, and the set of operations that can be performed on the data for efficient access and modification. It can be built based on the implementation of an abstract data type, such as when implementing a stack using a list. It can also be built without relying on the logical model presented by an abstract data type. An example is when the set of operations it can perform have a single implementation detail. Examples: array, doubly linked list. Tests To run tests: python -m doctest -v algorithms/**/*.py data_structures/**/*.py Code formatting and styling Isort, black and flake8 are used to format and style code. To automate this task, pre-commit hooks are used. Install the pre-commit package: pip install pre-commit Install git hook scripts: pre-commit install (optional) Run against all the files: pre-commit run --all-files The installed pre-commit hooks will automatically ensure use of a consistent code format and style whenever one commits changes using git. For full documentation, view the pre-commit docs .","title":"Home"},{"location":"#algorithms","text":"An algorithm is a set of steps used to solve a problem. An example problem is the task of sorting a list of numbers in ascending or descending order. The sequence of steps used to solve this problem forms an algorithm.","title":"Algorithms"},{"location":"#abstract-data-types","text":"An abstract data type is a logical model that declares a set of high level operations that can be performed on data, without specifying the implementation details. It provides an interface that describes the manipulation of data it contains, from which a concrete implementation can be built upon. An example of an abstract data type is the stack. It provides three main methods to manipulate data - push, pop, and peek. It's concrete implementation may rely on an underlying list, array, or any other data structure to organise the data held within itself.","title":"Abstract data types"},{"location":"#data-structures","text":"A data structure is a concrete implementation of the organisation of data, and the set of operations that can be performed on the data for efficient access and modification. It can be built based on the implementation of an abstract data type, such as when implementing a stack using a list. It can also be built without relying on the logical model presented by an abstract data type. An example is when the set of operations it can perform have a single implementation detail. Examples: array, doubly linked list.","title":"Data structures"},{"location":"#tests","text":"To run tests: python -m doctest -v algorithms/**/*.py data_structures/**/*.py","title":"Tests"},{"location":"#code-formatting-and-styling","text":"Isort, black and flake8 are used to format and style code. To automate this task, pre-commit hooks are used. Install the pre-commit package: pip install pre-commit Install git hook scripts: pre-commit install (optional) Run against all the files: pre-commit run --all-files The installed pre-commit hooks will automatically ensure use of a consistent code format and style whenever one commits changes using git. For full documentation, view the pre-commit docs .","title":"Code formatting and styling"},{"location":"algorithms/sorting_algorithms/bubble_sort/","text":"bubble_sort ( x ) Bubble sort repeatedly compares adjacent elements and swaps those that are wrongly ordered. This process is repeated till the list is fully sorted. It has an average time complexity of \u0398(n^2) due to the nesting of its two loops. Time complexity for the worst case, when the list is sorted in reverse order, is O(n^2). Time complexity for the best case, when the list is already sorted in the correct order, is \u03a9(n). bubble_sort([4, 2, 3, 1, 0, 5]) [0, 1, 2, 3, 4, 5] Parameters: Name Type Description Default x List list to be sorted required Returns: Type Description List new sorted list Source code in sorting_algorithms/bubble_sort.py def bubble_sort ( x : List ) -> List : \"\"\"Bubble sort repeatedly compares adjacent elements and swaps those that are wrongly ordered. This process is repeated till the list is fully sorted. It has an average time complexity of \u0398(n^2) due to the nesting of its two loops. Time complexity for the worst case, when the list is sorted in reverse order, is O(n^2). Time complexity for the best case, when the list is already sorted in the correct order, is \u03a9(n). >>> bubble_sort([4, 2, 3, 1, 0, 5]) [0, 1, 2, 3, 4, 5] :param x: list to be sorted :return: new sorted list \"\"\" a_list = copy . deepcopy ( x ) # To avoid modifying the original list length = len ( a_list ) for _ in range ( length - 1 ): swapped = False for current_idx in range ( length - 1 ): next_idx = current_idx + 1 if a_list [ current_idx ] > a_list [ next_idx ]: swapped = True a_list [ current_idx ], a_list [ next_idx ] = ( a_list [ next_idx ], a_list [ current_idx ], ) # If no swap takes place, it means that the list is fully sorted # The remaining loops can therefore be safely ignored if not swapped : break return a_list","title":"Bubble Sort"},{"location":"algorithms/sorting_algorithms/bubble_sort/#algorithms.sorting_algorithms.bubble_sort.bubble_sort","text":"Bubble sort repeatedly compares adjacent elements and swaps those that are wrongly ordered. This process is repeated till the list is fully sorted. It has an average time complexity of \u0398(n^2) due to the nesting of its two loops. Time complexity for the worst case, when the list is sorted in reverse order, is O(n^2). Time complexity for the best case, when the list is already sorted in the correct order, is \u03a9(n). bubble_sort([4, 2, 3, 1, 0, 5]) [0, 1, 2, 3, 4, 5] Parameters: Name Type Description Default x List list to be sorted required Returns: Type Description List new sorted list Source code in sorting_algorithms/bubble_sort.py def bubble_sort ( x : List ) -> List : \"\"\"Bubble sort repeatedly compares adjacent elements and swaps those that are wrongly ordered. This process is repeated till the list is fully sorted. It has an average time complexity of \u0398(n^2) due to the nesting of its two loops. Time complexity for the worst case, when the list is sorted in reverse order, is O(n^2). Time complexity for the best case, when the list is already sorted in the correct order, is \u03a9(n). >>> bubble_sort([4, 2, 3, 1, 0, 5]) [0, 1, 2, 3, 4, 5] :param x: list to be sorted :return: new sorted list \"\"\" a_list = copy . deepcopy ( x ) # To avoid modifying the original list length = len ( a_list ) for _ in range ( length - 1 ): swapped = False for current_idx in range ( length - 1 ): next_idx = current_idx + 1 if a_list [ current_idx ] > a_list [ next_idx ]: swapped = True a_list [ current_idx ], a_list [ next_idx ] = ( a_list [ next_idx ], a_list [ current_idx ], ) # If no swap takes place, it means that the list is fully sorted # The remaining loops can therefore be safely ignored if not swapped : break return a_list","title":"bubble_sort()"},{"location":"algorithms/sorting_algorithms/insertion_sort/","text":"insertion_sort ( x ) Insertion sort compares elements and moves them to their correct position by repeatedly comparing an element with previous elements in the list until its correct position is located, then moving the element to its correct position. It has an average time complexity of \u0398(n^2) due to the nesting of its two loops. Time complexity for the worst case, when the list is sorted in reverse order, is O(n^2). Time complexity for the best case, when the list is already sorted in the correct order, is \u03a9(n). insertion_sort([4, 2, 3, 1, 0, 5]) [0, 1, 2, 3, 4, 5] Parameters: Name Type Description Default x List list to be sorted required Returns: Type Description List new sorted list Source code in sorting_algorithms/insertion_sort.py def insertion_sort ( x : List ) -> List : \"\"\"Insertion sort compares elements and moves them to their correct position by repeatedly comparing an element with previous elements in the list until its correct position is located, then moving the element to its correct position. It has an average time complexity of \u0398(n^2) due to the nesting of its two loops. Time complexity for the worst case, when the list is sorted in reverse order, is O(n^2). Time complexity for the best case, when the list is already sorted in the correct order, is \u03a9(n). >>> insertion_sort([4, 2, 3, 1, 0, 5]) [0, 1, 2, 3, 4, 5] :param x: list to be sorted :return: new sorted list \"\"\" a_list = copy . deepcopy ( x ) # To avoid modifying the original list length = len ( a_list ) for i in range ( length ): idx_to_insert_at = None for current_idx in range ( i - 1 , - 1 , - 1 ): if a_list [ current_idx ] > a_list [ i ]: idx_to_insert_at = current_idx else : # The list upto the current_idx is fully sorted with elements less than the element at index i # The inner loop can thus be safely terminated, and the sorting process moved onto the next index break if idx_to_insert_at is not None : a_list . insert ( idx_to_insert_at , a_list . pop ( i )) return a_list","title":"Insertion Sort"},{"location":"algorithms/sorting_algorithms/insertion_sort/#algorithms.sorting_algorithms.insertion_sort.insertion_sort","text":"Insertion sort compares elements and moves them to their correct position by repeatedly comparing an element with previous elements in the list until its correct position is located, then moving the element to its correct position. It has an average time complexity of \u0398(n^2) due to the nesting of its two loops. Time complexity for the worst case, when the list is sorted in reverse order, is O(n^2). Time complexity for the best case, when the list is already sorted in the correct order, is \u03a9(n). insertion_sort([4, 2, 3, 1, 0, 5]) [0, 1, 2, 3, 4, 5] Parameters: Name Type Description Default x List list to be sorted required Returns: Type Description List new sorted list Source code in sorting_algorithms/insertion_sort.py def insertion_sort ( x : List ) -> List : \"\"\"Insertion sort compares elements and moves them to their correct position by repeatedly comparing an element with previous elements in the list until its correct position is located, then moving the element to its correct position. It has an average time complexity of \u0398(n^2) due to the nesting of its two loops. Time complexity for the worst case, when the list is sorted in reverse order, is O(n^2). Time complexity for the best case, when the list is already sorted in the correct order, is \u03a9(n). >>> insertion_sort([4, 2, 3, 1, 0, 5]) [0, 1, 2, 3, 4, 5] :param x: list to be sorted :return: new sorted list \"\"\" a_list = copy . deepcopy ( x ) # To avoid modifying the original list length = len ( a_list ) for i in range ( length ): idx_to_insert_at = None for current_idx in range ( i - 1 , - 1 , - 1 ): if a_list [ current_idx ] > a_list [ i ]: idx_to_insert_at = current_idx else : # The list upto the current_idx is fully sorted with elements less than the element at index i # The inner loop can thus be safely terminated, and the sorting process moved onto the next index break if idx_to_insert_at is not None : a_list . insert ( idx_to_insert_at , a_list . pop ( i )) return a_list","title":"insertion_sort()"},{"location":"algorithms/sorting_algorithms/merge_sort/","text":"merge_sort ( x ) Merge sort divides a list into two smaller lists, and recursively repeats the process on the two smaller lists till lists of single elements are obtained. These smaller lists are then combined to form a single sorted list of the original elements. It has an average time complexity of \u0398(nlogn). Time complexity for the worst case is O(nlogn). Time complexity for the best case is \u03a9(nlogn). merge_sort([4, 2, 3, 1, 0, 5]) [0, 1, 2, 3, 4, 5] Parameters: Name Type Description Default x List list to be sorted required Returns: Type Description List new sorted list Source code in sorting_algorithms/merge_sort.py def merge_sort ( x : List ) -> List : \"\"\"Merge sort divides a list into two smaller lists, and recursively repeats the process on the two smaller lists till lists of single elements are obtained. These smaller lists are then combined to form a single sorted list of the original elements. It has an average time complexity of \u0398(nlogn). Time complexity for the worst case is O(nlogn). Time complexity for the best case is \u03a9(nlogn). >>> merge_sort([4, 2, 3, 1, 0, 5]) [0, 1, 2, 3, 4, 5] :param x: list to be sorted :return: new sorted list \"\"\" length = len ( x ) if length <= 1 : return x mid_idx = length // 2 left = merge_sort ( x [ 0 : mid_idx ]) right = merge_sort ( x [ mid_idx : length ]) result = [] while len ( left ) > 0 and len ( right ) > 0 : if left [ 0 ] <= right [ 0 ]: result . append ( left . pop ( 0 )) else : result . append ( right . pop ( 0 )) result . extend ( left ) result . extend ( right ) return result","title":"Merge Sort"},{"location":"algorithms/sorting_algorithms/merge_sort/#algorithms.sorting_algorithms.merge_sort.merge_sort","text":"Merge sort divides a list into two smaller lists, and recursively repeats the process on the two smaller lists till lists of single elements are obtained. These smaller lists are then combined to form a single sorted list of the original elements. It has an average time complexity of \u0398(nlogn). Time complexity for the worst case is O(nlogn). Time complexity for the best case is \u03a9(nlogn). merge_sort([4, 2, 3, 1, 0, 5]) [0, 1, 2, 3, 4, 5] Parameters: Name Type Description Default x List list to be sorted required Returns: Type Description List new sorted list Source code in sorting_algorithms/merge_sort.py def merge_sort ( x : List ) -> List : \"\"\"Merge sort divides a list into two smaller lists, and recursively repeats the process on the two smaller lists till lists of single elements are obtained. These smaller lists are then combined to form a single sorted list of the original elements. It has an average time complexity of \u0398(nlogn). Time complexity for the worst case is O(nlogn). Time complexity for the best case is \u03a9(nlogn). >>> merge_sort([4, 2, 3, 1, 0, 5]) [0, 1, 2, 3, 4, 5] :param x: list to be sorted :return: new sorted list \"\"\" length = len ( x ) if length <= 1 : return x mid_idx = length // 2 left = merge_sort ( x [ 0 : mid_idx ]) right = merge_sort ( x [ mid_idx : length ]) result = [] while len ( left ) > 0 and len ( right ) > 0 : if left [ 0 ] <= right [ 0 ]: result . append ( left . pop ( 0 )) else : result . append ( right . pop ( 0 )) result . extend ( left ) result . extend ( right ) return result","title":"merge_sort()"},{"location":"algorithms/sorting_algorithms/quick_sort/","text":"quick_sort ( x ) Quick sort repeatedly moves smaller elements left and larger elements right relative to a pivot that divides the list into two smaller lists. The process is recursively repeated for the two smaller lists till all elements are fully sorted. It has an average time complexity of \u0398(nlogn). Time complexity for the worst case, when the pivot creates the most unbalanced divisions for all recursions, is O(n^2). Time complexity for the best case, when the median is always chosen as the pivot, is \u03a9(nlogn). quick_sort([4, 2, 3, 1, 0, 5]) [0, 1, 2, 3, 4, 5] Parameters: Name Type Description Default x List list to be sorted required Returns: Type Description List new sorted list Source code in sorting_algorithms/quick_sort.py def quick_sort ( x : List ) -> List : \"\"\"Quick sort repeatedly moves smaller elements left and larger elements right relative to a pivot that divides the list into two smaller lists. The process is recursively repeated for the two smaller lists till all elements are fully sorted. It has an average time complexity of \u0398(nlogn). Time complexity for the worst case, when the pivot creates the most unbalanced divisions for all recursions, is O(n^2). Time complexity for the best case, when the median is always chosen as the pivot, is \u03a9(nlogn). >>> quick_sort([4, 2, 3, 1, 0, 5]) [0, 1, 2, 3, 4, 5] :param x: list to be sorted :return: new sorted list \"\"\" a_list = copy . deepcopy ( x ) # To avoid modifying the original list def sort_helper ( y : List , start_idx : int , stop_idx : int ) -> None : \"\"\"Helper function to recursively sort the list :param y: list to be sorted :param start_idx: index at which sorting begins from :param stop_idx: index at which sorting stops \"\"\" if start_idx < stop_idx : # ensure pivot is as close to the mid-point as possible while taking care of integer overflow pivot_idx = start_idx + int (( stop_idx - start_idx ) / 2 ) pivot = y [ pivot_idx ] i = 0 values_equal_to_pivot = 0 while i <= stop_idx : if y [ i ] < pivot and i > pivot_idx : y . insert ( pivot_idx , y . pop ( i )) pivot_idx += 1 i += 1 elif y [ i ] > pivot and i < pivot_idx : y . insert ( pivot_idx , y . pop ( i )) pivot_idx -= 1 else : i += 1 sort_helper ( y , start_idx , pivot_idx - 1 ) sort_helper ( y , pivot_idx + values_equal_to_pivot + 1 , stop_idx ) sort_helper ( a_list , 0 , len ( a_list ) - 1 ) return a_list","title":"Quick Sort"},{"location":"algorithms/sorting_algorithms/quick_sort/#algorithms.sorting_algorithms.quick_sort.quick_sort","text":"Quick sort repeatedly moves smaller elements left and larger elements right relative to a pivot that divides the list into two smaller lists. The process is recursively repeated for the two smaller lists till all elements are fully sorted. It has an average time complexity of \u0398(nlogn). Time complexity for the worst case, when the pivot creates the most unbalanced divisions for all recursions, is O(n^2). Time complexity for the best case, when the median is always chosen as the pivot, is \u03a9(nlogn). quick_sort([4, 2, 3, 1, 0, 5]) [0, 1, 2, 3, 4, 5] Parameters: Name Type Description Default x List list to be sorted required Returns: Type Description List new sorted list Source code in sorting_algorithms/quick_sort.py def quick_sort ( x : List ) -> List : \"\"\"Quick sort repeatedly moves smaller elements left and larger elements right relative to a pivot that divides the list into two smaller lists. The process is recursively repeated for the two smaller lists till all elements are fully sorted. It has an average time complexity of \u0398(nlogn). Time complexity for the worst case, when the pivot creates the most unbalanced divisions for all recursions, is O(n^2). Time complexity for the best case, when the median is always chosen as the pivot, is \u03a9(nlogn). >>> quick_sort([4, 2, 3, 1, 0, 5]) [0, 1, 2, 3, 4, 5] :param x: list to be sorted :return: new sorted list \"\"\" a_list = copy . deepcopy ( x ) # To avoid modifying the original list def sort_helper ( y : List , start_idx : int , stop_idx : int ) -> None : \"\"\"Helper function to recursively sort the list :param y: list to be sorted :param start_idx: index at which sorting begins from :param stop_idx: index at which sorting stops \"\"\" if start_idx < stop_idx : # ensure pivot is as close to the mid-point as possible while taking care of integer overflow pivot_idx = start_idx + int (( stop_idx - start_idx ) / 2 ) pivot = y [ pivot_idx ] i = 0 values_equal_to_pivot = 0 while i <= stop_idx : if y [ i ] < pivot and i > pivot_idx : y . insert ( pivot_idx , y . pop ( i )) pivot_idx += 1 i += 1 elif y [ i ] > pivot and i < pivot_idx : y . insert ( pivot_idx , y . pop ( i )) pivot_idx -= 1 else : i += 1 sort_helper ( y , start_idx , pivot_idx - 1 ) sort_helper ( y , pivot_idx + values_equal_to_pivot + 1 , stop_idx ) sort_helper ( a_list , 0 , len ( a_list ) - 1 ) return a_list","title":"quick_sort()"},{"location":"algorithms/sorting_algorithms/selection_sort/","text":"selection_sort ( x ) Selection sort repeatedly swaps the minimum element of a list with the left-most unsorted element, building up a new list that's fully sorted. It has an average time complexity of \u0398(n^2) due to the nesting of its two loops. Time complexity for the worst case, when the list is sorted in reverse order, is O(n^2). Time complexity for the best case, when the list is already sorted in the correct order, is \u03a9(n^2). selection_sort([4, 2, 3, 1, 0, 5]) [0, 1, 2, 3, 4, 5] Parameters: Name Type Description Default x List list to be sorted required Returns: Type Description List new sorted list Source code in sorting_algorithms/selection_sort.py def selection_sort ( x : List ) -> List : \"\"\"Selection sort repeatedly swaps the minimum element of a list with the left-most unsorted element, building up a new list that's fully sorted. It has an average time complexity of \u0398(n^2) due to the nesting of its two loops. Time complexity for the worst case, when the list is sorted in reverse order, is O(n^2). Time complexity for the best case, when the list is already sorted in the correct order, is \u03a9(n^2). >>> selection_sort([4, 2, 3, 1, 0, 5]) [0, 1, 2, 3, 4, 5] :param x: list to be sorted :return: new sorted list \"\"\" a_list = copy . deepcopy ( x ) # To avoid modifying the original list length = len ( a_list ) for i in range ( length ): unsorted_min_idx = i for idx , element in enumerate ( a_list [ i :]): if element < a_list [ unsorted_min_idx ]: unsorted_min_idx += idx a_list [ i ], a_list [ unsorted_min_idx ] = a_list [ unsorted_min_idx ], a_list [ i ] return a_list","title":"Selection Sort"},{"location":"algorithms/sorting_algorithms/selection_sort/#algorithms.sorting_algorithms.selection_sort.selection_sort","text":"Selection sort repeatedly swaps the minimum element of a list with the left-most unsorted element, building up a new list that's fully sorted. It has an average time complexity of \u0398(n^2) due to the nesting of its two loops. Time complexity for the worst case, when the list is sorted in reverse order, is O(n^2). Time complexity for the best case, when the list is already sorted in the correct order, is \u03a9(n^2). selection_sort([4, 2, 3, 1, 0, 5]) [0, 1, 2, 3, 4, 5] Parameters: Name Type Description Default x List list to be sorted required Returns: Type Description List new sorted list Source code in sorting_algorithms/selection_sort.py def selection_sort ( x : List ) -> List : \"\"\"Selection sort repeatedly swaps the minimum element of a list with the left-most unsorted element, building up a new list that's fully sorted. It has an average time complexity of \u0398(n^2) due to the nesting of its two loops. Time complexity for the worst case, when the list is sorted in reverse order, is O(n^2). Time complexity for the best case, when the list is already sorted in the correct order, is \u03a9(n^2). >>> selection_sort([4, 2, 3, 1, 0, 5]) [0, 1, 2, 3, 4, 5] :param x: list to be sorted :return: new sorted list \"\"\" a_list = copy . deepcopy ( x ) # To avoid modifying the original list length = len ( a_list ) for i in range ( length ): unsorted_min_idx = i for idx , element in enumerate ( a_list [ i :]): if element < a_list [ unsorted_min_idx ]: unsorted_min_idx += idx a_list [ i ], a_list [ unsorted_min_idx ] = a_list [ unsorted_min_idx ], a_list [ i ] return a_list","title":"selection_sort()"},{"location":"data_structures/deques/deque/","text":"Deque ( ABC ) A deque is an ADT that supports insertion and removal of elements from either end. It's also referred to as a double-ended queue. __len__ ( self ) special Get the total number of elements stored in the deque Returns: Type Description int count of elements in deque Source code in deques/deque.py @abstractmethod def __len__ ( self ) -> int : \"\"\"Get the total number of elements stored in the deque :returns: count of elements in deque \"\"\" pass dequeue_first ( self ) Remove first element of the deque and return it Returns: Type Description Any first element of deque Source code in deques/deque.py @abstractmethod def dequeue_first ( self ) -> Any : \"\"\"Remove first element of the deque and return it :return: first element of deque \"\"\" pass dequeue_last ( self ) Remove last element of the deque and return it Returns: Type Description Any last element of deque Source code in deques/deque.py @abstractmethod def dequeue_last ( self ) -> Any : \"\"\"Remove last element of the deque and return it :return: last element of deque \"\"\" pass enqueue_first ( self , x ) Insert an element to the front of the deque Parameters: Name Type Description Default x Any element to add to the deque required Source code in deques/deque.py @abstractmethod def enqueue_first ( self , x : Any ) -> None : \"\"\"Insert an element to the front of the deque :param x: element to add to the deque \"\"\" pass enqueue_last ( self , x ) Insert an element to the end of the deque Parameters: Name Type Description Default x Any element to add to the deque required Source code in deques/deque.py @abstractmethod def enqueue_last ( self , x : Any ) -> None : \"\"\"Insert an element to the end of the deque :param x: element to add to the deque \"\"\" pass get_first ( self ) Return first element of the deque without removing it Returns: Type Description Any first element of deque Source code in deques/deque.py @abstractmethod def get_first ( self ) -> Any : \"\"\"Return first element of the deque without removing it :return: first element of deque \"\"\" pass get_last ( self ) Return last element of the deque without removing it Returns: Type Description Any last element of deque Source code in deques/deque.py @abstractmethod def get_last ( self ) -> Any : \"\"\"Return last element of the deque without removing it :return: last element of deque \"\"\" pass is_empty ( self ) Check if deque contains no elements Returns: Type Description bool True if deque is empty, else False Source code in deques/deque.py @abstractmethod def is_empty ( self ) -> bool : \"\"\"Check if deque contains no elements :return: True if deque is empty, else False \"\"\" pass","title":"Deque ADT"},{"location":"data_structures/deques/deque/#data_structures.deques.deque.Deque","text":"A deque is an ADT that supports insertion and removal of elements from either end. It's also referred to as a double-ended queue.","title":"Deque"},{"location":"data_structures/deques/deque/#data_structures.deques.deque.Deque.__len__","text":"Get the total number of elements stored in the deque Returns: Type Description int count of elements in deque Source code in deques/deque.py @abstractmethod def __len__ ( self ) -> int : \"\"\"Get the total number of elements stored in the deque :returns: count of elements in deque \"\"\" pass","title":"__len__()"},{"location":"data_structures/deques/deque/#data_structures.deques.deque.Deque.dequeue_first","text":"Remove first element of the deque and return it Returns: Type Description Any first element of deque Source code in deques/deque.py @abstractmethod def dequeue_first ( self ) -> Any : \"\"\"Remove first element of the deque and return it :return: first element of deque \"\"\" pass","title":"dequeue_first()"},{"location":"data_structures/deques/deque/#data_structures.deques.deque.Deque.dequeue_last","text":"Remove last element of the deque and return it Returns: Type Description Any last element of deque Source code in deques/deque.py @abstractmethod def dequeue_last ( self ) -> Any : \"\"\"Remove last element of the deque and return it :return: last element of deque \"\"\" pass","title":"dequeue_last()"},{"location":"data_structures/deques/deque/#data_structures.deques.deque.Deque.enqueue_first","text":"Insert an element to the front of the deque Parameters: Name Type Description Default x Any element to add to the deque required Source code in deques/deque.py @abstractmethod def enqueue_first ( self , x : Any ) -> None : \"\"\"Insert an element to the front of the deque :param x: element to add to the deque \"\"\" pass","title":"enqueue_first()"},{"location":"data_structures/deques/deque/#data_structures.deques.deque.Deque.enqueue_last","text":"Insert an element to the end of the deque Parameters: Name Type Description Default x Any element to add to the deque required Source code in deques/deque.py @abstractmethod def enqueue_last ( self , x : Any ) -> None : \"\"\"Insert an element to the end of the deque :param x: element to add to the deque \"\"\" pass","title":"enqueue_last()"},{"location":"data_structures/deques/deque/#data_structures.deques.deque.Deque.get_first","text":"Return first element of the deque without removing it Returns: Type Description Any first element of deque Source code in deques/deque.py @abstractmethod def get_first ( self ) -> Any : \"\"\"Return first element of the deque without removing it :return: first element of deque \"\"\" pass","title":"get_first()"},{"location":"data_structures/deques/deque/#data_structures.deques.deque.Deque.get_last","text":"Return last element of the deque without removing it Returns: Type Description Any last element of deque Source code in deques/deque.py @abstractmethod def get_last ( self ) -> Any : \"\"\"Return last element of the deque without removing it :return: last element of deque \"\"\" pass","title":"get_last()"},{"location":"data_structures/deques/deque/#data_structures.deques.deque.Deque.is_empty","text":"Check if deque contains no elements Returns: Type Description bool True if deque is empty, else False Source code in deques/deque.py @abstractmethod def is_empty ( self ) -> bool : \"\"\"Check if deque contains no elements :return: True if deque is empty, else False \"\"\" pass","title":"is_empty()"},{"location":"data_structures/deques/list_deque/","text":"ListDeque ( Deque ) A deque implemented using python's list data structure __len__ ( self ) special Get the total number of elements stored in the deque >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) >>> len(a_deque) 1 Returns: Type Description int count of elements in deque Source code in deques/list_deque.py def __len__ ( self ) -> int : \"\"\"Get the total number of elements stored in the deque >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) >>> len(a_deque) 1 :returns: count of elements in deque \"\"\" return len ( self . __data_store ) dequeue_first ( self ) Remove first element of the deque and return it >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) >>> a_deque.dequeue_first() 1 Returns: Type Description Any first element of deque Source code in deques/list_deque.py def dequeue_first ( self ) -> Any : \"\"\"Remove first element of the deque and return it >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) >>> a_deque.dequeue_first() 1 :return: first element of deque \"\"\" if self . is_empty (): raise Empty ( \"Deque is empty\" ) return self . __data_store . pop ( 0 ) dequeue_last ( self ) Remove last element of the deque and return it >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) >>> a_deque.dequeue_last() 1 Returns: Type Description Any last element of deque Source code in deques/list_deque.py def dequeue_last ( self ) -> Any : \"\"\"Remove last element of the deque and return it >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) >>> a_deque.dequeue_last() 1 :return: last element of deque \"\"\" if self . is_empty (): raise Empty ( \"Deque is empty\" ) return self . __data_store . pop () enqueue_first ( self , x ) Insert an element to the front of the deque >>> a_deque = ListDeque() >>> a_deque.enqueue_first(1) Parameters: Name Type Description Default x Any element to add to the deque required Source code in deques/list_deque.py def enqueue_first ( self , x : Any ) -> None : \"\"\"Insert an element to the front of the deque >>> a_deque = ListDeque() >>> a_deque.enqueue_first(1) :param x: element to add to the deque \"\"\" self . __data_store . insert ( 0 , x ) enqueue_last ( self , x ) Insert an element to the end of the deque >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) Parameters: Name Type Description Default x Any element to add to the deque required Source code in deques/list_deque.py def enqueue_last ( self , x : Any ) -> None : \"\"\"Insert an element to the end of the deque >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) :param x: element to add to the deque \"\"\" self . __data_store . append ( x ) get_first ( self ) Return first element of the deque without removing it >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) >>> a_deque.get_first() 1 Returns: Type Description Any first element of deque Source code in deques/list_deque.py def get_first ( self ) -> Any : \"\"\"Return first element of the deque without removing it >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) >>> a_deque.get_first() 1 :return: first element of deque \"\"\" if self . is_empty (): raise Empty ( \"Deque is empty\" ) return self . __data_store [ 0 ] get_last ( self ) Return last element of the deque without removing it >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) >>> a_deque.get_last() 1 Returns: Type Description Any last element of deque Source code in deques/list_deque.py def get_last ( self ) -> Any : \"\"\"Return last element of the deque without removing it >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) >>> a_deque.get_last() 1 :return: last element of deque \"\"\" if self . is_empty (): raise Empty ( \"Deque is empty\" ) return self . __data_store [ - 1 ] is_empty ( self ) Check if deque contains no elements >>> a_deque = ListDeque() >>> a_deque.is_empty() True >>> a_deque.enqueue_last(1) >>> a_deque.is_empty() False Returns: Type Description bool True if deque is empty, else False Source code in deques/list_deque.py def is_empty ( self ) -> bool : \"\"\"Check if deque contains no elements >>> a_deque = ListDeque() >>> a_deque.is_empty() True >>> a_deque.enqueue_last(1) >>> a_deque.is_empty() False :return: True if deque is empty, else False \"\"\" return len ( self . __data_store ) == 0","title":"List Deque"},{"location":"data_structures/deques/list_deque/#data_structures.deques.list_deque.ListDeque","text":"A deque implemented using python's list data structure","title":"ListDeque"},{"location":"data_structures/deques/list_deque/#data_structures.deques.list_deque.ListDeque.__len__","text":"Get the total number of elements stored in the deque >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) >>> len(a_deque) 1 Returns: Type Description int count of elements in deque Source code in deques/list_deque.py def __len__ ( self ) -> int : \"\"\"Get the total number of elements stored in the deque >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) >>> len(a_deque) 1 :returns: count of elements in deque \"\"\" return len ( self . __data_store )","title":"__len__()"},{"location":"data_structures/deques/list_deque/#data_structures.deques.list_deque.ListDeque.dequeue_first","text":"Remove first element of the deque and return it >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) >>> a_deque.dequeue_first() 1 Returns: Type Description Any first element of deque Source code in deques/list_deque.py def dequeue_first ( self ) -> Any : \"\"\"Remove first element of the deque and return it >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) >>> a_deque.dequeue_first() 1 :return: first element of deque \"\"\" if self . is_empty (): raise Empty ( \"Deque is empty\" ) return self . __data_store . pop ( 0 )","title":"dequeue_first()"},{"location":"data_structures/deques/list_deque/#data_structures.deques.list_deque.ListDeque.dequeue_last","text":"Remove last element of the deque and return it >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) >>> a_deque.dequeue_last() 1 Returns: Type Description Any last element of deque Source code in deques/list_deque.py def dequeue_last ( self ) -> Any : \"\"\"Remove last element of the deque and return it >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) >>> a_deque.dequeue_last() 1 :return: last element of deque \"\"\" if self . is_empty (): raise Empty ( \"Deque is empty\" ) return self . __data_store . pop ()","title":"dequeue_last()"},{"location":"data_structures/deques/list_deque/#data_structures.deques.list_deque.ListDeque.enqueue_first","text":"Insert an element to the front of the deque >>> a_deque = ListDeque() >>> a_deque.enqueue_first(1) Parameters: Name Type Description Default x Any element to add to the deque required Source code in deques/list_deque.py def enqueue_first ( self , x : Any ) -> None : \"\"\"Insert an element to the front of the deque >>> a_deque = ListDeque() >>> a_deque.enqueue_first(1) :param x: element to add to the deque \"\"\" self . __data_store . insert ( 0 , x )","title":"enqueue_first()"},{"location":"data_structures/deques/list_deque/#data_structures.deques.list_deque.ListDeque.enqueue_last","text":"Insert an element to the end of the deque >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) Parameters: Name Type Description Default x Any element to add to the deque required Source code in deques/list_deque.py def enqueue_last ( self , x : Any ) -> None : \"\"\"Insert an element to the end of the deque >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) :param x: element to add to the deque \"\"\" self . __data_store . append ( x )","title":"enqueue_last()"},{"location":"data_structures/deques/list_deque/#data_structures.deques.list_deque.ListDeque.get_first","text":"Return first element of the deque without removing it >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) >>> a_deque.get_first() 1 Returns: Type Description Any first element of deque Source code in deques/list_deque.py def get_first ( self ) -> Any : \"\"\"Return first element of the deque without removing it >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) >>> a_deque.get_first() 1 :return: first element of deque \"\"\" if self . is_empty (): raise Empty ( \"Deque is empty\" ) return self . __data_store [ 0 ]","title":"get_first()"},{"location":"data_structures/deques/list_deque/#data_structures.deques.list_deque.ListDeque.get_last","text":"Return last element of the deque without removing it >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) >>> a_deque.get_last() 1 Returns: Type Description Any last element of deque Source code in deques/list_deque.py def get_last ( self ) -> Any : \"\"\"Return last element of the deque without removing it >>> a_deque = ListDeque() >>> a_deque.enqueue_last(1) >>> a_deque.get_last() 1 :return: last element of deque \"\"\" if self . is_empty (): raise Empty ( \"Deque is empty\" ) return self . __data_store [ - 1 ]","title":"get_last()"},{"location":"data_structures/deques/list_deque/#data_structures.deques.list_deque.ListDeque.is_empty","text":"Check if deque contains no elements >>> a_deque = ListDeque() >>> a_deque.is_empty() True >>> a_deque.enqueue_last(1) >>> a_deque.is_empty() False Returns: Type Description bool True if deque is empty, else False Source code in deques/list_deque.py def is_empty ( self ) -> bool : \"\"\"Check if deque contains no elements >>> a_deque = ListDeque() >>> a_deque.is_empty() True >>> a_deque.enqueue_last(1) >>> a_deque.is_empty() False :return: True if deque is empty, else False \"\"\" return len ( self . __data_store ) == 0","title":"is_empty()"},{"location":"data_structures/graphs/adjacency_list_graph/","text":"AdjacencyListGraph ( Graph ) An adjacency list graph is a graph implemented based on a mapping of each vertex to a list of all vertices that are adjacent to it. Instantiate an adjacency list graph object >>> directed_graph = AdjacencyListGraph(directed=True) >>> undirected_graph = AdjacencyListGraph(directed=False) Check if a graph is directed >>> directed_graph.is_directed() True >>> undirected_graph.is_directed() False Add a vertex to a graph >>> directed_graph.add_vertex(1, 1000) >>> directed_graph.add_vertex(2, 2000) >>> directed_graph.add_vertex(3, 3000) >>> directed_graph.add_vertex(4, 4000) >>> directed_graph.add_vertex(5, 5000) >>> undirected_graph.add_vertex(1, 1000) >>> undirected_graph.add_vertex(2, 2000) >>> undirected_graph.add_vertex(3, 3000) >>> undirected_graph.add_vertex(4, 4000) >>> undirected_graph.add_vertex(5, 5000) Add an edge to a graph >>> directed_graph.add_edge(1, 2, 100) >>> directed_graph.add_edge(1, 3, 200) >>> directed_graph.add_edge(1, 4, 300) >>> directed_graph.add_edge(2, 3, 400) >>> directed_graph.add_edge(2, 5, 500) >>> directed_graph.add_edge(3, 5, 600) >>> directed_graph.add_edge(4, 5, 700) >>> undirected_graph.add_edge(1, 2, 100) >>> undirected_graph.add_edge(1, 3, 200) >>> undirected_graph.add_edge(1, 4, 300) >>> undirected_graph.add_edge(2, 3, 400) >>> undirected_graph.add_edge(2, 5, 500) >>> undirected_graph.add_edge(3, 5, 600) >>> undirected_graph.add_edge(4, 5, 700) Get keys of all the vertices in a graph >>> directed_graph.get_vertices() [1, 2, 3, 4, 5] >>> undirected_graph.get_vertices() [1, 2, 3, 4, 5] Get all the edges in a graph >>> directed_graph.get_edges() [(1, 2, 100), (1, 3, 200), (1, 4, 300), (2, 3, 400), (2, 5, 500), (3, 5, 600), (4, 5, 700)] >>> undirected_graph.get_edges() [(1, 2, 100), (1, 3, 200), (1, 4, 300), (2, 1, 100), (2, 3, 400), (2, 5, 500), (3, 1, 200), (3, 2, 400), (3, 5, 600), (4, 1, 300), (4, 5, 700), (5, 2, 500), (5, 3, 600), (5, 4, 700)] Check if a pair of vertices form an edge >>> directed_graph.is_edge(1, 2) True >>> directed_graph.is_edge(2, 1) False >>> directed_graph.is_edge(1, 5) False >>> undirected_graph.is_edge(1, 2) True >>> undirected_graph.is_edge(2, 1) True >>> undirected_graph.is_edge(1, 5) False Get incoming edges of a vertex >>> directed_graph.get_incoming_edges(3) [(1, 3, 200), (2, 3, 400)] >>> undirected_graph.get_incoming_edges(3) [(1, 3, 200), (2, 3, 400), (5, 3, 600)] Get outgoing edges of a vertex >>> directed_graph.get_outgoing_edges(3) [(3, 5, 600)] >>> undirected_graph.get_outgoing_edges(3) [(3, 1, 200), (3, 2, 400), (3, 5, 600)] Get the weight of some edge >>> directed_graph.get_edge_weight(1, 2) 100 >>> undirected_graph.get_edge_weight(1, 2) 100 Get adjacent vertices relative to some vertex >>> directed_graph.get_adjacent_vertices(2) [(1, 100), (3, 400), (5, 500)] >>> undirected_graph.get_adjacent_vertices(2) [(1, 100), (3, 400), (5, 500)] Get adjacent incoming vertices relative to some vertex >>> directed_graph.get_incoming_adjacent_vertices(2) [(1, 100)] >>> undirected_graph.get_incoming_adjacent_vertices(2) [(1, 100), (3, 400), (5, 500)] Get adjacent outgoing vertices relative to some vertex >>> directed_graph.get_outgoing_adjacent_vertices(2) [(3, 400), (5, 500)] >>> undirected_graph.get_outgoing_adjacent_vertices(2) [(1, 100), (3, 400), (5, 500)] Get value stored in a vertex >>> directed_graph.get_vertex_value(1) 1000 >>> undirected_graph.get_vertex_value(1) 1000 String representation of a graph >>> str(directed_graph) '{\\n\\t1: [(2, 100), (3, 200), (4, 300)]\\n\\t2: [(3, 400), (5, 500)]\\n\\t3: [(5, 600)]\\n\\t4: [(5, 700)]\\n\\t5: []\\n}' >>> str(undirected_graph).strip() '{\\n\\t1: [(2, 100), (3, 200), (4, 300)]\\n\\t2: [(3, 400), (5, 500)]\\n\\t3: [(5, 600)]\\n\\t4: [(5, 700)]\\n\\t5: []\\n}' Check if a vertex corresponding to some key is contained in the graph >>> 1 in directed_graph True >>> 100 in directed_graph False >>> 1 in undirected_graph True >>> 100 in undirected_graph False Depth-first traversal of a graph >>> [i for i in directed_graph.depth_first_traversal(1)] [(1, 1), (2, 2), (3, 3), (5, 4), (4, 8)] >>> [i for i in undirected_graph.depth_first_traversal(1)] [(1, 1), (2, 2), (3, 3), (5, 4), (4, 8)] Breadth-first traversal of a graph >>> [i for i in directed_graph.breadth_first_traversal(1)] [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] >>> [i for i in undirected_graph.breadth_first_traversal(1)] [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] Delete an edge >>> directed_graph.remove_edge(1, 2) >>> undirected_graph.remove_edge(1, 2) Delete a vertex >>> directed_graph.remove_vertex(1) >>> undirected_graph.remove_vertex(1) add_edge ( self , key1 , key2 , weight = None ) Connect the vertices associated to the passed keys with a new edge Parameters: Name Type Description Default key1 Any the key associated to the first vertex in the pair required key2 Any the key associated to the second vertex in the pair required weight float the cost of traversing the newly formed edge None Source code in graphs/adjacency_list_graph.py def add_edge ( self , key1 : Any , key2 : Any , weight : float = None ) -> None : super () . add_edge ( key1 , key2 , weight ) self . __adjacency_list [ key1 ] . append (( key2 , weight )) add_vertex ( self , key , value = None ) Add a new vertex to the graph Parameters: Name Type Description Default key Any the key to associate to the new vertex required value Any the value to be stored in the new vertex None Source code in graphs/adjacency_list_graph.py def add_vertex ( self , key : Any , value : Any = None ) -> None : super () . add_vertex ( key , value ) self . __adjacency_list [ key ] = [] breadth_first_traversal ( self , key ) Return a generator that yields keys of vertices of the graph when traversed breadth first from some vertex Parameters: Name Type Description Default key Any the key where the traversal begins from required Returns: Type Description Generator a generator of vertex keys Source code in graphs/adjacency_list_graph.py def breadth_first_traversal ( self , key : Any ) -> Generator : yield from super () . breadth_first_traversal ( key ) depth_first_traversal ( self , key ) Return a generator that yields keys of vertices of the graph when traversed depth first from some vertex Parameters: Name Type Description Default key Any the key where the traversal begins from required Returns: Type Description Generator a generator of vertex keys Source code in graphs/adjacency_list_graph.py def depth_first_traversal ( self , key : Any ) -> Generator : yield from super () . depth_first_traversal ( key ) get_adjacent_vertices ( self , key ) Return a list of keys of all the vertices connected to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex all adjacent vertices' keys are being sought required Returns: Type Description list a list of vertex keys Source code in graphs/adjacency_list_graph.py def get_adjacent_vertices ( self , key : Any ) -> list : super () . get_adjacent_vertices ( key ) vertices = [] for k , adjacent in self . __adjacency_list . items (): if k != key : for i in adjacent : if i [ 0 ] == key : vertices . append (( k , i [ 1 ])) else : vertices . extend ( adjacent ) return vertices get_edge_weight ( self , key1 , key2 ) Return the weight associated with the edge connecting the vertices associated with the vertices of the passed keys Parameters: Name Type Description Default key1 Any the key of the first vertex in the edge pair required key2 Any the key of the second vertex in the edge pair required Returns: Type Description float weight of the edge Source code in graphs/adjacency_list_graph.py def get_edge_weight ( self , key1 : Any , key2 : Any ) -> float : return super () . get_edge_weight ( key1 , key2 ) get_edges ( self ) Return a list of all the edges in the graph Returns: Type Description list a list of all the edges Source code in graphs/adjacency_list_graph.py def get_edges ( self ) -> list : return super () . get_edges () get_incoming_adjacent_vertices ( self , key ) Return a list of keys of all the vertices incoming to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex all incoming vertices' keys are being sought required Returns: Type Description list a list of vertex keys Source code in graphs/adjacency_list_graph.py def get_incoming_adjacent_vertices ( self , key : Any ) -> list : super () . get_incoming_adjacent_vertices ( key ) vertices = [] for k , adjacent in self . __adjacency_list . items (): if k != key : for i in adjacent : if i [ 0 ] == key : vertices . append (( k , i [ 1 ])) else : if not self . is_directed (): vertices . extend ( adjacent ) return vertices get_incoming_edges ( self , key ) Return a list of incoming edges corresponding to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex a list of incoming edges is being sought required Returns: Type Description list a list of edges Source code in graphs/adjacency_list_graph.py def get_incoming_edges ( self , key : Any ) -> list : return super () . get_incoming_edges ( key ) get_outgoing_adjacent_vertices ( self , key ) Return a list of keys of all the vertices outgoing from the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex all outgoing vertices' keys are being sought required Returns: Type Description list a list of vertex keys Source code in graphs/adjacency_list_graph.py def get_outgoing_adjacent_vertices ( self , key : Any ) -> list : super () . get_outgoing_adjacent_vertices ( key ) vertices = [] for k , adjacent in self . __adjacency_list . items (): if k != key : if not self . is_directed (): for i in adjacent : if i [ 0 ] == key : vertices . append (( k , i [ 1 ])) else : vertices . extend ( adjacent ) return vertices get_outgoing_edges ( self , key ) Return a list of outgoing edges corresponding to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex a list of outgoing edges is being sought required Returns: Type Description list a list of edges Source code in graphs/adjacency_list_graph.py def get_outgoing_edges ( self , key : Any ) -> list : return super () . get_outgoing_edges ( key ) is_edge ( self , key1 , key2 ) Check if a pair of vertices form an edge Parameters: Name Type Description Default key1 Any the key of the first vertex in the edge pair required key2 Any the key of the second vertex in the edge pair required Returns: Type Description bool True if the passed pair form an edge, else False Source code in graphs/adjacency_list_graph.py def is_edge ( self , key1 : Any , key2 : Any ) -> bool : return super () . is_edge ( key1 , key2 ) remove_edge ( self , key1 , key2 ) Delete the edge connecting the vertices associated with the passed keys Parameters: Name Type Description Default key1 Any the key associated with the first vertex of the edge pair required key2 Any the key associated with the second vertex of the edge pair required Source code in graphs/adjacency_list_graph.py def remove_edge ( self , key1 : Any , key2 : Any ) -> None : super () . remove_edge ( key1 , key2 ) for i in self . get_adjacent_vertices ( key1 ): if key2 == i [ 0 ]: self . __adjacency_list [ key1 ] . remove ( i ) return if not self . is_directed (): for i in self . get_adjacent_vertices ( key2 ): if key1 == i [ 0 ]: self . __adjacency_list [ key2 ] . remove ( i ) return raise ValueError ( f \"Edge ( { key1 } , { key2 } ) is absent from the graph\" ) remove_vertex ( self , key ) Delete the vertex associated to the passed key Parameters: Name Type Description Default key Any the key whose vertex id to be deleted required Source code in graphs/adjacency_list_graph.py def remove_vertex ( self , key : Any ) -> None : super () . remove_vertex ( key ) del self . __adjacency_list [ key ]","title":"Adjacency List Graph"},{"location":"data_structures/graphs/adjacency_list_graph/#data_structures.graphs.adjacency_list_graph.AdjacencyListGraph","text":"An adjacency list graph is a graph implemented based on a mapping of each vertex to a list of all vertices that are adjacent to it. Instantiate an adjacency list graph object >>> directed_graph = AdjacencyListGraph(directed=True) >>> undirected_graph = AdjacencyListGraph(directed=False) Check if a graph is directed >>> directed_graph.is_directed() True >>> undirected_graph.is_directed() False Add a vertex to a graph >>> directed_graph.add_vertex(1, 1000) >>> directed_graph.add_vertex(2, 2000) >>> directed_graph.add_vertex(3, 3000) >>> directed_graph.add_vertex(4, 4000) >>> directed_graph.add_vertex(5, 5000) >>> undirected_graph.add_vertex(1, 1000) >>> undirected_graph.add_vertex(2, 2000) >>> undirected_graph.add_vertex(3, 3000) >>> undirected_graph.add_vertex(4, 4000) >>> undirected_graph.add_vertex(5, 5000) Add an edge to a graph >>> directed_graph.add_edge(1, 2, 100) >>> directed_graph.add_edge(1, 3, 200) >>> directed_graph.add_edge(1, 4, 300) >>> directed_graph.add_edge(2, 3, 400) >>> directed_graph.add_edge(2, 5, 500) >>> directed_graph.add_edge(3, 5, 600) >>> directed_graph.add_edge(4, 5, 700) >>> undirected_graph.add_edge(1, 2, 100) >>> undirected_graph.add_edge(1, 3, 200) >>> undirected_graph.add_edge(1, 4, 300) >>> undirected_graph.add_edge(2, 3, 400) >>> undirected_graph.add_edge(2, 5, 500) >>> undirected_graph.add_edge(3, 5, 600) >>> undirected_graph.add_edge(4, 5, 700) Get keys of all the vertices in a graph >>> directed_graph.get_vertices() [1, 2, 3, 4, 5] >>> undirected_graph.get_vertices() [1, 2, 3, 4, 5] Get all the edges in a graph >>> directed_graph.get_edges() [(1, 2, 100), (1, 3, 200), (1, 4, 300), (2, 3, 400), (2, 5, 500), (3, 5, 600), (4, 5, 700)] >>> undirected_graph.get_edges() [(1, 2, 100), (1, 3, 200), (1, 4, 300), (2, 1, 100), (2, 3, 400), (2, 5, 500), (3, 1, 200), (3, 2, 400), (3, 5, 600), (4, 1, 300), (4, 5, 700), (5, 2, 500), (5, 3, 600), (5, 4, 700)] Check if a pair of vertices form an edge >>> directed_graph.is_edge(1, 2) True >>> directed_graph.is_edge(2, 1) False >>> directed_graph.is_edge(1, 5) False >>> undirected_graph.is_edge(1, 2) True >>> undirected_graph.is_edge(2, 1) True >>> undirected_graph.is_edge(1, 5) False Get incoming edges of a vertex >>> directed_graph.get_incoming_edges(3) [(1, 3, 200), (2, 3, 400)] >>> undirected_graph.get_incoming_edges(3) [(1, 3, 200), (2, 3, 400), (5, 3, 600)] Get outgoing edges of a vertex >>> directed_graph.get_outgoing_edges(3) [(3, 5, 600)] >>> undirected_graph.get_outgoing_edges(3) [(3, 1, 200), (3, 2, 400), (3, 5, 600)] Get the weight of some edge >>> directed_graph.get_edge_weight(1, 2) 100 >>> undirected_graph.get_edge_weight(1, 2) 100 Get adjacent vertices relative to some vertex >>> directed_graph.get_adjacent_vertices(2) [(1, 100), (3, 400), (5, 500)] >>> undirected_graph.get_adjacent_vertices(2) [(1, 100), (3, 400), (5, 500)] Get adjacent incoming vertices relative to some vertex >>> directed_graph.get_incoming_adjacent_vertices(2) [(1, 100)] >>> undirected_graph.get_incoming_adjacent_vertices(2) [(1, 100), (3, 400), (5, 500)] Get adjacent outgoing vertices relative to some vertex >>> directed_graph.get_outgoing_adjacent_vertices(2) [(3, 400), (5, 500)] >>> undirected_graph.get_outgoing_adjacent_vertices(2) [(1, 100), (3, 400), (5, 500)] Get value stored in a vertex >>> directed_graph.get_vertex_value(1) 1000 >>> undirected_graph.get_vertex_value(1) 1000 String representation of a graph >>> str(directed_graph) '{\\n\\t1: [(2, 100), (3, 200), (4, 300)]\\n\\t2: [(3, 400), (5, 500)]\\n\\t3: [(5, 600)]\\n\\t4: [(5, 700)]\\n\\t5: []\\n}' >>> str(undirected_graph).strip() '{\\n\\t1: [(2, 100), (3, 200), (4, 300)]\\n\\t2: [(3, 400), (5, 500)]\\n\\t3: [(5, 600)]\\n\\t4: [(5, 700)]\\n\\t5: []\\n}' Check if a vertex corresponding to some key is contained in the graph >>> 1 in directed_graph True >>> 100 in directed_graph False >>> 1 in undirected_graph True >>> 100 in undirected_graph False Depth-first traversal of a graph >>> [i for i in directed_graph.depth_first_traversal(1)] [(1, 1), (2, 2), (3, 3), (5, 4), (4, 8)] >>> [i for i in undirected_graph.depth_first_traversal(1)] [(1, 1), (2, 2), (3, 3), (5, 4), (4, 8)] Breadth-first traversal of a graph >>> [i for i in directed_graph.breadth_first_traversal(1)] [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] >>> [i for i in undirected_graph.breadth_first_traversal(1)] [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] Delete an edge >>> directed_graph.remove_edge(1, 2) >>> undirected_graph.remove_edge(1, 2) Delete a vertex >>> directed_graph.remove_vertex(1) >>> undirected_graph.remove_vertex(1)","title":"AdjacencyListGraph"},{"location":"data_structures/graphs/adjacency_list_graph/#data_structures.graphs.adjacency_list_graph.AdjacencyListGraph.add_edge","text":"Connect the vertices associated to the passed keys with a new edge Parameters: Name Type Description Default key1 Any the key associated to the first vertex in the pair required key2 Any the key associated to the second vertex in the pair required weight float the cost of traversing the newly formed edge None Source code in graphs/adjacency_list_graph.py def add_edge ( self , key1 : Any , key2 : Any , weight : float = None ) -> None : super () . add_edge ( key1 , key2 , weight ) self . __adjacency_list [ key1 ] . append (( key2 , weight ))","title":"add_edge()"},{"location":"data_structures/graphs/adjacency_list_graph/#data_structures.graphs.adjacency_list_graph.AdjacencyListGraph.add_vertex","text":"Add a new vertex to the graph Parameters: Name Type Description Default key Any the key to associate to the new vertex required value Any the value to be stored in the new vertex None Source code in graphs/adjacency_list_graph.py def add_vertex ( self , key : Any , value : Any = None ) -> None : super () . add_vertex ( key , value ) self . __adjacency_list [ key ] = []","title":"add_vertex()"},{"location":"data_structures/graphs/adjacency_list_graph/#data_structures.graphs.adjacency_list_graph.AdjacencyListGraph.breadth_first_traversal","text":"Return a generator that yields keys of vertices of the graph when traversed breadth first from some vertex Parameters: Name Type Description Default key Any the key where the traversal begins from required Returns: Type Description Generator a generator of vertex keys Source code in graphs/adjacency_list_graph.py def breadth_first_traversal ( self , key : Any ) -> Generator : yield from super () . breadth_first_traversal ( key )","title":"breadth_first_traversal()"},{"location":"data_structures/graphs/adjacency_list_graph/#data_structures.graphs.adjacency_list_graph.AdjacencyListGraph.depth_first_traversal","text":"Return a generator that yields keys of vertices of the graph when traversed depth first from some vertex Parameters: Name Type Description Default key Any the key where the traversal begins from required Returns: Type Description Generator a generator of vertex keys Source code in graphs/adjacency_list_graph.py def depth_first_traversal ( self , key : Any ) -> Generator : yield from super () . depth_first_traversal ( key )","title":"depth_first_traversal()"},{"location":"data_structures/graphs/adjacency_list_graph/#data_structures.graphs.adjacency_list_graph.AdjacencyListGraph.get_adjacent_vertices","text":"Return a list of keys of all the vertices connected to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex all adjacent vertices' keys are being sought required Returns: Type Description list a list of vertex keys Source code in graphs/adjacency_list_graph.py def get_adjacent_vertices ( self , key : Any ) -> list : super () . get_adjacent_vertices ( key ) vertices = [] for k , adjacent in self . __adjacency_list . items (): if k != key : for i in adjacent : if i [ 0 ] == key : vertices . append (( k , i [ 1 ])) else : vertices . extend ( adjacent ) return vertices","title":"get_adjacent_vertices()"},{"location":"data_structures/graphs/adjacency_list_graph/#data_structures.graphs.adjacency_list_graph.AdjacencyListGraph.get_edge_weight","text":"Return the weight associated with the edge connecting the vertices associated with the vertices of the passed keys Parameters: Name Type Description Default key1 Any the key of the first vertex in the edge pair required key2 Any the key of the second vertex in the edge pair required Returns: Type Description float weight of the edge Source code in graphs/adjacency_list_graph.py def get_edge_weight ( self , key1 : Any , key2 : Any ) -> float : return super () . get_edge_weight ( key1 , key2 )","title":"get_edge_weight()"},{"location":"data_structures/graphs/adjacency_list_graph/#data_structures.graphs.adjacency_list_graph.AdjacencyListGraph.get_edges","text":"Return a list of all the edges in the graph Returns: Type Description list a list of all the edges Source code in graphs/adjacency_list_graph.py def get_edges ( self ) -> list : return super () . get_edges ()","title":"get_edges()"},{"location":"data_structures/graphs/adjacency_list_graph/#data_structures.graphs.adjacency_list_graph.AdjacencyListGraph.get_incoming_adjacent_vertices","text":"Return a list of keys of all the vertices incoming to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex all incoming vertices' keys are being sought required Returns: Type Description list a list of vertex keys Source code in graphs/adjacency_list_graph.py def get_incoming_adjacent_vertices ( self , key : Any ) -> list : super () . get_incoming_adjacent_vertices ( key ) vertices = [] for k , adjacent in self . __adjacency_list . items (): if k != key : for i in adjacent : if i [ 0 ] == key : vertices . append (( k , i [ 1 ])) else : if not self . is_directed (): vertices . extend ( adjacent ) return vertices","title":"get_incoming_adjacent_vertices()"},{"location":"data_structures/graphs/adjacency_list_graph/#data_structures.graphs.adjacency_list_graph.AdjacencyListGraph.get_incoming_edges","text":"Return a list of incoming edges corresponding to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex a list of incoming edges is being sought required Returns: Type Description list a list of edges Source code in graphs/adjacency_list_graph.py def get_incoming_edges ( self , key : Any ) -> list : return super () . get_incoming_edges ( key )","title":"get_incoming_edges()"},{"location":"data_structures/graphs/adjacency_list_graph/#data_structures.graphs.adjacency_list_graph.AdjacencyListGraph.get_outgoing_adjacent_vertices","text":"Return a list of keys of all the vertices outgoing from the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex all outgoing vertices' keys are being sought required Returns: Type Description list a list of vertex keys Source code in graphs/adjacency_list_graph.py def get_outgoing_adjacent_vertices ( self , key : Any ) -> list : super () . get_outgoing_adjacent_vertices ( key ) vertices = [] for k , adjacent in self . __adjacency_list . items (): if k != key : if not self . is_directed (): for i in adjacent : if i [ 0 ] == key : vertices . append (( k , i [ 1 ])) else : vertices . extend ( adjacent ) return vertices","title":"get_outgoing_adjacent_vertices()"},{"location":"data_structures/graphs/adjacency_list_graph/#data_structures.graphs.adjacency_list_graph.AdjacencyListGraph.get_outgoing_edges","text":"Return a list of outgoing edges corresponding to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex a list of outgoing edges is being sought required Returns: Type Description list a list of edges Source code in graphs/adjacency_list_graph.py def get_outgoing_edges ( self , key : Any ) -> list : return super () . get_outgoing_edges ( key )","title":"get_outgoing_edges()"},{"location":"data_structures/graphs/adjacency_list_graph/#data_structures.graphs.adjacency_list_graph.AdjacencyListGraph.is_edge","text":"Check if a pair of vertices form an edge Parameters: Name Type Description Default key1 Any the key of the first vertex in the edge pair required key2 Any the key of the second vertex in the edge pair required Returns: Type Description bool True if the passed pair form an edge, else False Source code in graphs/adjacency_list_graph.py def is_edge ( self , key1 : Any , key2 : Any ) -> bool : return super () . is_edge ( key1 , key2 )","title":"is_edge()"},{"location":"data_structures/graphs/adjacency_list_graph/#data_structures.graphs.adjacency_list_graph.AdjacencyListGraph.remove_edge","text":"Delete the edge connecting the vertices associated with the passed keys Parameters: Name Type Description Default key1 Any the key associated with the first vertex of the edge pair required key2 Any the key associated with the second vertex of the edge pair required Source code in graphs/adjacency_list_graph.py def remove_edge ( self , key1 : Any , key2 : Any ) -> None : super () . remove_edge ( key1 , key2 ) for i in self . get_adjacent_vertices ( key1 ): if key2 == i [ 0 ]: self . __adjacency_list [ key1 ] . remove ( i ) return if not self . is_directed (): for i in self . get_adjacent_vertices ( key2 ): if key1 == i [ 0 ]: self . __adjacency_list [ key2 ] . remove ( i ) return raise ValueError ( f \"Edge ( { key1 } , { key2 } ) is absent from the graph\" )","title":"remove_edge()"},{"location":"data_structures/graphs/adjacency_list_graph/#data_structures.graphs.adjacency_list_graph.AdjacencyListGraph.remove_vertex","text":"Delete the vertex associated to the passed key Parameters: Name Type Description Default key Any the key whose vertex id to be deleted required Source code in graphs/adjacency_list_graph.py def remove_vertex ( self , key : Any ) -> None : super () . remove_vertex ( key ) del self . __adjacency_list [ key ]","title":"remove_vertex()"},{"location":"data_structures/graphs/adjacency_matrix_graph/","text":"AdjacencyMatrixGraph ( Graph ) An adjacency matrix graph is a graph implemented based on a 2-dimensional array-like structure with the vertices of the graph aligned to both axes. The intersection of both axes marks that the corresponding vertices are connected with an edge, with the value contained at the intersection denoting the weight of the edge. An empty intersection denotes that the corresponding vertices are not connected. Instantiate an adjacency matrix graph object >>> directed_graph = AdjacencyMatrixGraph(directed=True) >>> undirected_graph = AdjacencyMatrixGraph(directed=False) Check if a graph is directed >>> directed_graph.is_directed() True >>> undirected_graph.is_directed() False Add a vertex to a graph >>> directed_graph.add_vertex(1, 1000) >>> directed_graph.add_vertex(2, 2000) >>> directed_graph.add_vertex(3, 3000) >>> directed_graph.add_vertex(4, 4000) >>> directed_graph.add_vertex(5, 5000) >>> undirected_graph.add_vertex(1, 1000) >>> undirected_graph.add_vertex(2, 2000) >>> undirected_graph.add_vertex(3, 3000) >>> undirected_graph.add_vertex(4, 4000) >>> undirected_graph.add_vertex(5, 5000) Add an edge to a graph >>> directed_graph.add_edge(1, 2, 100) >>> directed_graph.add_edge(1, 3, 200) >>> directed_graph.add_edge(1, 4, 300) >>> directed_graph.add_edge(2, 3, 400) >>> directed_graph.add_edge(2, 5, 500) >>> directed_graph.add_edge(3, 5, 600) >>> directed_graph.add_edge(4, 5, 700) >>> undirected_graph.add_edge(1, 2, 100) >>> undirected_graph.add_edge(1, 3, 200) >>> undirected_graph.add_edge(1, 4, 300) >>> undirected_graph.add_edge(2, 3, 400) >>> undirected_graph.add_edge(2, 5, 500) >>> undirected_graph.add_edge(3, 5, 600) >>> undirected_graph.add_edge(4, 5, 700) Get keys of all the vertices in a graph >>> directed_graph.get_vertices() [1, 2, 3, 4, 5] >>> undirected_graph.get_vertices() [1, 2, 3, 4, 5] Get all the edges in a graph >>> directed_graph.get_edges() [(1, 2, 100), (1, 3, 200), (1, 4, 300), (2, 3, 400), (2, 5, 500), (3, 5, 600), (4, 5, 700)] >>> undirected_graph.get_edges() [(1, 2, 100), (1, 3, 200), (1, 4, 300), (2, 1, 100), (2, 3, 400), (2, 5, 500), (3, 1, 200), (3, 2, 400), (3, 5, 600), (4, 1, 300), (4, 5, 700), (5, 2, 500), (5, 3, 600), (5, 4, 700)] Check if a pair of vertices form an edge >>> directed_graph.is_edge(1, 2) True >>> directed_graph.is_edge(2, 1) False >>> directed_graph.is_edge(1, 5) False >>> undirected_graph.is_edge(1, 2) True >>> undirected_graph.is_edge(2, 1) True >>> undirected_graph.is_edge(1, 5) False Get incoming edges of a vertex >>> directed_graph.get_incoming_edges(3) [(1, 3, 200), (2, 3, 400)] >>> undirected_graph.get_incoming_edges(3) [(1, 3, 200), (2, 3, 400), (5, 3, 600)] Get outgoing edges of a vertex >>> directed_graph.get_outgoing_edges(3) [(3, 5, 600)] >>> undirected_graph.get_outgoing_edges(3) [(3, 1, 200), (3, 2, 400), (3, 5, 600)] Get the weight of some edge >>> directed_graph.get_edge_weight(1, 2) 100 >>> undirected_graph.get_edge_weight(1, 2) 100 Get adjacent vertices relative to some vertex >>> directed_graph.get_adjacent_vertices(2) [(1, 100), (3, 400), (5, 500)] >>> undirected_graph.get_adjacent_vertices(2) [(1, 100), (3, 400), (5, 500)] Get adjacent incoming vertices relative to some vertex >>> directed_graph.get_incoming_adjacent_vertices(2) [(1, 100)] >>> undirected_graph.get_incoming_adjacent_vertices(2) [(1, 100), (3, 400), (5, 500)] Get adjacent outgoing vertices relative to some vertex >>> directed_graph.get_outgoing_adjacent_vertices(2) [(3, 400), (5, 500)] >>> undirected_graph.get_outgoing_adjacent_vertices(2) [(1, 100), (3, 400), (5, 500)] Get value stored in a vertex >>> directed_graph.get_vertex_value(1) 1000 >>> undirected_graph.get_vertex_value(1) 1000 String representation of a graph >>> str(directed_graph) '[-, 100, 200, 300, -]\\n[-, -, 400, -, 500]\\n[-, -, -, -, 600]\\n[-, -, -, -, 700]\\n[-, -, -, -, -]' >>> str(undirected_graph).strip() '[-, 100, 200, 300, -]\\n[-, -, 400, -, 500]\\n[-, -, -, -, 600]\\n[-, -, -, -, 700]\\n[-, -, -, -, -]' Check if a vertex corresponding to some key is contained in the graph >>> 1 in directed_graph True >>> 100 in directed_graph False >>> 1 in undirected_graph True >>> 100 in undirected_graph False Depth-first traversal of a graph >>> [i for i in directed_graph.depth_first_traversal(1)] [(1, 1), (2, 2), (3, 3), (5, 4), (4, 8)] >>> [i for i in undirected_graph.depth_first_traversal(1)] [(1, 1), (2, 2), (3, 3), (5, 4), (4, 8)] Breadth-first traversal of a graph >>> [i for i in directed_graph.breadth_first_traversal(1)] [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] >>> [i for i in undirected_graph.breadth_first_traversal(1)] [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] Delete an edge >>> directed_graph.remove_edge(1, 2) >>> undirected_graph.remove_edge(1, 2) Delete a vertex >>> directed_graph.remove_vertex(1) >>> undirected_graph.remove_vertex(1) add_edge ( self , key1 , key2 , weight = None ) Connect the vertices associated to the passed keys with a new edge Parameters: Name Type Description Default key1 Any the key associated to the first vertex in the pair required key2 Any the key associated to the second vertex in the pair required weight float the cost of traversing the newly formed edge None Source code in graphs/adjacency_matrix_graph.py def add_edge ( self , key1 : Any , key2 : Any , weight : float = None ) -> None : super () . add_edge ( key1 , key2 , weight ) idx1 = self . _keys . index ( key1 ) idx2 = self . _keys . index ( key2 ) self . __adjacency_matrix [ idx1 ][ idx2 ] = weight add_vertex ( self , key , value = None ) Add a new vertex to the graph Parameters: Name Type Description Default key Any the key to associate to the new vertex required value Any the value to be stored in the new vertex None Source code in graphs/adjacency_matrix_graph.py def add_vertex ( self , key : Any , value : Any = None ) -> None : super () . add_vertex ( key , value ) self . __adjacency_matrix . append ( [ AdjacencyMatrixGraph . _Empty () for _ in range ( len ( self . _keys ) - 1 )] ) for row in self . __adjacency_matrix : row . append ( AdjacencyMatrixGraph . _Empty ()) breadth_first_traversal ( self , key ) Return a generator that yields keys of vertices of the graph when traversed breadth first from some vertex Parameters: Name Type Description Default key Any the key where the traversal begins from required Returns: Type Description Generator a generator of vertex keys Source code in graphs/adjacency_matrix_graph.py def breadth_first_traversal ( self , key : Any ) -> Generator : yield from super () . breadth_first_traversal ( key ) depth_first_traversal ( self , key ) Return a generator that yields keys of vertices of the graph when traversed depth first from some vertex Parameters: Name Type Description Default key Any the key where the traversal begins from required Returns: Type Description Generator a generator of vertex keys Source code in graphs/adjacency_matrix_graph.py def depth_first_traversal ( self , key : Any ) -> Generator : yield from super () . depth_first_traversal ( key ) get_adjacent_vertices ( self , key ) Return a list of keys of all the vertices connected to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex all adjacent vertices' keys are being sought required Returns: Type Description list a list of vertex keys Source code in graphs/adjacency_matrix_graph.py def get_adjacent_vertices ( self , key : Any ) -> list : super () . get_adjacent_vertices ( key ) idx = self . _keys . index ( key ) vertices = [] for i , row in enumerate ( self . __adjacency_matrix ): if i != idx : for j , weight in enumerate ( row ): if j == idx and not isinstance ( weight , AdjacencyMatrixGraph . _Empty ): vertices . append (( self . _keys [ i ], weight )) else : vertices . extend ( [ ( self . _keys [ j ], weight ) for j , weight in enumerate ( row ) if not isinstance ( weight , AdjacencyMatrixGraph . _Empty ) ] ) return vertices get_edge_weight ( self , key1 , key2 ) Return the weight associated with the edge connecting the vertices associated with the vertices of the passed keys Parameters: Name Type Description Default key1 Any the key of the first vertex in the edge pair required key2 Any the key of the second vertex in the edge pair required Returns: Type Description float weight of the edge Source code in graphs/adjacency_matrix_graph.py def get_edge_weight ( self , key1 : Any , key2 : Any ) -> float : return super () . get_edge_weight ( key1 , key2 ) get_edges ( self ) Return a list of all the edges in the graph Returns: Type Description list a list of all the edges Source code in graphs/adjacency_matrix_graph.py def get_edges ( self ) -> list : return super () . get_edges () get_incoming_adjacent_vertices ( self , key ) Return a list of keys of all the vertices incoming to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex all incoming vertices' keys are being sought required Returns: Type Description list a list of vertex keys Source code in graphs/adjacency_matrix_graph.py def get_incoming_adjacent_vertices ( self , key : Any ) -> list : super () . get_incoming_adjacent_vertices ( key ) idx = self . _keys . index ( key ) vertices = [] for i , row in enumerate ( self . __adjacency_matrix ): if i != idx : for j , weight in enumerate ( row ): if j == idx and not isinstance ( weight , AdjacencyMatrixGraph . _Empty ): vertices . append (( self . _keys [ i ], weight )) else : if not self . is_directed (): vertices . extend ( [ ( self . _keys [ j ], weight ) for j , weight in enumerate ( row ) if not isinstance ( weight , AdjacencyMatrixGraph . _Empty ) ] ) return vertices get_incoming_edges ( self , key ) Return a list of incoming edges corresponding to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex a list of incoming edges is being sought required Returns: Type Description list a list of edges Source code in graphs/adjacency_matrix_graph.py def get_incoming_edges ( self , key : Any ) -> list : return super () . get_incoming_edges ( key ) get_outgoing_adjacent_vertices ( self , key ) Return a list of keys of all the vertices outgoing from the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex all outgoing vertices' keys are being sought required Returns: Type Description list a list of vertex keys Source code in graphs/adjacency_matrix_graph.py def get_outgoing_adjacent_vertices ( self , key : Any ) -> list : super () . get_outgoing_adjacent_vertices ( key ) idx = self . _keys . index ( key ) vertices = [] for i , row in enumerate ( self . __adjacency_matrix ): if i != idx : if not self . is_directed (): for j , weight in enumerate ( row ): if j == idx and not isinstance ( weight , AdjacencyMatrixGraph . _Empty ): vertices . append (( self . _keys [ i ], weight )) else : vertices . extend ( [ ( self . _keys [ j ], weight ) for j , weight in enumerate ( row ) if not isinstance ( weight , AdjacencyMatrixGraph . _Empty ) ] ) return vertices get_outgoing_edges ( self , key ) Return a list of outgoing edges corresponding to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex a list of outgoing edges is being sought required Returns: Type Description list a list of edges Source code in graphs/adjacency_matrix_graph.py def get_outgoing_edges ( self , key : Any ) -> list : return super () . get_outgoing_edges ( key ) is_edge ( self , key1 , key2 ) Check if a pair of vertices form an edge Parameters: Name Type Description Default key1 Any the key of the first vertex in the edge pair required key2 Any the key of the second vertex in the edge pair required Returns: Type Description bool True if the passed pair form an edge, else False Source code in graphs/adjacency_matrix_graph.py def is_edge ( self , key1 : Any , key2 : Any ) -> bool : return super () . is_edge ( key1 , key2 ) remove_edge ( self , key1 , key2 ) Delete the edge connecting the vertices associated with the passed keys Parameters: Name Type Description Default key1 Any the key associated with the first vertex of the edge pair required key2 Any the key associated with the second vertex of the edge pair required Source code in graphs/adjacency_matrix_graph.py def remove_edge ( self , key1 : Any , key2 : Any ) -> None : super () . remove_edge ( key1 , key2 ) for i in self . get_adjacent_vertices ( key1 ): if key2 == i [ 0 ]: idx1 = self . _keys . index ( key1 ) idx2 = self . _keys . index ( key2 ) self . __adjacency_matrix [ idx1 ][ idx2 ] = AdjacencyMatrixGraph . _Empty () return if not self . is_directed (): for i in self . get_adjacent_vertices ( key2 ): if key1 == i [ 0 ]: idx1 = self . _keys . index ( key1 ) idx2 = self . _keys . index ( key2 ) self . __adjacency_matrix [ idx2 ][ idx1 ] = AdjacencyMatrixGraph . _Empty () return raise ValueError ( f \"Edge ( { key1 } , { key2 } ) is absent from the graph\" ) remove_vertex ( self , key ) Delete the vertex associated to the passed key Parameters: Name Type Description Default key Any the key whose vertex id to be deleted required Source code in graphs/adjacency_matrix_graph.py def remove_vertex ( self , key : Any ) -> None : idx = None if key in self : idx = self . _keys . index ( key ) super () . remove_vertex ( key ) del self . __adjacency_matrix [ idx ] for i in range ( len ( self . __adjacency_matrix )): del self . __adjacency_matrix [ i ][ idx ]","title":"Adjacency Matrix Graph"},{"location":"data_structures/graphs/adjacency_matrix_graph/#data_structures.graphs.adjacency_matrix_graph.AdjacencyMatrixGraph","text":"An adjacency matrix graph is a graph implemented based on a 2-dimensional array-like structure with the vertices of the graph aligned to both axes. The intersection of both axes marks that the corresponding vertices are connected with an edge, with the value contained at the intersection denoting the weight of the edge. An empty intersection denotes that the corresponding vertices are not connected. Instantiate an adjacency matrix graph object >>> directed_graph = AdjacencyMatrixGraph(directed=True) >>> undirected_graph = AdjacencyMatrixGraph(directed=False) Check if a graph is directed >>> directed_graph.is_directed() True >>> undirected_graph.is_directed() False Add a vertex to a graph >>> directed_graph.add_vertex(1, 1000) >>> directed_graph.add_vertex(2, 2000) >>> directed_graph.add_vertex(3, 3000) >>> directed_graph.add_vertex(4, 4000) >>> directed_graph.add_vertex(5, 5000) >>> undirected_graph.add_vertex(1, 1000) >>> undirected_graph.add_vertex(2, 2000) >>> undirected_graph.add_vertex(3, 3000) >>> undirected_graph.add_vertex(4, 4000) >>> undirected_graph.add_vertex(5, 5000) Add an edge to a graph >>> directed_graph.add_edge(1, 2, 100) >>> directed_graph.add_edge(1, 3, 200) >>> directed_graph.add_edge(1, 4, 300) >>> directed_graph.add_edge(2, 3, 400) >>> directed_graph.add_edge(2, 5, 500) >>> directed_graph.add_edge(3, 5, 600) >>> directed_graph.add_edge(4, 5, 700) >>> undirected_graph.add_edge(1, 2, 100) >>> undirected_graph.add_edge(1, 3, 200) >>> undirected_graph.add_edge(1, 4, 300) >>> undirected_graph.add_edge(2, 3, 400) >>> undirected_graph.add_edge(2, 5, 500) >>> undirected_graph.add_edge(3, 5, 600) >>> undirected_graph.add_edge(4, 5, 700) Get keys of all the vertices in a graph >>> directed_graph.get_vertices() [1, 2, 3, 4, 5] >>> undirected_graph.get_vertices() [1, 2, 3, 4, 5] Get all the edges in a graph >>> directed_graph.get_edges() [(1, 2, 100), (1, 3, 200), (1, 4, 300), (2, 3, 400), (2, 5, 500), (3, 5, 600), (4, 5, 700)] >>> undirected_graph.get_edges() [(1, 2, 100), (1, 3, 200), (1, 4, 300), (2, 1, 100), (2, 3, 400), (2, 5, 500), (3, 1, 200), (3, 2, 400), (3, 5, 600), (4, 1, 300), (4, 5, 700), (5, 2, 500), (5, 3, 600), (5, 4, 700)] Check if a pair of vertices form an edge >>> directed_graph.is_edge(1, 2) True >>> directed_graph.is_edge(2, 1) False >>> directed_graph.is_edge(1, 5) False >>> undirected_graph.is_edge(1, 2) True >>> undirected_graph.is_edge(2, 1) True >>> undirected_graph.is_edge(1, 5) False Get incoming edges of a vertex >>> directed_graph.get_incoming_edges(3) [(1, 3, 200), (2, 3, 400)] >>> undirected_graph.get_incoming_edges(3) [(1, 3, 200), (2, 3, 400), (5, 3, 600)] Get outgoing edges of a vertex >>> directed_graph.get_outgoing_edges(3) [(3, 5, 600)] >>> undirected_graph.get_outgoing_edges(3) [(3, 1, 200), (3, 2, 400), (3, 5, 600)] Get the weight of some edge >>> directed_graph.get_edge_weight(1, 2) 100 >>> undirected_graph.get_edge_weight(1, 2) 100 Get adjacent vertices relative to some vertex >>> directed_graph.get_adjacent_vertices(2) [(1, 100), (3, 400), (5, 500)] >>> undirected_graph.get_adjacent_vertices(2) [(1, 100), (3, 400), (5, 500)] Get adjacent incoming vertices relative to some vertex >>> directed_graph.get_incoming_adjacent_vertices(2) [(1, 100)] >>> undirected_graph.get_incoming_adjacent_vertices(2) [(1, 100), (3, 400), (5, 500)] Get adjacent outgoing vertices relative to some vertex >>> directed_graph.get_outgoing_adjacent_vertices(2) [(3, 400), (5, 500)] >>> undirected_graph.get_outgoing_adjacent_vertices(2) [(1, 100), (3, 400), (5, 500)] Get value stored in a vertex >>> directed_graph.get_vertex_value(1) 1000 >>> undirected_graph.get_vertex_value(1) 1000 String representation of a graph >>> str(directed_graph) '[-, 100, 200, 300, -]\\n[-, -, 400, -, 500]\\n[-, -, -, -, 600]\\n[-, -, -, -, 700]\\n[-, -, -, -, -]' >>> str(undirected_graph).strip() '[-, 100, 200, 300, -]\\n[-, -, 400, -, 500]\\n[-, -, -, -, 600]\\n[-, -, -, -, 700]\\n[-, -, -, -, -]' Check if a vertex corresponding to some key is contained in the graph >>> 1 in directed_graph True >>> 100 in directed_graph False >>> 1 in undirected_graph True >>> 100 in undirected_graph False Depth-first traversal of a graph >>> [i for i in directed_graph.depth_first_traversal(1)] [(1, 1), (2, 2), (3, 3), (5, 4), (4, 8)] >>> [i for i in undirected_graph.depth_first_traversal(1)] [(1, 1), (2, 2), (3, 3), (5, 4), (4, 8)] Breadth-first traversal of a graph >>> [i for i in directed_graph.breadth_first_traversal(1)] [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] >>> [i for i in undirected_graph.breadth_first_traversal(1)] [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] Delete an edge >>> directed_graph.remove_edge(1, 2) >>> undirected_graph.remove_edge(1, 2) Delete a vertex >>> directed_graph.remove_vertex(1) >>> undirected_graph.remove_vertex(1)","title":"AdjacencyMatrixGraph"},{"location":"data_structures/graphs/adjacency_matrix_graph/#data_structures.graphs.adjacency_matrix_graph.AdjacencyMatrixGraph.add_edge","text":"Connect the vertices associated to the passed keys with a new edge Parameters: Name Type Description Default key1 Any the key associated to the first vertex in the pair required key2 Any the key associated to the second vertex in the pair required weight float the cost of traversing the newly formed edge None Source code in graphs/adjacency_matrix_graph.py def add_edge ( self , key1 : Any , key2 : Any , weight : float = None ) -> None : super () . add_edge ( key1 , key2 , weight ) idx1 = self . _keys . index ( key1 ) idx2 = self . _keys . index ( key2 ) self . __adjacency_matrix [ idx1 ][ idx2 ] = weight","title":"add_edge()"},{"location":"data_structures/graphs/adjacency_matrix_graph/#data_structures.graphs.adjacency_matrix_graph.AdjacencyMatrixGraph.add_vertex","text":"Add a new vertex to the graph Parameters: Name Type Description Default key Any the key to associate to the new vertex required value Any the value to be stored in the new vertex None Source code in graphs/adjacency_matrix_graph.py def add_vertex ( self , key : Any , value : Any = None ) -> None : super () . add_vertex ( key , value ) self . __adjacency_matrix . append ( [ AdjacencyMatrixGraph . _Empty () for _ in range ( len ( self . _keys ) - 1 )] ) for row in self . __adjacency_matrix : row . append ( AdjacencyMatrixGraph . _Empty ())","title":"add_vertex()"},{"location":"data_structures/graphs/adjacency_matrix_graph/#data_structures.graphs.adjacency_matrix_graph.AdjacencyMatrixGraph.breadth_first_traversal","text":"Return a generator that yields keys of vertices of the graph when traversed breadth first from some vertex Parameters: Name Type Description Default key Any the key where the traversal begins from required Returns: Type Description Generator a generator of vertex keys Source code in graphs/adjacency_matrix_graph.py def breadth_first_traversal ( self , key : Any ) -> Generator : yield from super () . breadth_first_traversal ( key )","title":"breadth_first_traversal()"},{"location":"data_structures/graphs/adjacency_matrix_graph/#data_structures.graphs.adjacency_matrix_graph.AdjacencyMatrixGraph.depth_first_traversal","text":"Return a generator that yields keys of vertices of the graph when traversed depth first from some vertex Parameters: Name Type Description Default key Any the key where the traversal begins from required Returns: Type Description Generator a generator of vertex keys Source code in graphs/adjacency_matrix_graph.py def depth_first_traversal ( self , key : Any ) -> Generator : yield from super () . depth_first_traversal ( key )","title":"depth_first_traversal()"},{"location":"data_structures/graphs/adjacency_matrix_graph/#data_structures.graphs.adjacency_matrix_graph.AdjacencyMatrixGraph.get_adjacent_vertices","text":"Return a list of keys of all the vertices connected to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex all adjacent vertices' keys are being sought required Returns: Type Description list a list of vertex keys Source code in graphs/adjacency_matrix_graph.py def get_adjacent_vertices ( self , key : Any ) -> list : super () . get_adjacent_vertices ( key ) idx = self . _keys . index ( key ) vertices = [] for i , row in enumerate ( self . __adjacency_matrix ): if i != idx : for j , weight in enumerate ( row ): if j == idx and not isinstance ( weight , AdjacencyMatrixGraph . _Empty ): vertices . append (( self . _keys [ i ], weight )) else : vertices . extend ( [ ( self . _keys [ j ], weight ) for j , weight in enumerate ( row ) if not isinstance ( weight , AdjacencyMatrixGraph . _Empty ) ] ) return vertices","title":"get_adjacent_vertices()"},{"location":"data_structures/graphs/adjacency_matrix_graph/#data_structures.graphs.adjacency_matrix_graph.AdjacencyMatrixGraph.get_edge_weight","text":"Return the weight associated with the edge connecting the vertices associated with the vertices of the passed keys Parameters: Name Type Description Default key1 Any the key of the first vertex in the edge pair required key2 Any the key of the second vertex in the edge pair required Returns: Type Description float weight of the edge Source code in graphs/adjacency_matrix_graph.py def get_edge_weight ( self , key1 : Any , key2 : Any ) -> float : return super () . get_edge_weight ( key1 , key2 )","title":"get_edge_weight()"},{"location":"data_structures/graphs/adjacency_matrix_graph/#data_structures.graphs.adjacency_matrix_graph.AdjacencyMatrixGraph.get_edges","text":"Return a list of all the edges in the graph Returns: Type Description list a list of all the edges Source code in graphs/adjacency_matrix_graph.py def get_edges ( self ) -> list : return super () . get_edges ()","title":"get_edges()"},{"location":"data_structures/graphs/adjacency_matrix_graph/#data_structures.graphs.adjacency_matrix_graph.AdjacencyMatrixGraph.get_incoming_adjacent_vertices","text":"Return a list of keys of all the vertices incoming to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex all incoming vertices' keys are being sought required Returns: Type Description list a list of vertex keys Source code in graphs/adjacency_matrix_graph.py def get_incoming_adjacent_vertices ( self , key : Any ) -> list : super () . get_incoming_adjacent_vertices ( key ) idx = self . _keys . index ( key ) vertices = [] for i , row in enumerate ( self . __adjacency_matrix ): if i != idx : for j , weight in enumerate ( row ): if j == idx and not isinstance ( weight , AdjacencyMatrixGraph . _Empty ): vertices . append (( self . _keys [ i ], weight )) else : if not self . is_directed (): vertices . extend ( [ ( self . _keys [ j ], weight ) for j , weight in enumerate ( row ) if not isinstance ( weight , AdjacencyMatrixGraph . _Empty ) ] ) return vertices","title":"get_incoming_adjacent_vertices()"},{"location":"data_structures/graphs/adjacency_matrix_graph/#data_structures.graphs.adjacency_matrix_graph.AdjacencyMatrixGraph.get_incoming_edges","text":"Return a list of incoming edges corresponding to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex a list of incoming edges is being sought required Returns: Type Description list a list of edges Source code in graphs/adjacency_matrix_graph.py def get_incoming_edges ( self , key : Any ) -> list : return super () . get_incoming_edges ( key )","title":"get_incoming_edges()"},{"location":"data_structures/graphs/adjacency_matrix_graph/#data_structures.graphs.adjacency_matrix_graph.AdjacencyMatrixGraph.get_outgoing_adjacent_vertices","text":"Return a list of keys of all the vertices outgoing from the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex all outgoing vertices' keys are being sought required Returns: Type Description list a list of vertex keys Source code in graphs/adjacency_matrix_graph.py def get_outgoing_adjacent_vertices ( self , key : Any ) -> list : super () . get_outgoing_adjacent_vertices ( key ) idx = self . _keys . index ( key ) vertices = [] for i , row in enumerate ( self . __adjacency_matrix ): if i != idx : if not self . is_directed (): for j , weight in enumerate ( row ): if j == idx and not isinstance ( weight , AdjacencyMatrixGraph . _Empty ): vertices . append (( self . _keys [ i ], weight )) else : vertices . extend ( [ ( self . _keys [ j ], weight ) for j , weight in enumerate ( row ) if not isinstance ( weight , AdjacencyMatrixGraph . _Empty ) ] ) return vertices","title":"get_outgoing_adjacent_vertices()"},{"location":"data_structures/graphs/adjacency_matrix_graph/#data_structures.graphs.adjacency_matrix_graph.AdjacencyMatrixGraph.get_outgoing_edges","text":"Return a list of outgoing edges corresponding to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex a list of outgoing edges is being sought required Returns: Type Description list a list of edges Source code in graphs/adjacency_matrix_graph.py def get_outgoing_edges ( self , key : Any ) -> list : return super () . get_outgoing_edges ( key )","title":"get_outgoing_edges()"},{"location":"data_structures/graphs/adjacency_matrix_graph/#data_structures.graphs.adjacency_matrix_graph.AdjacencyMatrixGraph.is_edge","text":"Check if a pair of vertices form an edge Parameters: Name Type Description Default key1 Any the key of the first vertex in the edge pair required key2 Any the key of the second vertex in the edge pair required Returns: Type Description bool True if the passed pair form an edge, else False Source code in graphs/adjacency_matrix_graph.py def is_edge ( self , key1 : Any , key2 : Any ) -> bool : return super () . is_edge ( key1 , key2 )","title":"is_edge()"},{"location":"data_structures/graphs/adjacency_matrix_graph/#data_structures.graphs.adjacency_matrix_graph.AdjacencyMatrixGraph.remove_edge","text":"Delete the edge connecting the vertices associated with the passed keys Parameters: Name Type Description Default key1 Any the key associated with the first vertex of the edge pair required key2 Any the key associated with the second vertex of the edge pair required Source code in graphs/adjacency_matrix_graph.py def remove_edge ( self , key1 : Any , key2 : Any ) -> None : super () . remove_edge ( key1 , key2 ) for i in self . get_adjacent_vertices ( key1 ): if key2 == i [ 0 ]: idx1 = self . _keys . index ( key1 ) idx2 = self . _keys . index ( key2 ) self . __adjacency_matrix [ idx1 ][ idx2 ] = AdjacencyMatrixGraph . _Empty () return if not self . is_directed (): for i in self . get_adjacent_vertices ( key2 ): if key1 == i [ 0 ]: idx1 = self . _keys . index ( key1 ) idx2 = self . _keys . index ( key2 ) self . __adjacency_matrix [ idx2 ][ idx1 ] = AdjacencyMatrixGraph . _Empty () return raise ValueError ( f \"Edge ( { key1 } , { key2 } ) is absent from the graph\" )","title":"remove_edge()"},{"location":"data_structures/graphs/adjacency_matrix_graph/#data_structures.graphs.adjacency_matrix_graph.AdjacencyMatrixGraph.remove_vertex","text":"Delete the vertex associated to the passed key Parameters: Name Type Description Default key Any the key whose vertex id to be deleted required Source code in graphs/adjacency_matrix_graph.py def remove_vertex ( self , key : Any ) -> None : idx = None if key in self : idx = self . _keys . index ( key ) super () . remove_vertex ( key ) del self . __adjacency_matrix [ idx ] for i in range ( len ( self . __adjacency_matrix )): del self . __adjacency_matrix [ i ][ idx ]","title":"remove_vertex()"},{"location":"data_structures/graphs/graph/","text":"Graph ( ABC ) A graph is a set of vertices and the edges that connect these vertices together in pairs. The graph abstract data type can be implemented based on various structures, but the most common are: adjacency matrix adjacency list Graph vocabularies include, but are not limited to: Directed graph: a graph whose edges have an order, such that one of the vertices in each edge precedes the other. It's also called a digraph. Undirected graph: a graph whose edges have no order, such that each vertex has no precedence over any other vertex. Multi-graph: a graph that contains at least one pair of vertices joined by multiple edges. Complete graph: a graph whose vertices are each connected to every other vertex within the graph. Degree of a vertex: the number of edges connected to the vertex. Weight of an edge: the cost of traversing the edge. Path: a complete route from some vertex to some other vertex within the graph. Circuit: a path that begins and ends at the same vertex without traversing any edge more than once. __contains__ ( self , key ) special Check if a graph contains a vertex with the passed key Parameters: Name Type Description Default key Any the key to check required Returns: Type Description bool True if the key is contained in some vertex of the graph, else False Source code in graphs/graph.py def __contains__ ( self , key : Any ) -> bool : \"\"\"Check if a graph contains a vertex with the passed key :param key: the key to check :returns: True if the key is contained in some vertex of the graph, else False \"\"\" return key in self . _keys __repr__ ( self ) special Return a string representation of the graph Returns: Type Description str the string representation of the graph Source code in graphs/graph.py @abstractmethod def __repr__ ( self ) -> str : \"\"\"Return a string representation of the graph :returns: the string representation of the graph \"\"\" pass add_edge ( self , key1 , key2 , weight = None ) Connect the vertices associated to the passed keys with a new edge Parameters: Name Type Description Default key1 Any the key associated to the first vertex in the pair required key2 Any the key associated to the second vertex in the pair required weight float the cost of traversing the newly formed edge None Source code in graphs/graph.py @abstractmethod def add_edge ( self , key1 : Any , key2 : Any , weight : float = None ) -> None : \"\"\"Connect the vertices associated to the passed keys with a new edge :param key1: the key associated to the first vertex in the pair :param key2: the key associated to the second vertex in the pair :param weight: the cost of traversing the newly formed edge \"\"\" if key1 not in self : raise KeyError ( f \" { key1 } is absent from the graph\" ) if key2 not in self : raise KeyError ( f \" { key2 } is absent from the graph\" ) add_vertex ( self , key , value = None ) Add a new vertex to the graph Parameters: Name Type Description Default key Any the key to associate to the new vertex required value Any the value to be stored in the new vertex None Source code in graphs/graph.py @abstractmethod def add_vertex ( self , key : Any , value : Any = None ) -> None : \"\"\"Add a new vertex to the graph :param key: the key to associate to the new vertex :param value: the value to be stored in the new vertex \"\"\" if key in self : raise KeyError ( f \" { key } already exists in the graph\" ) self . _keys . append ( key ) self . _vertices . append ( Graph . _Vertex ( key , value )) breadth_first_traversal ( self , key ) Return a generator that yields keys of vertices of the graph when traversed breadth first from some vertex Parameters: Name Type Description Default key Any the key where the traversal begins from required Returns: Type Description Generator a generator of vertex keys Source code in graphs/graph.py @abstractmethod def breadth_first_traversal ( self , key : Any ) -> Generator : \"\"\"Return a generator that yields keys of vertices of the graph when traversed breadth first from some vertex :param key: the key where the traversal begins from :returns: a generator of vertex keys \"\"\" visited = { \"__steps\" : 1 , key : { \"visit\" : 1 }} helper_queue = [ key ] while len ( helper_queue ) > 0 : current_key = helper_queue . pop ( 0 ) yield current_key , visited [ current_key ][ \"visit\" ] for k , _ in self . _get_next_vertices ( current_key ): if k not in visited . keys (): visited [ \"__steps\" ] += 1 visited [ k ] = { \"visit\" : visited [ \"__steps\" ]} helper_queue . append ( k ) depth_first_traversal ( self , key ) Return a generator that yields keys of vertices of the graph when traversed depth first from some vertex Parameters: Name Type Description Default key Any the key where the traversal begins from required Returns: Type Description Generator a generator of vertex keys Source code in graphs/graph.py @abstractmethod def depth_first_traversal ( self , key : Any ) -> Generator : \"\"\"Return a generator that yields keys of vertices of the graph when traversed depth first from some vertex :param key: the key where the traversal begins from :returns: a generator of vertex keys \"\"\" visited = { \"__steps\" : 0 } def helper ( vertex_key ): visited [ \"__steps\" ] += 1 visited [ vertex_key ] = { \"first_visit\" : visited [ \"__steps\" ]} yield vertex_key , visited [ \"__steps\" ] for k , _ in self . _get_next_vertices ( vertex_key ): if k not in visited . keys (): yield from helper ( k ) visited [ \"__steps\" ] += 1 visited [ vertex_key ] = { \"last_visit\" : visited [ \"__steps\" ]} yield from helper ( key ) get_adjacent_vertices ( self , key ) Return a list of keys of all the vertices connected to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex all adjacent vertices' keys are being sought required Returns: Type Description list a list of vertex keys Source code in graphs/graph.py @abstractmethod def get_adjacent_vertices ( self , key : Any ) -> list : \"\"\"Return a list of keys of all the vertices connected to the vertex associated with the passed key :param key: the key whose vertex all adjacent vertices' keys are being sought :returns: a list of vertex keys \"\"\" if key not in self : raise KeyError ( f \" { key } is absent from the graph\" ) get_edge_weight ( self , key1 , key2 ) Return the weight associated with the edge connecting the vertices associated with the vertices of the passed keys Parameters: Name Type Description Default key1 Any the key of the first vertex in the edge pair required key2 Any the key of the second vertex in the edge pair required Returns: Type Description float weight of the edge Source code in graphs/graph.py @abstractmethod def get_edge_weight ( self , key1 : Any , key2 : Any ) -> float : \"\"\"Return the weight associated with the edge connecting the vertices associated with the vertices of the passed keys :param key1: the key of the first vertex in the edge pair :param key2: the key of the second vertex in the edge pair :returns: weight of the edge \"\"\" if key1 not in self : raise KeyError ( f \" { key1 } is absent from the graph\" ) if key2 not in self : raise KeyError ( f \" { key2 } is absent from the graph\" ) for i in self . get_adjacent_vertices ( key1 ): if key2 == i [ 0 ]: return i [ 1 ] if not self . is_directed (): for i in self . get_adjacent_vertices ( key2 ): if key1 == i [ 0 ]: return i [ 1 ] raise ValueError ( f \"Edge ( { key1 } , { key2 } ) is absent from the graph\" ) get_edges ( self ) Return a list of all the edges in the graph Returns: Type Description list a list of all the edges Source code in graphs/graph.py @abstractmethod def get_edges ( self ) -> list : \"\"\"Return a list of all the edges in the graph :returns: a list of all the edges \"\"\" edges = [] for i in self . get_vertices (): for j in self . get_outgoing_adjacent_vertices ( i ): edges . append (( i , j [ 0 ], j [ 1 ])) return edges get_incoming_adjacent_vertices ( self , key ) Return a list of keys of all the vertices incoming to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex all incoming vertices' keys are being sought required Returns: Type Description list a list of vertex keys Source code in graphs/graph.py @abstractmethod def get_incoming_adjacent_vertices ( self , key : Any ) -> list : \"\"\"Return a list of keys of all the vertices incoming to the vertex associated with the passed key :param key: the key whose vertex all incoming vertices' keys are being sought :returns: a list of vertex keys \"\"\" if key not in self : raise KeyError ( f \" { key } is absent from the graph\" ) get_incoming_edges ( self , key ) Return a list of incoming edges corresponding to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex a list of incoming edges is being sought required Returns: Type Description list a list of edges Source code in graphs/graph.py @abstractmethod def get_incoming_edges ( self , key : Any ) -> list : \"\"\"Return a list of incoming edges corresponding to the vertex associated with the passed key :param key: the key whose vertex a list of incoming edges is being sought :returns: a list of edges \"\"\" if key not in self : raise KeyError ( f \" { key } is absent from the graph\" ) return [( i [ 0 ], key , i [ 1 ]) for i in self . get_incoming_adjacent_vertices ( key )] get_outgoing_adjacent_vertices ( self , key ) Return a list of keys of all the vertices outgoing from the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex all outgoing vertices' keys are being sought required Returns: Type Description list a list of vertex keys Source code in graphs/graph.py @abstractmethod def get_outgoing_adjacent_vertices ( self , key : Any ) -> list : \"\"\"Return a list of keys of all the vertices outgoing from the vertex associated with the passed key :param key: the key whose vertex all outgoing vertices' keys are being sought :returns: a list of vertex keys \"\"\" if key not in self : raise KeyError ( f \" { key } is absent from the graph\" ) get_outgoing_edges ( self , key ) Return a list of outgoing edges corresponding to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex a list of outgoing edges is being sought required Returns: Type Description list a list of edges Source code in graphs/graph.py @abstractmethod def get_outgoing_edges ( self , key : Any ) -> list : \"\"\"Return a list of outgoing edges corresponding to the vertex associated with the passed key :param key: the key whose vertex a list of outgoing edges is being sought :returns: a list of edges \"\"\" if key not in self : raise KeyError ( f \" { key } is absent from the graph\" ) return [( key , * i ) for i in self . get_outgoing_adjacent_vertices ( key )] get_vertex_value ( self , key ) Return the value stored in the vertex corresponding to the passed key Parameters: Name Type Description Default key Any the key whose corresponding vertex's value is being sought required Returns: Type Description Any the value associated to vertex of the passed key Source code in graphs/graph.py def get_vertex_value ( self , key : Any ) -> Any : \"\"\"Return the value stored in the vertex corresponding to the passed key :param key: the key whose corresponding vertex's value is being sought :returns: the value associated to vertex of the passed key \"\"\" if key not in self : raise KeyError ( f \" { key } is absent from the graph\" ) idx = self . _keys . index ( key ) return self . _vertices [ idx ] . value get_vertices ( self ) Return a list of the keys of all vertices contained within the graph Returns: Type Description list a list of all the vertices' keys Source code in graphs/graph.py def get_vertices ( self ) -> list : \"\"\"Return a list of the keys of all vertices contained within the graph :returns: a list of all the vertices' keys \"\"\" return self . _keys is_directed ( self ) Check if the graph is directed Returns: Type Description bool True if the graph is directed, else False Source code in graphs/graph.py def is_directed ( self ) -> bool : \"\"\"Check if the graph is directed :returns: True if the graph is directed, else False \"\"\" return self . _directed is_edge ( self , key1 , key2 ) Check if a pair of vertices form an edge Parameters: Name Type Description Default key1 Any the key of the first vertex in the edge pair required key2 Any the key of the second vertex in the edge pair required Returns: Type Description bool True if the passed pair form an edge, else False Source code in graphs/graph.py @abstractmethod def is_edge ( self , key1 : Any , key2 : Any ) -> bool : \"\"\"Check if a pair of vertices form an edge :param key1: the key of the first vertex in the edge pair :param key2: the key of the second vertex in the edge pair :returns: True if the passed pair form an edge, else False \"\"\" if key1 not in self : raise KeyError ( f \" { key1 } is absent from the graph\" ) if key2 not in self : raise KeyError ( f \" { key2 } is absent from the graph\" ) for i in self . get_outgoing_adjacent_vertices ( key1 ): if key2 == i [ 0 ]: return True return False remove_edge ( self , key1 , key2 ) Delete the edge connecting the vertices associated with the passed keys Parameters: Name Type Description Default key1 Any the key associated with the first vertex of the edge pair required key2 Any the key associated with the second vertex of the edge pair required Source code in graphs/graph.py @abstractmethod def remove_edge ( self , key1 : Any , key2 : Any ) -> None : \"\"\"Delete the edge connecting the vertices associated with the passed keys :param key1: the key associated with the first vertex of the edge pair :param key2: the key associated with the second vertex of the edge pair \"\"\" if key1 not in self : raise KeyError ( f \" { key1 } is absent from the graph\" ) if key2 not in self : raise KeyError ( f \" { key2 } is absent from the graph\" ) remove_vertex ( self , key ) Delete the vertex associated to the passed key Parameters: Name Type Description Default key Any the key whose vertex id to be deleted required Source code in graphs/graph.py @abstractmethod def remove_vertex ( self , key : Any ) -> None : \"\"\"Delete the vertex associated to the passed key :param key: the key whose vertex id to be deleted \"\"\" if key not in self : raise KeyError ( f \" { key } is absent from the graph\" ) idx = self . _keys . index ( key ) del self . _keys [ idx ] del self . _vertices [ idx ]","title":"Graph ADT"},{"location":"data_structures/graphs/graph/#data_structures.graphs.graph.Graph","text":"A graph is a set of vertices and the edges that connect these vertices together in pairs. The graph abstract data type can be implemented based on various structures, but the most common are: adjacency matrix adjacency list Graph vocabularies include, but are not limited to: Directed graph: a graph whose edges have an order, such that one of the vertices in each edge precedes the other. It's also called a digraph. Undirected graph: a graph whose edges have no order, such that each vertex has no precedence over any other vertex. Multi-graph: a graph that contains at least one pair of vertices joined by multiple edges. Complete graph: a graph whose vertices are each connected to every other vertex within the graph. Degree of a vertex: the number of edges connected to the vertex. Weight of an edge: the cost of traversing the edge. Path: a complete route from some vertex to some other vertex within the graph. Circuit: a path that begins and ends at the same vertex without traversing any edge more than once.","title":"Graph"},{"location":"data_structures/graphs/graph/#data_structures.graphs.graph.Graph.__contains__","text":"Check if a graph contains a vertex with the passed key Parameters: Name Type Description Default key Any the key to check required Returns: Type Description bool True if the key is contained in some vertex of the graph, else False Source code in graphs/graph.py def __contains__ ( self , key : Any ) -> bool : \"\"\"Check if a graph contains a vertex with the passed key :param key: the key to check :returns: True if the key is contained in some vertex of the graph, else False \"\"\" return key in self . _keys","title":"__contains__()"},{"location":"data_structures/graphs/graph/#data_structures.graphs.graph.Graph.__repr__","text":"Return a string representation of the graph Returns: Type Description str the string representation of the graph Source code in graphs/graph.py @abstractmethod def __repr__ ( self ) -> str : \"\"\"Return a string representation of the graph :returns: the string representation of the graph \"\"\" pass","title":"__repr__()"},{"location":"data_structures/graphs/graph/#data_structures.graphs.graph.Graph.add_edge","text":"Connect the vertices associated to the passed keys with a new edge Parameters: Name Type Description Default key1 Any the key associated to the first vertex in the pair required key2 Any the key associated to the second vertex in the pair required weight float the cost of traversing the newly formed edge None Source code in graphs/graph.py @abstractmethod def add_edge ( self , key1 : Any , key2 : Any , weight : float = None ) -> None : \"\"\"Connect the vertices associated to the passed keys with a new edge :param key1: the key associated to the first vertex in the pair :param key2: the key associated to the second vertex in the pair :param weight: the cost of traversing the newly formed edge \"\"\" if key1 not in self : raise KeyError ( f \" { key1 } is absent from the graph\" ) if key2 not in self : raise KeyError ( f \" { key2 } is absent from the graph\" )","title":"add_edge()"},{"location":"data_structures/graphs/graph/#data_structures.graphs.graph.Graph.add_vertex","text":"Add a new vertex to the graph Parameters: Name Type Description Default key Any the key to associate to the new vertex required value Any the value to be stored in the new vertex None Source code in graphs/graph.py @abstractmethod def add_vertex ( self , key : Any , value : Any = None ) -> None : \"\"\"Add a new vertex to the graph :param key: the key to associate to the new vertex :param value: the value to be stored in the new vertex \"\"\" if key in self : raise KeyError ( f \" { key } already exists in the graph\" ) self . _keys . append ( key ) self . _vertices . append ( Graph . _Vertex ( key , value ))","title":"add_vertex()"},{"location":"data_structures/graphs/graph/#data_structures.graphs.graph.Graph.breadth_first_traversal","text":"Return a generator that yields keys of vertices of the graph when traversed breadth first from some vertex Parameters: Name Type Description Default key Any the key where the traversal begins from required Returns: Type Description Generator a generator of vertex keys Source code in graphs/graph.py @abstractmethod def breadth_first_traversal ( self , key : Any ) -> Generator : \"\"\"Return a generator that yields keys of vertices of the graph when traversed breadth first from some vertex :param key: the key where the traversal begins from :returns: a generator of vertex keys \"\"\" visited = { \"__steps\" : 1 , key : { \"visit\" : 1 }} helper_queue = [ key ] while len ( helper_queue ) > 0 : current_key = helper_queue . pop ( 0 ) yield current_key , visited [ current_key ][ \"visit\" ] for k , _ in self . _get_next_vertices ( current_key ): if k not in visited . keys (): visited [ \"__steps\" ] += 1 visited [ k ] = { \"visit\" : visited [ \"__steps\" ]} helper_queue . append ( k )","title":"breadth_first_traversal()"},{"location":"data_structures/graphs/graph/#data_structures.graphs.graph.Graph.depth_first_traversal","text":"Return a generator that yields keys of vertices of the graph when traversed depth first from some vertex Parameters: Name Type Description Default key Any the key where the traversal begins from required Returns: Type Description Generator a generator of vertex keys Source code in graphs/graph.py @abstractmethod def depth_first_traversal ( self , key : Any ) -> Generator : \"\"\"Return a generator that yields keys of vertices of the graph when traversed depth first from some vertex :param key: the key where the traversal begins from :returns: a generator of vertex keys \"\"\" visited = { \"__steps\" : 0 } def helper ( vertex_key ): visited [ \"__steps\" ] += 1 visited [ vertex_key ] = { \"first_visit\" : visited [ \"__steps\" ]} yield vertex_key , visited [ \"__steps\" ] for k , _ in self . _get_next_vertices ( vertex_key ): if k not in visited . keys (): yield from helper ( k ) visited [ \"__steps\" ] += 1 visited [ vertex_key ] = { \"last_visit\" : visited [ \"__steps\" ]} yield from helper ( key )","title":"depth_first_traversal()"},{"location":"data_structures/graphs/graph/#data_structures.graphs.graph.Graph.get_adjacent_vertices","text":"Return a list of keys of all the vertices connected to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex all adjacent vertices' keys are being sought required Returns: Type Description list a list of vertex keys Source code in graphs/graph.py @abstractmethod def get_adjacent_vertices ( self , key : Any ) -> list : \"\"\"Return a list of keys of all the vertices connected to the vertex associated with the passed key :param key: the key whose vertex all adjacent vertices' keys are being sought :returns: a list of vertex keys \"\"\" if key not in self : raise KeyError ( f \" { key } is absent from the graph\" )","title":"get_adjacent_vertices()"},{"location":"data_structures/graphs/graph/#data_structures.graphs.graph.Graph.get_edge_weight","text":"Return the weight associated with the edge connecting the vertices associated with the vertices of the passed keys Parameters: Name Type Description Default key1 Any the key of the first vertex in the edge pair required key2 Any the key of the second vertex in the edge pair required Returns: Type Description float weight of the edge Source code in graphs/graph.py @abstractmethod def get_edge_weight ( self , key1 : Any , key2 : Any ) -> float : \"\"\"Return the weight associated with the edge connecting the vertices associated with the vertices of the passed keys :param key1: the key of the first vertex in the edge pair :param key2: the key of the second vertex in the edge pair :returns: weight of the edge \"\"\" if key1 not in self : raise KeyError ( f \" { key1 } is absent from the graph\" ) if key2 not in self : raise KeyError ( f \" { key2 } is absent from the graph\" ) for i in self . get_adjacent_vertices ( key1 ): if key2 == i [ 0 ]: return i [ 1 ] if not self . is_directed (): for i in self . get_adjacent_vertices ( key2 ): if key1 == i [ 0 ]: return i [ 1 ] raise ValueError ( f \"Edge ( { key1 } , { key2 } ) is absent from the graph\" )","title":"get_edge_weight()"},{"location":"data_structures/graphs/graph/#data_structures.graphs.graph.Graph.get_edges","text":"Return a list of all the edges in the graph Returns: Type Description list a list of all the edges Source code in graphs/graph.py @abstractmethod def get_edges ( self ) -> list : \"\"\"Return a list of all the edges in the graph :returns: a list of all the edges \"\"\" edges = [] for i in self . get_vertices (): for j in self . get_outgoing_adjacent_vertices ( i ): edges . append (( i , j [ 0 ], j [ 1 ])) return edges","title":"get_edges()"},{"location":"data_structures/graphs/graph/#data_structures.graphs.graph.Graph.get_incoming_adjacent_vertices","text":"Return a list of keys of all the vertices incoming to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex all incoming vertices' keys are being sought required Returns: Type Description list a list of vertex keys Source code in graphs/graph.py @abstractmethod def get_incoming_adjacent_vertices ( self , key : Any ) -> list : \"\"\"Return a list of keys of all the vertices incoming to the vertex associated with the passed key :param key: the key whose vertex all incoming vertices' keys are being sought :returns: a list of vertex keys \"\"\" if key not in self : raise KeyError ( f \" { key } is absent from the graph\" )","title":"get_incoming_adjacent_vertices()"},{"location":"data_structures/graphs/graph/#data_structures.graphs.graph.Graph.get_incoming_edges","text":"Return a list of incoming edges corresponding to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex a list of incoming edges is being sought required Returns: Type Description list a list of edges Source code in graphs/graph.py @abstractmethod def get_incoming_edges ( self , key : Any ) -> list : \"\"\"Return a list of incoming edges corresponding to the vertex associated with the passed key :param key: the key whose vertex a list of incoming edges is being sought :returns: a list of edges \"\"\" if key not in self : raise KeyError ( f \" { key } is absent from the graph\" ) return [( i [ 0 ], key , i [ 1 ]) for i in self . get_incoming_adjacent_vertices ( key )]","title":"get_incoming_edges()"},{"location":"data_structures/graphs/graph/#data_structures.graphs.graph.Graph.get_outgoing_adjacent_vertices","text":"Return a list of keys of all the vertices outgoing from the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex all outgoing vertices' keys are being sought required Returns: Type Description list a list of vertex keys Source code in graphs/graph.py @abstractmethod def get_outgoing_adjacent_vertices ( self , key : Any ) -> list : \"\"\"Return a list of keys of all the vertices outgoing from the vertex associated with the passed key :param key: the key whose vertex all outgoing vertices' keys are being sought :returns: a list of vertex keys \"\"\" if key not in self : raise KeyError ( f \" { key } is absent from the graph\" )","title":"get_outgoing_adjacent_vertices()"},{"location":"data_structures/graphs/graph/#data_structures.graphs.graph.Graph.get_outgoing_edges","text":"Return a list of outgoing edges corresponding to the vertex associated with the passed key Parameters: Name Type Description Default key Any the key whose vertex a list of outgoing edges is being sought required Returns: Type Description list a list of edges Source code in graphs/graph.py @abstractmethod def get_outgoing_edges ( self , key : Any ) -> list : \"\"\"Return a list of outgoing edges corresponding to the vertex associated with the passed key :param key: the key whose vertex a list of outgoing edges is being sought :returns: a list of edges \"\"\" if key not in self : raise KeyError ( f \" { key } is absent from the graph\" ) return [( key , * i ) for i in self . get_outgoing_adjacent_vertices ( key )]","title":"get_outgoing_edges()"},{"location":"data_structures/graphs/graph/#data_structures.graphs.graph.Graph.get_vertex_value","text":"Return the value stored in the vertex corresponding to the passed key Parameters: Name Type Description Default key Any the key whose corresponding vertex's value is being sought required Returns: Type Description Any the value associated to vertex of the passed key Source code in graphs/graph.py def get_vertex_value ( self , key : Any ) -> Any : \"\"\"Return the value stored in the vertex corresponding to the passed key :param key: the key whose corresponding vertex's value is being sought :returns: the value associated to vertex of the passed key \"\"\" if key not in self : raise KeyError ( f \" { key } is absent from the graph\" ) idx = self . _keys . index ( key ) return self . _vertices [ idx ] . value","title":"get_vertex_value()"},{"location":"data_structures/graphs/graph/#data_structures.graphs.graph.Graph.get_vertices","text":"Return a list of the keys of all vertices contained within the graph Returns: Type Description list a list of all the vertices' keys Source code in graphs/graph.py def get_vertices ( self ) -> list : \"\"\"Return a list of the keys of all vertices contained within the graph :returns: a list of all the vertices' keys \"\"\" return self . _keys","title":"get_vertices()"},{"location":"data_structures/graphs/graph/#data_structures.graphs.graph.Graph.is_directed","text":"Check if the graph is directed Returns: Type Description bool True if the graph is directed, else False Source code in graphs/graph.py def is_directed ( self ) -> bool : \"\"\"Check if the graph is directed :returns: True if the graph is directed, else False \"\"\" return self . _directed","title":"is_directed()"},{"location":"data_structures/graphs/graph/#data_structures.graphs.graph.Graph.is_edge","text":"Check if a pair of vertices form an edge Parameters: Name Type Description Default key1 Any the key of the first vertex in the edge pair required key2 Any the key of the second vertex in the edge pair required Returns: Type Description bool True if the passed pair form an edge, else False Source code in graphs/graph.py @abstractmethod def is_edge ( self , key1 : Any , key2 : Any ) -> bool : \"\"\"Check if a pair of vertices form an edge :param key1: the key of the first vertex in the edge pair :param key2: the key of the second vertex in the edge pair :returns: True if the passed pair form an edge, else False \"\"\" if key1 not in self : raise KeyError ( f \" { key1 } is absent from the graph\" ) if key2 not in self : raise KeyError ( f \" { key2 } is absent from the graph\" ) for i in self . get_outgoing_adjacent_vertices ( key1 ): if key2 == i [ 0 ]: return True return False","title":"is_edge()"},{"location":"data_structures/graphs/graph/#data_structures.graphs.graph.Graph.remove_edge","text":"Delete the edge connecting the vertices associated with the passed keys Parameters: Name Type Description Default key1 Any the key associated with the first vertex of the edge pair required key2 Any the key associated with the second vertex of the edge pair required Source code in graphs/graph.py @abstractmethod def remove_edge ( self , key1 : Any , key2 : Any ) -> None : \"\"\"Delete the edge connecting the vertices associated with the passed keys :param key1: the key associated with the first vertex of the edge pair :param key2: the key associated with the second vertex of the edge pair \"\"\" if key1 not in self : raise KeyError ( f \" { key1 } is absent from the graph\" ) if key2 not in self : raise KeyError ( f \" { key2 } is absent from the graph\" )","title":"remove_edge()"},{"location":"data_structures/graphs/graph/#data_structures.graphs.graph.Graph.remove_vertex","text":"Delete the vertex associated to the passed key Parameters: Name Type Description Default key Any the key whose vertex id to be deleted required Source code in graphs/graph.py @abstractmethod def remove_vertex ( self , key : Any ) -> None : \"\"\"Delete the vertex associated to the passed key :param key: the key whose vertex id to be deleted \"\"\" if key not in self : raise KeyError ( f \" { key } is absent from the graph\" ) idx = self . _keys . index ( key ) del self . _keys [ idx ] del self . _vertices [ idx ]","title":"remove_vertex()"},{"location":"data_structures/linked_lists/circularly_doubly_linked_list/","text":"CircularlyDoublyLinkedList ( DoublyLinkedList ) A circularly doubly linked list is a cyclic collection of nodes whose head and tail nodes are connected. Each node contains a reference to the node preceding it, and a reference to the node succeeding it. Instantiate a circularly doubly linked list object >>> a_list = CircularlyDoublyLinkedList() Append an item to the list >>> a_list.append(0) The L.append(x) method is an alias of L.insert_last(x) >>> a_list.insert_last(1) Insert an item at the head of the list >>> a_list.insert_first(2) Insert an item at a specific index >>> a_list.insert(1, 3) Insert an item at an index that's out of range raises IndexError >>> a_list.insert(100, 3) Traceback (most recent call last): ... IndexError: Index out of range Get first item of the list >>> a_list.get_first() 2 Get first item of an empty list raises Empty >>> CircularlyDoublyLinkedList().get_first() Traceback (most recent call last): ... linked_list.Empty: List is empty Get last item of the list >>> a_list.get_last() 1 Get last item of an empty list raises Empty >>> CircularlyDoublyLinkedList().get_last() Traceback (most recent call last): ... linked_list.Empty: List is empty Get item at a specific index >>> a_list[1] 3 Get item at an index that's out of range raises IndexError >>> a_list[100] Traceback (most recent call last): ... IndexError: Index out of range Get items at slice range of the list >>> a_list[1:3] [3, 0] Get items at a slice that's out of range raises IndexError >>> a_list[1:100] Traceback (most recent call last): ... IndexError: Index out of range Get items at a slice with a slice step of less than one raises a ValueError >>> a_list[1:3:0] Traceback (most recent call last): ... ValueError: Step needs to be greater than zero Get an iterable object of the list >>> iterable_object = iter(a_list) Get next item of the iterable object >>> next(iterable_object) 2 Get next item of the list iterator >>> next(a_list) 3 Get length of the the list >>> len(a_list) 4 Get a string representation of the list >>> str(a_list) '[2, 3, 0, 1]' >>> a_list [2, 3, 0, 1] Delete first item of the list >>> a_list.remove_first() Delete first item of an empty list raises Empty >>> CircularlyDoublyLinkedList().remove_first() Traceback (most recent call last): ... linked_list.Empty: List is empty Delete last item of the list >>> a_list.remove_last() Delete last item of an empty list raises Empty >>> CircularlyDoublyLinkedList().remove_last() Traceback (most recent call last): ... linked_list.Empty: List is empty Delete item at a specific index >>> del a_list[0] Delete item of at an index that's out of range raises IndexError >>> del a_list[100] Traceback (most recent call last): ... IndexError: Index out of range Replace item at a specific index >>> a_list[0] = 100 Replace item of at an index that's out of range raises IndexError >>> a_list[100] = 100 Traceback (most recent call last): ... IndexError: Index out of range Delete all items from the list >>> a_list.remove_all() >>> a_list []","title":"Circularly Doubly Linked List"},{"location":"data_structures/linked_lists/circularly_doubly_linked_list/#data_structures.linked_lists.circularly_doubly_linked_list.CircularlyDoublyLinkedList","text":"A circularly doubly linked list is a cyclic collection of nodes whose head and tail nodes are connected. Each node contains a reference to the node preceding it, and a reference to the node succeeding it. Instantiate a circularly doubly linked list object >>> a_list = CircularlyDoublyLinkedList() Append an item to the list >>> a_list.append(0) The L.append(x) method is an alias of L.insert_last(x) >>> a_list.insert_last(1) Insert an item at the head of the list >>> a_list.insert_first(2) Insert an item at a specific index >>> a_list.insert(1, 3) Insert an item at an index that's out of range raises IndexError >>> a_list.insert(100, 3) Traceback (most recent call last): ... IndexError: Index out of range Get first item of the list >>> a_list.get_first() 2 Get first item of an empty list raises Empty >>> CircularlyDoublyLinkedList().get_first() Traceback (most recent call last): ... linked_list.Empty: List is empty Get last item of the list >>> a_list.get_last() 1 Get last item of an empty list raises Empty >>> CircularlyDoublyLinkedList().get_last() Traceback (most recent call last): ... linked_list.Empty: List is empty Get item at a specific index >>> a_list[1] 3 Get item at an index that's out of range raises IndexError >>> a_list[100] Traceback (most recent call last): ... IndexError: Index out of range Get items at slice range of the list >>> a_list[1:3] [3, 0] Get items at a slice that's out of range raises IndexError >>> a_list[1:100] Traceback (most recent call last): ... IndexError: Index out of range Get items at a slice with a slice step of less than one raises a ValueError >>> a_list[1:3:0] Traceback (most recent call last): ... ValueError: Step needs to be greater than zero Get an iterable object of the list >>> iterable_object = iter(a_list) Get next item of the iterable object >>> next(iterable_object) 2 Get next item of the list iterator >>> next(a_list) 3 Get length of the the list >>> len(a_list) 4 Get a string representation of the list >>> str(a_list) '[2, 3, 0, 1]' >>> a_list [2, 3, 0, 1] Delete first item of the list >>> a_list.remove_first() Delete first item of an empty list raises Empty >>> CircularlyDoublyLinkedList().remove_first() Traceback (most recent call last): ... linked_list.Empty: List is empty Delete last item of the list >>> a_list.remove_last() Delete last item of an empty list raises Empty >>> CircularlyDoublyLinkedList().remove_last() Traceback (most recent call last): ... linked_list.Empty: List is empty Delete item at a specific index >>> del a_list[0] Delete item of at an index that's out of range raises IndexError >>> del a_list[100] Traceback (most recent call last): ... IndexError: Index out of range Replace item at a specific index >>> a_list[0] = 100 Replace item of at an index that's out of range raises IndexError >>> a_list[100] = 100 Traceback (most recent call last): ... IndexError: Index out of range Delete all items from the list >>> a_list.remove_all() >>> a_list []","title":"CircularlyDoublyLinkedList"},{"location":"data_structures/linked_lists/circularly_singly_linked_list/","text":"CircularlySinglyLinkedList ( SinglyLinkedList ) A circularly singly linked list is a cyclic collection of nodes whose head and tail nodes are connected. Each node contains a reference to the node succeeding it. Instantiate a circularly singly linked list object >>> a_list = CircularlySinglyLinkedList() Append an item to the list >>> a_list.append(0) The L.append(x) method is an alias of L.insert_last(x) >>> a_list.insert_last(1) Insert an item at the head of the list >>> a_list.insert_first(2) Insert an item at a specific index >>> a_list.insert(1, 3) Insert an item at an index that's out of range raises IndexError >>> a_list.insert(100, 3) Traceback (most recent call last): ... IndexError: Index out of range Get first item of the list >>> a_list.get_first() 2 Get first item of an empty list raises Empty >>> CircularlySinglyLinkedList().get_first() Traceback (most recent call last): ... linked_list.Empty: List is empty Get last item of the list >>> a_list.get_last() 1 Get last item of an empty list raises Empty >>> CircularlySinglyLinkedList().get_last() Traceback (most recent call last): ... linked_list.Empty: List is empty Get item at a specific index >>> a_list[1] 3 Get item at an index that's out of range raises IndexError >>> a_list[100] Traceback (most recent call last): ... IndexError: Index out of range Get items at slice range of the list >>> a_list[1:3] [3, 0] Get items at a slice that's out of range raises IndexError >>> a_list[1:100] Traceback (most recent call last): ... IndexError: Index out of range Get items at a slice with a slice step of less than one raises a ValueError >>> a_list[1:3:0] Traceback (most recent call last): ... ValueError: Step needs to be greater than zero Get an iterable object of the list >>> iterable_object = iter(a_list) Get next item of the iterable object >>> next(iterable_object) 2 Get next item of the list iterator >>> next(a_list) 3 Get length of the the list >>> len(a_list) 4 Get a string representation of the list >>> str(a_list) '[2, 3, 0, 1]' >>> a_list [2, 3, 0, 1] Delete first item of the list >>> a_list.remove_first() Delete first item of an empty list raises Empty >>> CircularlySinglyLinkedList().remove_first() Traceback (most recent call last): ... linked_list.Empty: List is empty Delete last item of the list >>> a_list.remove_last() Delete last item of an empty list raises Empty >>> CircularlySinglyLinkedList().remove_last() Traceback (most recent call last): ... linked_list.Empty: List is empty Delete item at a specific index >>> del a_list[0] Delete item of at an index that's out of range raises IndexError >>> del a_list[100] Traceback (most recent call last): ... IndexError: Index out of range Replace item at a specific index >>> a_list[0] = 100 Replace item of at an index that's out of range raises IndexError >>> a_list[100] = 100 Traceback (most recent call last): ... IndexError: Index out of range Delete all items from the list >>> a_list.remove_all() >>> a_list []","title":"Circularly Singly Linked List"},{"location":"data_structures/linked_lists/circularly_singly_linked_list/#data_structures.linked_lists.circularly_singly_linked_list.CircularlySinglyLinkedList","text":"A circularly singly linked list is a cyclic collection of nodes whose head and tail nodes are connected. Each node contains a reference to the node succeeding it. Instantiate a circularly singly linked list object >>> a_list = CircularlySinglyLinkedList() Append an item to the list >>> a_list.append(0) The L.append(x) method is an alias of L.insert_last(x) >>> a_list.insert_last(1) Insert an item at the head of the list >>> a_list.insert_first(2) Insert an item at a specific index >>> a_list.insert(1, 3) Insert an item at an index that's out of range raises IndexError >>> a_list.insert(100, 3) Traceback (most recent call last): ... IndexError: Index out of range Get first item of the list >>> a_list.get_first() 2 Get first item of an empty list raises Empty >>> CircularlySinglyLinkedList().get_first() Traceback (most recent call last): ... linked_list.Empty: List is empty Get last item of the list >>> a_list.get_last() 1 Get last item of an empty list raises Empty >>> CircularlySinglyLinkedList().get_last() Traceback (most recent call last): ... linked_list.Empty: List is empty Get item at a specific index >>> a_list[1] 3 Get item at an index that's out of range raises IndexError >>> a_list[100] Traceback (most recent call last): ... IndexError: Index out of range Get items at slice range of the list >>> a_list[1:3] [3, 0] Get items at a slice that's out of range raises IndexError >>> a_list[1:100] Traceback (most recent call last): ... IndexError: Index out of range Get items at a slice with a slice step of less than one raises a ValueError >>> a_list[1:3:0] Traceback (most recent call last): ... ValueError: Step needs to be greater than zero Get an iterable object of the list >>> iterable_object = iter(a_list) Get next item of the iterable object >>> next(iterable_object) 2 Get next item of the list iterator >>> next(a_list) 3 Get length of the the list >>> len(a_list) 4 Get a string representation of the list >>> str(a_list) '[2, 3, 0, 1]' >>> a_list [2, 3, 0, 1] Delete first item of the list >>> a_list.remove_first() Delete first item of an empty list raises Empty >>> CircularlySinglyLinkedList().remove_first() Traceback (most recent call last): ... linked_list.Empty: List is empty Delete last item of the list >>> a_list.remove_last() Delete last item of an empty list raises Empty >>> CircularlySinglyLinkedList().remove_last() Traceback (most recent call last): ... linked_list.Empty: List is empty Delete item at a specific index >>> del a_list[0] Delete item of at an index that's out of range raises IndexError >>> del a_list[100] Traceback (most recent call last): ... IndexError: Index out of range Replace item at a specific index >>> a_list[0] = 100 Replace item of at an index that's out of range raises IndexError >>> a_list[100] = 100 Traceback (most recent call last): ... IndexError: Index out of range Delete all items from the list >>> a_list.remove_all() >>> a_list []","title":"CircularlySinglyLinkedList"},{"location":"data_structures/linked_lists/doubly_linked_list/","text":"DoublyLinkedList ( LinkedList ) A doubly linked list is a linear collection of nodes whose head and tail nodes are unconnected. Each node contains a reference to the node preceding it, and a reference to the node succeeding it. Instantiate a doubly linked list object >>> a_list = DoublyLinkedList() Append an item to the list >>> a_list.append(0) The L.append(x) method is an alias of L.insert_last(x) >>> a_list.insert_last(1) Insert an item at the head of the list >>> a_list.insert_first(2) Insert an item at a specific index >>> a_list.insert(1, 3) Insert an item at an index that's out of range raises IndexError >>> a_list.insert(100, 3) Traceback (most recent call last): ... IndexError: Index out of range Get first item of the list >>> a_list.get_first() 2 Get first item of an empty list raises Empty >>> DoublyLinkedList().get_first() Traceback (most recent call last): ... linked_list.Empty: List is empty Get last item of the list >>> a_list.get_last() 1 Get last item of an empty list raises Empty >>> DoublyLinkedList().get_last() Traceback (most recent call last): ... linked_list.Empty: List is empty Get item at a specific index >>> a_list[1] 3 Get item at an index that's out of range raises IndexError >>> a_list[100] Traceback (most recent call last): ... IndexError: Index out of range Get items at slice range of the list >>> a_list[1:3] [3, 0] Get items at a slice that's out of range raises IndexError >>> a_list[1:100] Traceback (most recent call last): ... IndexError: Index out of range Get items at a slice with a slice step of less than one raises a ValueError >>> a_list[1:3:0] Traceback (most recent call last): ... ValueError: Step needs to be greater than zero Get an iterable object of the list >>> iterable_object = iter(a_list) Get next item of the iterable object >>> next(iterable_object) 2 Get next item of the list iterator >>> next(a_list) 3 Get length of the the list >>> len(a_list) 4 Get a string representation of the list >>> str(a_list) '[2, 3, 0, 1]' >>> a_list [2, 3, 0, 1] Delete first item of the list >>> a_list.remove_first() Delete first item of an empty list raises Empty >>> DoublyLinkedList().remove_first() Traceback (most recent call last): ... linked_list.Empty: List is empty Delete last item of the list >>> a_list.remove_last() Delete last item of an empty list raises Empty >>> DoublyLinkedList().remove_last() Traceback (most recent call last): ... linked_list.Empty: List is empty Delete item at a specific index >>> del a_list[0] Delete item of at an index that's out of range raises IndexError >>> del a_list[100] Traceback (most recent call last): ... IndexError: Index out of range Replace item at a specific index >>> a_list[0] = 100 Replace item of at an index that's out of range raises IndexError >>> a_list[100] = 100 Traceback (most recent call last): ... IndexError: Index out of range Delete all items from the list >>> a_list.remove_all() >>> a_list [] get_last ( self ) Return item at the tail of the list. Time complexity: O(1). Returns: Type Description last item in list Exceptions: Type Description Empty when the list is empty Source code in linked_lists/doubly_linked_list.py def get_last ( self ): \"\"\"Return item at the tail of the list. Time complexity: O(1). :return: last item in list :raises Empty: when the list is empty \"\"\" if self . _length == 0 : raise Empty ( \"List is empty\" ) return self . _tail . previous_node . data insert_last ( self , data ) Add item at the tail of the list. Time complexity: O(1). Parameters: Name Type Description Default data item to insert required Source code in linked_lists/doubly_linked_list.py def insert_last ( self , data ): \"\"\"Add item at the tail of the list. Time complexity: O(1). :param data: item to insert \"\"\" self . _length += 1 DoublyLinkedList . _insert_between ( LinkedList . _Node ( data ), self . _tail . previous_node , self . _tail ) remove_last ( self ) Delete item at the tail of the list. Time complexity: O(1). Exceptions: Type Description Empty when the list is empty Source code in linked_lists/doubly_linked_list.py def remove_last ( self ): \"\"\"Delete item at the tail of the list. Time complexity: O(1). :raises Empty: when the list is empty \"\"\" if self . _length == 0 : raise Empty ( \"List is empty\" ) self . _length -= 1 current_node = self . _tail . previous_node previous_node = current_node . previous_node DoublyLinkedList . _remove_between ( previous_node , self . _tail )","title":"Doubly Linked List"},{"location":"data_structures/linked_lists/doubly_linked_list/#data_structures.linked_lists.doubly_linked_list.DoublyLinkedList","text":"A doubly linked list is a linear collection of nodes whose head and tail nodes are unconnected. Each node contains a reference to the node preceding it, and a reference to the node succeeding it. Instantiate a doubly linked list object >>> a_list = DoublyLinkedList() Append an item to the list >>> a_list.append(0) The L.append(x) method is an alias of L.insert_last(x) >>> a_list.insert_last(1) Insert an item at the head of the list >>> a_list.insert_first(2) Insert an item at a specific index >>> a_list.insert(1, 3) Insert an item at an index that's out of range raises IndexError >>> a_list.insert(100, 3) Traceback (most recent call last): ... IndexError: Index out of range Get first item of the list >>> a_list.get_first() 2 Get first item of an empty list raises Empty >>> DoublyLinkedList().get_first() Traceback (most recent call last): ... linked_list.Empty: List is empty Get last item of the list >>> a_list.get_last() 1 Get last item of an empty list raises Empty >>> DoublyLinkedList().get_last() Traceback (most recent call last): ... linked_list.Empty: List is empty Get item at a specific index >>> a_list[1] 3 Get item at an index that's out of range raises IndexError >>> a_list[100] Traceback (most recent call last): ... IndexError: Index out of range Get items at slice range of the list >>> a_list[1:3] [3, 0] Get items at a slice that's out of range raises IndexError >>> a_list[1:100] Traceback (most recent call last): ... IndexError: Index out of range Get items at a slice with a slice step of less than one raises a ValueError >>> a_list[1:3:0] Traceback (most recent call last): ... ValueError: Step needs to be greater than zero Get an iterable object of the list >>> iterable_object = iter(a_list) Get next item of the iterable object >>> next(iterable_object) 2 Get next item of the list iterator >>> next(a_list) 3 Get length of the the list >>> len(a_list) 4 Get a string representation of the list >>> str(a_list) '[2, 3, 0, 1]' >>> a_list [2, 3, 0, 1] Delete first item of the list >>> a_list.remove_first() Delete first item of an empty list raises Empty >>> DoublyLinkedList().remove_first() Traceback (most recent call last): ... linked_list.Empty: List is empty Delete last item of the list >>> a_list.remove_last() Delete last item of an empty list raises Empty >>> DoublyLinkedList().remove_last() Traceback (most recent call last): ... linked_list.Empty: List is empty Delete item at a specific index >>> del a_list[0] Delete item of at an index that's out of range raises IndexError >>> del a_list[100] Traceback (most recent call last): ... IndexError: Index out of range Replace item at a specific index >>> a_list[0] = 100 Replace item of at an index that's out of range raises IndexError >>> a_list[100] = 100 Traceback (most recent call last): ... IndexError: Index out of range Delete all items from the list >>> a_list.remove_all() >>> a_list []","title":"DoublyLinkedList"},{"location":"data_structures/linked_lists/doubly_linked_list/#data_structures.linked_lists.doubly_linked_list.DoublyLinkedList.get_last","text":"Return item at the tail of the list. Time complexity: O(1). Returns: Type Description last item in list Exceptions: Type Description Empty when the list is empty Source code in linked_lists/doubly_linked_list.py def get_last ( self ): \"\"\"Return item at the tail of the list. Time complexity: O(1). :return: last item in list :raises Empty: when the list is empty \"\"\" if self . _length == 0 : raise Empty ( \"List is empty\" ) return self . _tail . previous_node . data","title":"get_last()"},{"location":"data_structures/linked_lists/doubly_linked_list/#data_structures.linked_lists.doubly_linked_list.DoublyLinkedList.insert_last","text":"Add item at the tail of the list. Time complexity: O(1). Parameters: Name Type Description Default data item to insert required Source code in linked_lists/doubly_linked_list.py def insert_last ( self , data ): \"\"\"Add item at the tail of the list. Time complexity: O(1). :param data: item to insert \"\"\" self . _length += 1 DoublyLinkedList . _insert_between ( LinkedList . _Node ( data ), self . _tail . previous_node , self . _tail )","title":"insert_last()"},{"location":"data_structures/linked_lists/doubly_linked_list/#data_structures.linked_lists.doubly_linked_list.DoublyLinkedList.remove_last","text":"Delete item at the tail of the list. Time complexity: O(1). Exceptions: Type Description Empty when the list is empty Source code in linked_lists/doubly_linked_list.py def remove_last ( self ): \"\"\"Delete item at the tail of the list. Time complexity: O(1). :raises Empty: when the list is empty \"\"\" if self . _length == 0 : raise Empty ( \"List is empty\" ) self . _length -= 1 current_node = self . _tail . previous_node previous_node = current_node . previous_node DoublyLinkedList . _remove_between ( previous_node , self . _tail )","title":"remove_last()"},{"location":"data_structures/linked_lists/linked_list/","text":"LinkedList ( ABC ) A linked list is a collection of nodes, with each node containing a reference to the node preceding it, or the node succeeding it, or both. Data structures that implement this abstract data type include: singly linked list circularly singly linked list doubly linked list circularly doubly linked list For each of these data structures, the implementation details may defer between one implementation and another. One implementation may use sentinel nodes to denote the head and tail nodes, whereas another may use normal nodes with references to items within the list for the head and tail. The implementation details may also change depending on the context that these data structures will be used in, so as to best optimise them to the tasks within that specific context. The implementation of the various linked list data structures defined within this project is meant to provide a uniform behaviour for all the data structures, such that one data structure may be replaced with another seamlessly. __delitem__ ( self , idx ) special Delete item at a specific index. Time complexity: O(n). Parameters: Name Type Description Default idx int index of item to be deleted required Exceptions: Type Description IndexError when the index passed is out of range Source code in linked_lists/linked_list.py def __delitem__ ( self , idx : int ) -> Any : \"\"\"Delete item at a specific index. Time complexity: O(n). :param idx: index of item to be deleted :raises IndexError: when the index passed is out of range \"\"\" if idx < 0 or idx >= self . _length : raise IndexError ( \"Index out of range\" ) self . _length -= 1 previous_node = self . _head current_node = previous_node . next_node for i in range ( idx ): previous_node = current_node current_node = current_node . next_node self . _remove_between ( previous_node , current_node . next_node ) __getitem__ ( self , idx ) special Get item at a specific index, or items in a slice range of the list. Time complexity: O(n). Parameters: Name Type Description Default idx Union[int, slice] index or slice range of items within the list required Returns: Type Description Any item at a specific index, or items in a slice range Exceptions: Type Description IndexError when the index or slice passed is out of range ValueError when the step of the slice passed is less than one Source code in linked_lists/linked_list.py def __getitem__ ( self , idx : Union [ int , slice ]) -> Any : \"\"\"Get item at a specific index, or items in a slice range of the list. Time complexity: O(n). :param idx: index or slice range of items within the list :return: item at a specific index, or items in a slice range :raises IndexError: when the index or slice passed is out of range :raises ValueError: when the step of the slice passed is less than one \"\"\" if isinstance ( idx , int ): if idx < 0 or idx >= self . _length : raise IndexError ( \"Index out of range\" ) current_node = self . _head . next_node for i in range ( idx ): current_node = current_node . next_node return current_node . data elif isinstance ( idx , slice ): start = 0 if idx . start is None else idx . start stop = self . _length if idx . stop is None else idx . stop step = 1 if idx . step is None else idx . step if step <= 0 : raise ValueError ( \"Step needs to be greater than zero\" ) if start < 0 or start > self . _length or stop < 0 or stop > self . _length : raise IndexError ( \"Index out of range\" ) current_node = self . _head . next_node a_list = copy . deepcopy ( self ) i = 0 skipped = 0 a_list . remove_all () while i < stop : if i == start or ( i >= start and skipped == step ): a_list . append ( current_node . data ) skipped = 0 current_node = current_node . next_node i += 1 skipped += 1 return a_list else : raise TypeError __iter__ ( self ) special Get a linked list iterable. Time complexity: O(1). To iterate through all the items using the returned iterable, time complexity is O(n). Returns: Type Description Iterable linked list iterable Source code in linked_lists/linked_list.py def __iter__ ( self ) -> Iterable : \"\"\"Get a linked list iterable. Time complexity: O(1). To iterate through all the items using the returned iterable, time complexity is O(n). :return: linked list iterable \"\"\" return self __len__ ( self ) special Get the total number of items in list. Time complexity: O(1). Returns: Type Description int count of items in list Source code in linked_lists/linked_list.py def __len__ ( self ) -> int : \"\"\"Get the total number of items in list. Time complexity: O(1). :return: count of items in list \"\"\" return self . _length __next__ ( self ) special Get the next item of linked list iterator. Time complexity: O(1). Returns: Type Description Any next item Exceptions: Type Description StopIteration when the cursor denoting the current item surpasses the last item of the list Source code in linked_lists/linked_list.py def __next__ ( self ) -> Any : \"\"\"Get the next item of linked list iterator. Time complexity: O(1). :return: next item :raises StopIteration: when the cursor denoting the current item surpasses the last item of the list \"\"\" self . __current_node = ( self . _head if self . __current_node is None else self . __current_node . next_node ) next_node = self . __current_node . next_node if isinstance ( next_node , LinkedList . _SentinelNode ): self . __current_node = None raise StopIteration return next_node . data __repr__ ( self ) special Get a string representation of the list. Time complexity: O(n). Returns: Type Description str string representation of the list Source code in linked_lists/linked_list.py def __repr__ ( self ) -> str : \"\"\"Get a string representation of the list. Time complexity: O(n). :return: string representation of the list \"\"\" if self . _length == 0 : return \"[]\" current_node = self . _head . next_node s = \"[\" while not isinstance ( current_node , LinkedList . _SentinelNode ): s += f \" { current_node . data } , \" current_node = current_node . next_node return f \" { s [: - 2 ] } ]\" __setitem__ ( self , idx , data ) special Replace item at a specific index. Time complexity: O(n). Parameters: Name Type Description Default idx int index of item to be replaced required data Any new item to replace existing item required Exceptions: Type Description IndexError when the index passed is out of range Source code in linked_lists/linked_list.py def __setitem__ ( self , idx : int , data : Any ) -> None : \"\"\"Replace item at a specific index. Time complexity: O(n). :param idx: index of item to be replaced :param data: new item to replace existing item :raises IndexError: when the index passed is out of range \"\"\" if idx < 0 or idx >= self . _length : raise IndexError ( \"Index out of range\" ) current_node = self . _head . next_node for i in range ( idx ): current_node = current_node . next_node current_node . data = data append ( self , data ) Alias of insert_last Parameters: Name Type Description Default data Any item to insert required Source code in linked_lists/linked_list.py def append ( self , data : Any ) -> None : \"\"\"Alias of insert_last :param data: item to insert \"\"\" self . insert_last ( data ) get_first ( self ) Return item at the head of the list. Time complexity: O(1). Returns: Type Description Any first item in list Exceptions: Type Description Empty when the list is empty Source code in linked_lists/linked_list.py def get_first ( self ) -> Any : \"\"\"Return item at the head of the list. Time complexity: O(1). :return: first item in list :raises Empty: when the list is empty \"\"\" if self . _length == 0 : raise Empty ( \"List is empty\" ) return self . _head . next_node . data get_last ( self ) Return item at the tail of the list Returns: Type Description Any last item in list Source code in linked_lists/linked_list.py @abstractmethod def get_last ( self ) -> Any : \"\"\"Return item at the tail of the list :return: last item in list \"\"\" pass insert ( self , idx , data ) Add item at a specific index of the list. Time complexity: O(n). Parameters: Name Type Description Default idx int index to insert item at required data Any item to insert required Exceptions: Type Description IndexError when the index passed is out of range Source code in linked_lists/linked_list.py def insert ( self , idx : int , data : Any ) -> None : \"\"\"Add item at a specific index of the list. Time complexity: O(n). :param idx: index to insert item at :param data: item to insert :raises IndexError: when the index passed is out of range \"\"\" if idx < 0 or idx >= self . _length : raise IndexError ( \"Index out of range\" ) self . _length += 1 previous_node = self . _head current_node = previous_node . next_node for i in range ( idx ): previous_node = current_node current_node = current_node . next_node self . _insert_between ( LinkedList . _Node ( data ), previous_node , current_node ) insert_first ( self , data ) Add item at the head of the list. Time complexity: O(1). Parameters: Name Type Description Default data Any item to insert required Source code in linked_lists/linked_list.py def insert_first ( self , data : Any ) -> None : \"\"\"Add item at the head of the list. Time complexity: O(1). :param data: item to insert \"\"\" self . _length += 1 self . _insert_between ( LinkedList . _Node ( data ), self . _head , self . _head . next_node ) insert_last ( self , data ) Add item at the tail of the list Parameters: Name Type Description Default data Any item to insert required Source code in linked_lists/linked_list.py @abstractmethod def insert_last ( self , data : Any ) -> None : \"\"\"Add item at the tail of the list :param data: item to insert \"\"\" pass remove_all ( self ) Delete all items from the list. Time complexity: O(1). Source code in linked_lists/linked_list.py def remove_all ( self ) -> None : \"\"\"Delete all items from the list. Time complexity: O(1).\"\"\" self . __init__ () remove_first ( self ) Delete item at the head of the list. Time complexity: O(1). Exceptions: Type Description Empty when the list is empty Source code in linked_lists/linked_list.py def remove_first ( self ) -> None : \"\"\"Delete item at the head of the list. Time complexity: O(1). :raises Empty: when the list is empty \"\"\" if self . _length == 0 : raise Empty ( \"List is empty\" ) self . _length -= 1 current_node = self . _head . next_node self . _remove_between ( self . _head , current_node . next_node ) remove_last ( self ) Delete item at the tail of the list Source code in linked_lists/linked_list.py @abstractmethod def remove_last ( self ) -> None : \"\"\"Delete item at the tail of the list\"\"\" pass","title":"Linked List ADT"},{"location":"data_structures/linked_lists/linked_list/#data_structures.linked_lists.linked_list.LinkedList","text":"A linked list is a collection of nodes, with each node containing a reference to the node preceding it, or the node succeeding it, or both. Data structures that implement this abstract data type include: singly linked list circularly singly linked list doubly linked list circularly doubly linked list For each of these data structures, the implementation details may defer between one implementation and another. One implementation may use sentinel nodes to denote the head and tail nodes, whereas another may use normal nodes with references to items within the list for the head and tail. The implementation details may also change depending on the context that these data structures will be used in, so as to best optimise them to the tasks within that specific context. The implementation of the various linked list data structures defined within this project is meant to provide a uniform behaviour for all the data structures, such that one data structure may be replaced with another seamlessly.","title":"LinkedList"},{"location":"data_structures/linked_lists/linked_list/#data_structures.linked_lists.linked_list.LinkedList.__delitem__","text":"Delete item at a specific index. Time complexity: O(n). Parameters: Name Type Description Default idx int index of item to be deleted required Exceptions: Type Description IndexError when the index passed is out of range Source code in linked_lists/linked_list.py def __delitem__ ( self , idx : int ) -> Any : \"\"\"Delete item at a specific index. Time complexity: O(n). :param idx: index of item to be deleted :raises IndexError: when the index passed is out of range \"\"\" if idx < 0 or idx >= self . _length : raise IndexError ( \"Index out of range\" ) self . _length -= 1 previous_node = self . _head current_node = previous_node . next_node for i in range ( idx ): previous_node = current_node current_node = current_node . next_node self . _remove_between ( previous_node , current_node . next_node )","title":"__delitem__()"},{"location":"data_structures/linked_lists/linked_list/#data_structures.linked_lists.linked_list.LinkedList.__getitem__","text":"Get item at a specific index, or items in a slice range of the list. Time complexity: O(n). Parameters: Name Type Description Default idx Union[int, slice] index or slice range of items within the list required Returns: Type Description Any item at a specific index, or items in a slice range Exceptions: Type Description IndexError when the index or slice passed is out of range ValueError when the step of the slice passed is less than one Source code in linked_lists/linked_list.py def __getitem__ ( self , idx : Union [ int , slice ]) -> Any : \"\"\"Get item at a specific index, or items in a slice range of the list. Time complexity: O(n). :param idx: index or slice range of items within the list :return: item at a specific index, or items in a slice range :raises IndexError: when the index or slice passed is out of range :raises ValueError: when the step of the slice passed is less than one \"\"\" if isinstance ( idx , int ): if idx < 0 or idx >= self . _length : raise IndexError ( \"Index out of range\" ) current_node = self . _head . next_node for i in range ( idx ): current_node = current_node . next_node return current_node . data elif isinstance ( idx , slice ): start = 0 if idx . start is None else idx . start stop = self . _length if idx . stop is None else idx . stop step = 1 if idx . step is None else idx . step if step <= 0 : raise ValueError ( \"Step needs to be greater than zero\" ) if start < 0 or start > self . _length or stop < 0 or stop > self . _length : raise IndexError ( \"Index out of range\" ) current_node = self . _head . next_node a_list = copy . deepcopy ( self ) i = 0 skipped = 0 a_list . remove_all () while i < stop : if i == start or ( i >= start and skipped == step ): a_list . append ( current_node . data ) skipped = 0 current_node = current_node . next_node i += 1 skipped += 1 return a_list else : raise TypeError","title":"__getitem__()"},{"location":"data_structures/linked_lists/linked_list/#data_structures.linked_lists.linked_list.LinkedList.__iter__","text":"Get a linked list iterable. Time complexity: O(1). To iterate through all the items using the returned iterable, time complexity is O(n). Returns: Type Description Iterable linked list iterable Source code in linked_lists/linked_list.py def __iter__ ( self ) -> Iterable : \"\"\"Get a linked list iterable. Time complexity: O(1). To iterate through all the items using the returned iterable, time complexity is O(n). :return: linked list iterable \"\"\" return self","title":"__iter__()"},{"location":"data_structures/linked_lists/linked_list/#data_structures.linked_lists.linked_list.LinkedList.__len__","text":"Get the total number of items in list. Time complexity: O(1). Returns: Type Description int count of items in list Source code in linked_lists/linked_list.py def __len__ ( self ) -> int : \"\"\"Get the total number of items in list. Time complexity: O(1). :return: count of items in list \"\"\" return self . _length","title":"__len__()"},{"location":"data_structures/linked_lists/linked_list/#data_structures.linked_lists.linked_list.LinkedList.__next__","text":"Get the next item of linked list iterator. Time complexity: O(1). Returns: Type Description Any next item Exceptions: Type Description StopIteration when the cursor denoting the current item surpasses the last item of the list Source code in linked_lists/linked_list.py def __next__ ( self ) -> Any : \"\"\"Get the next item of linked list iterator. Time complexity: O(1). :return: next item :raises StopIteration: when the cursor denoting the current item surpasses the last item of the list \"\"\" self . __current_node = ( self . _head if self . __current_node is None else self . __current_node . next_node ) next_node = self . __current_node . next_node if isinstance ( next_node , LinkedList . _SentinelNode ): self . __current_node = None raise StopIteration return next_node . data","title":"__next__()"},{"location":"data_structures/linked_lists/linked_list/#data_structures.linked_lists.linked_list.LinkedList.__repr__","text":"Get a string representation of the list. Time complexity: O(n). Returns: Type Description str string representation of the list Source code in linked_lists/linked_list.py def __repr__ ( self ) -> str : \"\"\"Get a string representation of the list. Time complexity: O(n). :return: string representation of the list \"\"\" if self . _length == 0 : return \"[]\" current_node = self . _head . next_node s = \"[\" while not isinstance ( current_node , LinkedList . _SentinelNode ): s += f \" { current_node . data } , \" current_node = current_node . next_node return f \" { s [: - 2 ] } ]\"","title":"__repr__()"},{"location":"data_structures/linked_lists/linked_list/#data_structures.linked_lists.linked_list.LinkedList.__setitem__","text":"Replace item at a specific index. Time complexity: O(n). Parameters: Name Type Description Default idx int index of item to be replaced required data Any new item to replace existing item required Exceptions: Type Description IndexError when the index passed is out of range Source code in linked_lists/linked_list.py def __setitem__ ( self , idx : int , data : Any ) -> None : \"\"\"Replace item at a specific index. Time complexity: O(n). :param idx: index of item to be replaced :param data: new item to replace existing item :raises IndexError: when the index passed is out of range \"\"\" if idx < 0 or idx >= self . _length : raise IndexError ( \"Index out of range\" ) current_node = self . _head . next_node for i in range ( idx ): current_node = current_node . next_node current_node . data = data","title":"__setitem__()"},{"location":"data_structures/linked_lists/linked_list/#data_structures.linked_lists.linked_list.LinkedList.append","text":"Alias of insert_last Parameters: Name Type Description Default data Any item to insert required Source code in linked_lists/linked_list.py def append ( self , data : Any ) -> None : \"\"\"Alias of insert_last :param data: item to insert \"\"\" self . insert_last ( data )","title":"append()"},{"location":"data_structures/linked_lists/linked_list/#data_structures.linked_lists.linked_list.LinkedList.get_first","text":"Return item at the head of the list. Time complexity: O(1). Returns: Type Description Any first item in list Exceptions: Type Description Empty when the list is empty Source code in linked_lists/linked_list.py def get_first ( self ) -> Any : \"\"\"Return item at the head of the list. Time complexity: O(1). :return: first item in list :raises Empty: when the list is empty \"\"\" if self . _length == 0 : raise Empty ( \"List is empty\" ) return self . _head . next_node . data","title":"get_first()"},{"location":"data_structures/linked_lists/linked_list/#data_structures.linked_lists.linked_list.LinkedList.get_last","text":"Return item at the tail of the list Returns: Type Description Any last item in list Source code in linked_lists/linked_list.py @abstractmethod def get_last ( self ) -> Any : \"\"\"Return item at the tail of the list :return: last item in list \"\"\" pass","title":"get_last()"},{"location":"data_structures/linked_lists/linked_list/#data_structures.linked_lists.linked_list.LinkedList.insert","text":"Add item at a specific index of the list. Time complexity: O(n). Parameters: Name Type Description Default idx int index to insert item at required data Any item to insert required Exceptions: Type Description IndexError when the index passed is out of range Source code in linked_lists/linked_list.py def insert ( self , idx : int , data : Any ) -> None : \"\"\"Add item at a specific index of the list. Time complexity: O(n). :param idx: index to insert item at :param data: item to insert :raises IndexError: when the index passed is out of range \"\"\" if idx < 0 or idx >= self . _length : raise IndexError ( \"Index out of range\" ) self . _length += 1 previous_node = self . _head current_node = previous_node . next_node for i in range ( idx ): previous_node = current_node current_node = current_node . next_node self . _insert_between ( LinkedList . _Node ( data ), previous_node , current_node )","title":"insert()"},{"location":"data_structures/linked_lists/linked_list/#data_structures.linked_lists.linked_list.LinkedList.insert_first","text":"Add item at the head of the list. Time complexity: O(1). Parameters: Name Type Description Default data Any item to insert required Source code in linked_lists/linked_list.py def insert_first ( self , data : Any ) -> None : \"\"\"Add item at the head of the list. Time complexity: O(1). :param data: item to insert \"\"\" self . _length += 1 self . _insert_between ( LinkedList . _Node ( data ), self . _head , self . _head . next_node )","title":"insert_first()"},{"location":"data_structures/linked_lists/linked_list/#data_structures.linked_lists.linked_list.LinkedList.insert_last","text":"Add item at the tail of the list Parameters: Name Type Description Default data Any item to insert required Source code in linked_lists/linked_list.py @abstractmethod def insert_last ( self , data : Any ) -> None : \"\"\"Add item at the tail of the list :param data: item to insert \"\"\" pass","title":"insert_last()"},{"location":"data_structures/linked_lists/linked_list/#data_structures.linked_lists.linked_list.LinkedList.remove_all","text":"Delete all items from the list. Time complexity: O(1). Source code in linked_lists/linked_list.py def remove_all ( self ) -> None : \"\"\"Delete all items from the list. Time complexity: O(1).\"\"\" self . __init__ ()","title":"remove_all()"},{"location":"data_structures/linked_lists/linked_list/#data_structures.linked_lists.linked_list.LinkedList.remove_first","text":"Delete item at the head of the list. Time complexity: O(1). Exceptions: Type Description Empty when the list is empty Source code in linked_lists/linked_list.py def remove_first ( self ) -> None : \"\"\"Delete item at the head of the list. Time complexity: O(1). :raises Empty: when the list is empty \"\"\" if self . _length == 0 : raise Empty ( \"List is empty\" ) self . _length -= 1 current_node = self . _head . next_node self . _remove_between ( self . _head , current_node . next_node )","title":"remove_first()"},{"location":"data_structures/linked_lists/linked_list/#data_structures.linked_lists.linked_list.LinkedList.remove_last","text":"Delete item at the tail of the list Source code in linked_lists/linked_list.py @abstractmethod def remove_last ( self ) -> None : \"\"\"Delete item at the tail of the list\"\"\" pass","title":"remove_last()"},{"location":"data_structures/linked_lists/singly_linked_list/","text":"SinglyLinkedList ( LinkedList ) A singly linked list is a linear collection of nodes whose head and tail nodes are unconnected. Each node contains a reference to the node succeeding it. Instantiate a singly linked list object >>> a_list = SinglyLinkedList() Append an item to the list >>> a_list.append(0) The L.append(x) method is an alias of L.insert_last(x) >>> a_list.insert_last(1) Insert an item at the head of the list >>> a_list.insert_first(2) Insert an item at a specific index >>> a_list.insert(1, 3) Insert an item at an index that's out of range raises IndexError >>> a_list.insert(100, 3) Traceback (most recent call last): ... IndexError: Index out of range Get first item of the list >>> a_list.get_first() 2 Get first item of an empty list raises Empty >>> SinglyLinkedList().get_first() Traceback (most recent call last): ... linked_list.Empty: List is empty Get last item of the list >>> a_list.get_last() 1 Get last item of an empty list raises Empty >>> SinglyLinkedList().get_last() Traceback (most recent call last): ... linked_list.Empty: List is empty Get item at a specific index >>> a_list[1] 3 Get item at an index that's out of range raises IndexError >>> a_list[100] Traceback (most recent call last): ... IndexError: Index out of range Get items at slice range of the list >>> a_list[1:3] [3, 0] Get items at a slice that's out of range raises IndexError >>> a_list[1:100] Traceback (most recent call last): ... IndexError: Index out of range Get items at a slice with a slice step of less than one raises a ValueError >>> a_list[1:3:0] Traceback (most recent call last): ... ValueError: Step needs to be greater than zero Get an iterable object of the list >>> iterable_object = iter(a_list) Get next item of the iterable object >>> next(iterable_object) 2 Get next item of the list iterator >>> next(a_list) 3 Get length of the the list >>> len(a_list) 4 Get a string representation of the list >>> str(a_list) '[2, 3, 0, 1]' >>> a_list [2, 3, 0, 1] Delete first item of the list >>> a_list.remove_first() Delete first item of an empty list raises Empty >>> SinglyLinkedList().remove_first() Traceback (most recent call last): ... linked_list.Empty: List is empty Delete last item of the list >>> a_list.remove_last() Delete last item of an empty list raises Empty >>> SinglyLinkedList().remove_last() Traceback (most recent call last): ... linked_list.Empty: List is empty Delete item at a specific index >>> del a_list[0] Delete item of at an index that's out of range raises IndexError >>> del a_list[100] Traceback (most recent call last): ... IndexError: Index out of range Replace item at a specific index >>> a_list[0] = 100 Replace item of at an index that's out of range raises IndexError >>> a_list[100] = 100 Traceback (most recent call last): ... IndexError: Index out of range Delete all items from the list >>> a_list.remove_all() >>> a_list [] get_last ( self ) Return item at the tail of the list. Time complexity: O(n). Returns: Type Description Any last item in list Exceptions: Type Description Empty when the list is empty Source code in linked_lists/singly_linked_list.py def get_last ( self ) -> Any : \"\"\"Return item at the tail of the list. Time complexity: O(n). :return: last item in list :raises Empty: when the list is empty \"\"\" if self . _length == 0 : raise Empty ( \"List is empty\" ) current_node = self . _head . next_node while not isinstance ( current_node . next_node , LinkedList . _SentinelNode ): current_node = current_node . next_node return current_node . data insert_last ( self , data ) Add item at the tail of the list. Time complexity: O(n). Parameters: Name Type Description Default data Any item to insert required Source code in linked_lists/singly_linked_list.py def insert_last ( self , data : Any ) -> None : \"\"\"Add item at the tail of the list. Time complexity: O(n). :param data: item to insert \"\"\" self . _length += 1 previous_node = self . _head current_node = previous_node . next_node while not isinstance ( current_node , LinkedList . _SentinelNode ): previous_node = current_node current_node = current_node . next_node SinglyLinkedList . _insert_between ( LinkedList . _Node ( data ), previous_node , current_node ) remove_last ( self ) Delete item at the tail of the list. Time complexity: O(n). Exceptions: Type Description Empty when the list is empty Source code in linked_lists/singly_linked_list.py def remove_last ( self ) -> None : \"\"\"Delete item at the tail of the list. Time complexity: O(n). :raises Empty: when the list is empty \"\"\" if self . _length == 0 : raise Empty ( \"List is empty\" ) self . _length -= 1 previous_node = self . _head current_node = previous_node . next_node while True : if isinstance ( current_node . next_node , LinkedList . _SentinelNode ): break previous_node = current_node current_node = current_node . next_node SinglyLinkedList . _remove_between ( previous_node , current_node . next_node )","title":"Singly Linked List"},{"location":"data_structures/linked_lists/singly_linked_list/#data_structures.linked_lists.singly_linked_list.SinglyLinkedList","text":"A singly linked list is a linear collection of nodes whose head and tail nodes are unconnected. Each node contains a reference to the node succeeding it. Instantiate a singly linked list object >>> a_list = SinglyLinkedList() Append an item to the list >>> a_list.append(0) The L.append(x) method is an alias of L.insert_last(x) >>> a_list.insert_last(1) Insert an item at the head of the list >>> a_list.insert_first(2) Insert an item at a specific index >>> a_list.insert(1, 3) Insert an item at an index that's out of range raises IndexError >>> a_list.insert(100, 3) Traceback (most recent call last): ... IndexError: Index out of range Get first item of the list >>> a_list.get_first() 2 Get first item of an empty list raises Empty >>> SinglyLinkedList().get_first() Traceback (most recent call last): ... linked_list.Empty: List is empty Get last item of the list >>> a_list.get_last() 1 Get last item of an empty list raises Empty >>> SinglyLinkedList().get_last() Traceback (most recent call last): ... linked_list.Empty: List is empty Get item at a specific index >>> a_list[1] 3 Get item at an index that's out of range raises IndexError >>> a_list[100] Traceback (most recent call last): ... IndexError: Index out of range Get items at slice range of the list >>> a_list[1:3] [3, 0] Get items at a slice that's out of range raises IndexError >>> a_list[1:100] Traceback (most recent call last): ... IndexError: Index out of range Get items at a slice with a slice step of less than one raises a ValueError >>> a_list[1:3:0] Traceback (most recent call last): ... ValueError: Step needs to be greater than zero Get an iterable object of the list >>> iterable_object = iter(a_list) Get next item of the iterable object >>> next(iterable_object) 2 Get next item of the list iterator >>> next(a_list) 3 Get length of the the list >>> len(a_list) 4 Get a string representation of the list >>> str(a_list) '[2, 3, 0, 1]' >>> a_list [2, 3, 0, 1] Delete first item of the list >>> a_list.remove_first() Delete first item of an empty list raises Empty >>> SinglyLinkedList().remove_first() Traceback (most recent call last): ... linked_list.Empty: List is empty Delete last item of the list >>> a_list.remove_last() Delete last item of an empty list raises Empty >>> SinglyLinkedList().remove_last() Traceback (most recent call last): ... linked_list.Empty: List is empty Delete item at a specific index >>> del a_list[0] Delete item of at an index that's out of range raises IndexError >>> del a_list[100] Traceback (most recent call last): ... IndexError: Index out of range Replace item at a specific index >>> a_list[0] = 100 Replace item of at an index that's out of range raises IndexError >>> a_list[100] = 100 Traceback (most recent call last): ... IndexError: Index out of range Delete all items from the list >>> a_list.remove_all() >>> a_list []","title":"SinglyLinkedList"},{"location":"data_structures/linked_lists/singly_linked_list/#data_structures.linked_lists.singly_linked_list.SinglyLinkedList.get_last","text":"Return item at the tail of the list. Time complexity: O(n). Returns: Type Description Any last item in list Exceptions: Type Description Empty when the list is empty Source code in linked_lists/singly_linked_list.py def get_last ( self ) -> Any : \"\"\"Return item at the tail of the list. Time complexity: O(n). :return: last item in list :raises Empty: when the list is empty \"\"\" if self . _length == 0 : raise Empty ( \"List is empty\" ) current_node = self . _head . next_node while not isinstance ( current_node . next_node , LinkedList . _SentinelNode ): current_node = current_node . next_node return current_node . data","title":"get_last()"},{"location":"data_structures/linked_lists/singly_linked_list/#data_structures.linked_lists.singly_linked_list.SinglyLinkedList.insert_last","text":"Add item at the tail of the list. Time complexity: O(n). Parameters: Name Type Description Default data Any item to insert required Source code in linked_lists/singly_linked_list.py def insert_last ( self , data : Any ) -> None : \"\"\"Add item at the tail of the list. Time complexity: O(n). :param data: item to insert \"\"\" self . _length += 1 previous_node = self . _head current_node = previous_node . next_node while not isinstance ( current_node , LinkedList . _SentinelNode ): previous_node = current_node current_node = current_node . next_node SinglyLinkedList . _insert_between ( LinkedList . _Node ( data ), previous_node , current_node )","title":"insert_last()"},{"location":"data_structures/linked_lists/singly_linked_list/#data_structures.linked_lists.singly_linked_list.SinglyLinkedList.remove_last","text":"Delete item at the tail of the list. Time complexity: O(n). Exceptions: Type Description Empty when the list is empty Source code in linked_lists/singly_linked_list.py def remove_last ( self ) -> None : \"\"\"Delete item at the tail of the list. Time complexity: O(n). :raises Empty: when the list is empty \"\"\" if self . _length == 0 : raise Empty ( \"List is empty\" ) self . _length -= 1 previous_node = self . _head current_node = previous_node . next_node while True : if isinstance ( current_node . next_node , LinkedList . _SentinelNode ): break previous_node = current_node current_node = current_node . next_node SinglyLinkedList . _remove_between ( previous_node , current_node . next_node )","title":"remove_last()"},{"location":"data_structures/positional_linked_lists/positional_doubly_linked_list/","text":"PositionalDoublyLinkedList ( PositionalLinkedList , DoublyLinkedList ) A positional doubly linked list is a positional list implemented based on a doubly linked list Instantiate a positional doubly linked list object >>> a_list = PositionalDoublyLinkedList() Append an item to the list >>> position = a_list.append(0) >>> position.get_data() 0 The L.append(x) method is an alias of L.insert_last(x) >>> position = a_list.insert_last(1) >>> position.get_data() 1 Insert an item at the head of the list >>> position = a_list.insert_first(2) >>> position.get_data() 2 Insert an item just before a certain position in the list >>> new_position = a_list.insert_before(position, 3) >>> new_position.get_data() 3 Insert an item just after a certain position in the list >>> new_position = a_list.insert_after(position, 4) >>> new_position.get_data() 4 Replace item at a specific position >>> a_list.replace(position, 100) 2 Check if a positional doubly linked list is empty >>> a_list.is_empty() False >>> PositionalDoublyLinkedList().is_empty() True Get first item of the list >>> position = a_list.get_first() >>> position.get_data() 3 Get last item of the list >>> position = a_list.get_last() >>> position.get_data() 1 Get item just before a certain position of the list >>> position = a_list.get_last() >>> before_position = a_list.get_before(position) >>> before_position.get_data() 0 Get item just after a certain position of the list >>> position = a_list.get_first() >>> after_position = a_list.get_after(position) >>> after_position.get_data() 100 Delete item just before a certain position from the list >>> a_list.remove_before(after_position) 3 Delete item just after a certain position from the list >>> a_list.remove_after(after_position) 4 Delete item in a certain position from the list >>> position = a_list.get_first() >>> a_list.remove(position) 100 Delete first item from the list >>> a_list.remove_first() 0 Delete last item from the list >>> a_list.remove_last() 1 get_after ( self , position ) Return the position just after the passed position, None if the referenced after position doesn't exist Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Optional[positional_linked_list.PositionalLinkedList._Position] the position just after the passed position Source code in positional_linked_lists/positional_doubly_linked_list.py def get_after ( self , position : PositionalLinkedList . _Position ) -> Union [ PositionalLinkedList . _Position , None ]: super () . get_after ( position ) node = position . manipulate_node ( self , \"_validate_node\" , * []) if node is None : return None node_to_get = node . next_node if isinstance ( node_to_get , DoublyLinkedList . _SentinelNode ): return None else : return PositionalLinkedList . _Position ( self , node_to_get ) get_before ( self , position ) Return the position just before the passed position, None if the referenced before position doesn't exist Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Optional[positional_linked_list.PositionalLinkedList._Position] the position just before the passed position Source code in positional_linked_lists/positional_doubly_linked_list.py def get_before ( self , position : PositionalLinkedList . _Position ) -> Union [ PositionalLinkedList . _Position , None ]: super () . get_before ( position ) node = position . manipulate_node ( self , \"_validate_node\" , * []) if node is None : return None node_to_get = node . previous_node if isinstance ( node_to_get , DoublyLinkedList . _SentinelNode ): return None else : return PositionalLinkedList . _Position ( self , node_to_get ) get_first ( self ) Return the position of the item at the head of the list, None if the list is empty Returns: Type Description Optional[positional_linked_list.PositionalLinkedList._Position] the position of the item at the head of the list Source code in positional_linked_lists/positional_doubly_linked_list.py def get_first ( self ) -> Union [ PositionalLinkedList . _Position , None ]: if self . _length == 0 : return None return PositionalLinkedList . _Position ( self , self . _head . next_node ) get_last ( self ) Return the position of the item at the tail of the list, None if the list is empty Returns: Type Description Optional[positional_linked_list.PositionalLinkedList._Position] the position of the item at the tail of the list Source code in positional_linked_lists/positional_doubly_linked_list.py def get_last ( self ) -> Union [ PositionalLinkedList . _Position , None ]: if self . _length == 0 : return None return PositionalLinkedList . _Position ( self , self . _tail . previous_node ) insert_after ( self , position , data ) Add item after the defined position within the list Parameters: Name Type Description Default position _Position reference position required data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_doubly_linked_list.py def insert_after ( self , position : PositionalLinkedList . _Position , data : Any ) -> PositionalLinkedList . _Position : super () . insert_after ( position , data ) self . _length += 1 new_node = DoublyLinkedList . _Node ( data ) node = position . manipulate_node ( self , \"_validate_node\" , * []) DoublyLinkedList . _insert_between ( new_node , node , node . next_node ) return PositionalLinkedList . _Position ( self , new_node ) insert_before ( self , position , data ) Add item before the defined position within the list Parameters: Name Type Description Default position _Position reference position required data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_doubly_linked_list.py def insert_before ( self , position : PositionalLinkedList . _Position , data : Any ) -> PositionalLinkedList . _Position : super () . insert_before ( position , data ) self . _length += 1 new_node = DoublyLinkedList . _Node ( data ) node = position . manipulate_node ( self , \"_validate_node\" , * []) DoublyLinkedList . _insert_between ( new_node , node . previous_node , node ) return PositionalLinkedList . _Position ( self , new_node ) insert_first ( self , data ) Add item at the head of the list Parameters: Name Type Description Default data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_doubly_linked_list.py def insert_first ( self , data : Any ) -> PositionalLinkedList . _Position : DoublyLinkedList . insert_first ( self , data ) return PositionalLinkedList . _Position ( self , self . _head . next_node ) insert_last ( self , data ) Add item at the tail of the list Parameters: Name Type Description Default data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_doubly_linked_list.py def insert_last ( self , data : Any ) -> PositionalLinkedList . _Position : DoublyLinkedList . insert_last ( self , data ) return PositionalLinkedList . _Position ( self , self . _tail . previous_node ) is_empty ( self ) Return True if list is empty, else False Returns: Type Description bool True if list is empty, else False Source code in positional_linked_lists/positional_doubly_linked_list.py def is_empty ( self ) -> bool : return self . _length == 0 remove ( self , position ) Delete item at a specific position Parameters: Name Type Description Default position _Position position containing item to be deleted required Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_doubly_linked_list.py def remove ( self , position : PositionalLinkedList . _Position ) -> Any : super () . remove ( position ) self . _length -= 1 node = position . manipulate_node ( self , \"_validate_node\" , * []) _ = position . manipulate_variables ( self , \"_invalidate_position\" , * []) DoublyLinkedList . _remove_between ( node . previous_node , node . next_node ) return node . data remove_after ( self , position ) Delete item just after the passed position Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_doubly_linked_list.py def remove_after ( self , position : PositionalLinkedList . _Position ) -> Any : super () . remove_after ( position ) node = position . manipulate_node ( self , \"_validate_node\" , * []) node_to_delete = node . next_node if isinstance ( node_to_delete , DoublyLinkedList . _SentinelNode ): return None self . _length -= 1 DoublyLinkedList . _remove_between ( node , node_to_delete . next_node ) return node_to_delete . data remove_before ( self , position ) Delete item just before the passed position Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_doubly_linked_list.py def remove_before ( self , position : PositionalLinkedList . _Position ) -> Any : super () . remove_before ( position ) node = position . manipulate_node ( self , \"_validate_node\" , * []) node_to_delete = node . previous_node if isinstance ( node_to_delete , DoublyLinkedList . _SentinelNode ): return None self . _length -= 1 DoublyLinkedList . _remove_between ( node_to_delete . previous_node , node ) return node_to_delete . data remove_first ( self ) Delete item at the head of the list Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_doubly_linked_list.py def remove_first ( self ) -> Any : if self . _length == 0 : return None node_to_delete = self . _head . next_node DoublyLinkedList . remove_first ( self ) return node_to_delete . data remove_last ( self ) Delete item at the tail of the list Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_doubly_linked_list.py def remove_last ( self ) -> Any : if self . _length == 0 : return None node_to_delete = self . _tail . previous_node DoublyLinkedList . remove_last ( self ) return node_to_delete . data","title":"Positional Doubly Linked List"},{"location":"data_structures/positional_linked_lists/positional_doubly_linked_list/#data_structures.positional_linked_lists.positional_doubly_linked_list.PositionalDoublyLinkedList","text":"A positional doubly linked list is a positional list implemented based on a doubly linked list Instantiate a positional doubly linked list object >>> a_list = PositionalDoublyLinkedList() Append an item to the list >>> position = a_list.append(0) >>> position.get_data() 0 The L.append(x) method is an alias of L.insert_last(x) >>> position = a_list.insert_last(1) >>> position.get_data() 1 Insert an item at the head of the list >>> position = a_list.insert_first(2) >>> position.get_data() 2 Insert an item just before a certain position in the list >>> new_position = a_list.insert_before(position, 3) >>> new_position.get_data() 3 Insert an item just after a certain position in the list >>> new_position = a_list.insert_after(position, 4) >>> new_position.get_data() 4 Replace item at a specific position >>> a_list.replace(position, 100) 2 Check if a positional doubly linked list is empty >>> a_list.is_empty() False >>> PositionalDoublyLinkedList().is_empty() True Get first item of the list >>> position = a_list.get_first() >>> position.get_data() 3 Get last item of the list >>> position = a_list.get_last() >>> position.get_data() 1 Get item just before a certain position of the list >>> position = a_list.get_last() >>> before_position = a_list.get_before(position) >>> before_position.get_data() 0 Get item just after a certain position of the list >>> position = a_list.get_first() >>> after_position = a_list.get_after(position) >>> after_position.get_data() 100 Delete item just before a certain position from the list >>> a_list.remove_before(after_position) 3 Delete item just after a certain position from the list >>> a_list.remove_after(after_position) 4 Delete item in a certain position from the list >>> position = a_list.get_first() >>> a_list.remove(position) 100 Delete first item from the list >>> a_list.remove_first() 0 Delete last item from the list >>> a_list.remove_last() 1","title":"PositionalDoublyLinkedList"},{"location":"data_structures/positional_linked_lists/positional_doubly_linked_list/#data_structures.positional_linked_lists.positional_doubly_linked_list.PositionalDoublyLinkedList.get_after","text":"Return the position just after the passed position, None if the referenced after position doesn't exist Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Optional[positional_linked_list.PositionalLinkedList._Position] the position just after the passed position Source code in positional_linked_lists/positional_doubly_linked_list.py def get_after ( self , position : PositionalLinkedList . _Position ) -> Union [ PositionalLinkedList . _Position , None ]: super () . get_after ( position ) node = position . manipulate_node ( self , \"_validate_node\" , * []) if node is None : return None node_to_get = node . next_node if isinstance ( node_to_get , DoublyLinkedList . _SentinelNode ): return None else : return PositionalLinkedList . _Position ( self , node_to_get )","title":"get_after()"},{"location":"data_structures/positional_linked_lists/positional_doubly_linked_list/#data_structures.positional_linked_lists.positional_doubly_linked_list.PositionalDoublyLinkedList.get_before","text":"Return the position just before the passed position, None if the referenced before position doesn't exist Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Optional[positional_linked_list.PositionalLinkedList._Position] the position just before the passed position Source code in positional_linked_lists/positional_doubly_linked_list.py def get_before ( self , position : PositionalLinkedList . _Position ) -> Union [ PositionalLinkedList . _Position , None ]: super () . get_before ( position ) node = position . manipulate_node ( self , \"_validate_node\" , * []) if node is None : return None node_to_get = node . previous_node if isinstance ( node_to_get , DoublyLinkedList . _SentinelNode ): return None else : return PositionalLinkedList . _Position ( self , node_to_get )","title":"get_before()"},{"location":"data_structures/positional_linked_lists/positional_doubly_linked_list/#data_structures.positional_linked_lists.positional_doubly_linked_list.PositionalDoublyLinkedList.get_first","text":"Return the position of the item at the head of the list, None if the list is empty Returns: Type Description Optional[positional_linked_list.PositionalLinkedList._Position] the position of the item at the head of the list Source code in positional_linked_lists/positional_doubly_linked_list.py def get_first ( self ) -> Union [ PositionalLinkedList . _Position , None ]: if self . _length == 0 : return None return PositionalLinkedList . _Position ( self , self . _head . next_node )","title":"get_first()"},{"location":"data_structures/positional_linked_lists/positional_doubly_linked_list/#data_structures.positional_linked_lists.positional_doubly_linked_list.PositionalDoublyLinkedList.get_last","text":"Return the position of the item at the tail of the list, None if the list is empty Returns: Type Description Optional[positional_linked_list.PositionalLinkedList._Position] the position of the item at the tail of the list Source code in positional_linked_lists/positional_doubly_linked_list.py def get_last ( self ) -> Union [ PositionalLinkedList . _Position , None ]: if self . _length == 0 : return None return PositionalLinkedList . _Position ( self , self . _tail . previous_node )","title":"get_last()"},{"location":"data_structures/positional_linked_lists/positional_doubly_linked_list/#data_structures.positional_linked_lists.positional_doubly_linked_list.PositionalDoublyLinkedList.insert_after","text":"Add item after the defined position within the list Parameters: Name Type Description Default position _Position reference position required data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_doubly_linked_list.py def insert_after ( self , position : PositionalLinkedList . _Position , data : Any ) -> PositionalLinkedList . _Position : super () . insert_after ( position , data ) self . _length += 1 new_node = DoublyLinkedList . _Node ( data ) node = position . manipulate_node ( self , \"_validate_node\" , * []) DoublyLinkedList . _insert_between ( new_node , node , node . next_node ) return PositionalLinkedList . _Position ( self , new_node )","title":"insert_after()"},{"location":"data_structures/positional_linked_lists/positional_doubly_linked_list/#data_structures.positional_linked_lists.positional_doubly_linked_list.PositionalDoublyLinkedList.insert_before","text":"Add item before the defined position within the list Parameters: Name Type Description Default position _Position reference position required data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_doubly_linked_list.py def insert_before ( self , position : PositionalLinkedList . _Position , data : Any ) -> PositionalLinkedList . _Position : super () . insert_before ( position , data ) self . _length += 1 new_node = DoublyLinkedList . _Node ( data ) node = position . manipulate_node ( self , \"_validate_node\" , * []) DoublyLinkedList . _insert_between ( new_node , node . previous_node , node ) return PositionalLinkedList . _Position ( self , new_node )","title":"insert_before()"},{"location":"data_structures/positional_linked_lists/positional_doubly_linked_list/#data_structures.positional_linked_lists.positional_doubly_linked_list.PositionalDoublyLinkedList.insert_first","text":"Add item at the head of the list Parameters: Name Type Description Default data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_doubly_linked_list.py def insert_first ( self , data : Any ) -> PositionalLinkedList . _Position : DoublyLinkedList . insert_first ( self , data ) return PositionalLinkedList . _Position ( self , self . _head . next_node )","title":"insert_first()"},{"location":"data_structures/positional_linked_lists/positional_doubly_linked_list/#data_structures.positional_linked_lists.positional_doubly_linked_list.PositionalDoublyLinkedList.insert_last","text":"Add item at the tail of the list Parameters: Name Type Description Default data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_doubly_linked_list.py def insert_last ( self , data : Any ) -> PositionalLinkedList . _Position : DoublyLinkedList . insert_last ( self , data ) return PositionalLinkedList . _Position ( self , self . _tail . previous_node )","title":"insert_last()"},{"location":"data_structures/positional_linked_lists/positional_doubly_linked_list/#data_structures.positional_linked_lists.positional_doubly_linked_list.PositionalDoublyLinkedList.is_empty","text":"Return True if list is empty, else False Returns: Type Description bool True if list is empty, else False Source code in positional_linked_lists/positional_doubly_linked_list.py def is_empty ( self ) -> bool : return self . _length == 0","title":"is_empty()"},{"location":"data_structures/positional_linked_lists/positional_doubly_linked_list/#data_structures.positional_linked_lists.positional_doubly_linked_list.PositionalDoublyLinkedList.remove","text":"Delete item at a specific position Parameters: Name Type Description Default position _Position position containing item to be deleted required Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_doubly_linked_list.py def remove ( self , position : PositionalLinkedList . _Position ) -> Any : super () . remove ( position ) self . _length -= 1 node = position . manipulate_node ( self , \"_validate_node\" , * []) _ = position . manipulate_variables ( self , \"_invalidate_position\" , * []) DoublyLinkedList . _remove_between ( node . previous_node , node . next_node ) return node . data","title":"remove()"},{"location":"data_structures/positional_linked_lists/positional_doubly_linked_list/#data_structures.positional_linked_lists.positional_doubly_linked_list.PositionalDoublyLinkedList.remove_after","text":"Delete item just after the passed position Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_doubly_linked_list.py def remove_after ( self , position : PositionalLinkedList . _Position ) -> Any : super () . remove_after ( position ) node = position . manipulate_node ( self , \"_validate_node\" , * []) node_to_delete = node . next_node if isinstance ( node_to_delete , DoublyLinkedList . _SentinelNode ): return None self . _length -= 1 DoublyLinkedList . _remove_between ( node , node_to_delete . next_node ) return node_to_delete . data","title":"remove_after()"},{"location":"data_structures/positional_linked_lists/positional_doubly_linked_list/#data_structures.positional_linked_lists.positional_doubly_linked_list.PositionalDoublyLinkedList.remove_before","text":"Delete item just before the passed position Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_doubly_linked_list.py def remove_before ( self , position : PositionalLinkedList . _Position ) -> Any : super () . remove_before ( position ) node = position . manipulate_node ( self , \"_validate_node\" , * []) node_to_delete = node . previous_node if isinstance ( node_to_delete , DoublyLinkedList . _SentinelNode ): return None self . _length -= 1 DoublyLinkedList . _remove_between ( node_to_delete . previous_node , node ) return node_to_delete . data","title":"remove_before()"},{"location":"data_structures/positional_linked_lists/positional_doubly_linked_list/#data_structures.positional_linked_lists.positional_doubly_linked_list.PositionalDoublyLinkedList.remove_first","text":"Delete item at the head of the list Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_doubly_linked_list.py def remove_first ( self ) -> Any : if self . _length == 0 : return None node_to_delete = self . _head . next_node DoublyLinkedList . remove_first ( self ) return node_to_delete . data","title":"remove_first()"},{"location":"data_structures/positional_linked_lists/positional_doubly_linked_list/#data_structures.positional_linked_lists.positional_doubly_linked_list.PositionalDoublyLinkedList.remove_last","text":"Delete item at the tail of the list Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_doubly_linked_list.py def remove_last ( self ) -> Any : if self . _length == 0 : return None node_to_delete = self . _tail . previous_node DoublyLinkedList . remove_last ( self ) return node_to_delete . data","title":"remove_last()"},{"location":"data_structures/positional_linked_lists/positional_linked_list/","text":"PositionalLinkedList ( ABC ) A positional linked list is a linked list whose nodes are identifiable by their position within the list. Using the position of a node, operations such as insertion, retrieval, and deletion of elements can be performed on neighbouring nodes without the need to traverse the list from its head or tail to that specific position. A positional linked list can be implemented based on any linked list data structure, such as singly linked list, doubly linked list, etc. The operations that can be performed on the neighbouring nodes of a certain position, for a running time of O(1), are limited to the directions of traversal offered by the data structure used to implement the positional linked list. When using a linked list data structure where each node has a reference to the node succeeding it but not the one preceding it, only operations referencing the next neighbours of a specific position are achievable at constant running time. If the linked data structure contains nodes where each node contains references to both its previous and next nodes, operations referencing both the previous and next neighbours of a specific position are achievable at constant running time. append ( self , data ) Alias of insert_last Parameters: Name Type Description Default data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_linked_list.py def append ( self , data : Any ) -> _Position : \"\"\"Alias of insert_last :param data: item to insert :returns: the position of the added item \"\"\" return self . insert_last ( data ) get_after ( self , position ) Return the position just after the passed position, None if the referenced after position doesn't exist Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Optional[data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList._Position] the position just after the passed position Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def get_after ( self , position : _Position ) -> Union [ _Position , None ]: \"\"\"Return the position just after the passed position, None if the referenced after position doesn't exist :param position: reference position :returns: the position just after the passed position \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this list\" ) get_before ( self , position ) Return the position just before the passed position, None if the referenced before position doesn't exist Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Optional[data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList._Position] the position just before the passed position Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def get_before ( self , position : _Position ) -> Union [ _Position , None ]: \"\"\"Return the position just before the passed position, None if the referenced before position doesn't exist :param position: reference position :returns: the position just before the passed position \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this list\" ) get_first ( self ) Return the position of the item at the head of the list, None if the list is empty Returns: Type Description Optional[data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList._Position] the position of the item at the head of the list Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def get_first ( self ) -> Union [ _Position , None ]: \"\"\"Return the position of the item at the head of the list, None if the list is empty :returns: the position of the item at the head of the list \"\"\" pass get_last ( self ) Return the position of the item at the tail of the list, None if the list is empty Returns: Type Description Optional[data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList._Position] the position of the item at the tail of the list Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def get_last ( self ) -> Union [ _Position , None ]: \"\"\"Return the position of the item at the tail of the list, None if the list is empty :returns: the position of the item at the tail of the list \"\"\" pass insert_after ( self , position , data ) Add item after the defined position within the list Parameters: Name Type Description Default position _Position reference position required data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def insert_after ( self , position : _Position , data : Any ) -> _Position : \"\"\"Add item after the defined position within the list :param position: reference position :param data: item to insert :returns: the position of the added item \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this list\" ) insert_before ( self , position , data ) Add item before the defined position within the list Parameters: Name Type Description Default position _Position reference position required data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def insert_before ( self , position : _Position , data : Any ) -> _Position : \"\"\"Add item before the defined position within the list :param position: reference position :param data: item to insert :returns: the position of the added item \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this list\" ) insert_first ( self , data ) Add item at the head of the list Parameters: Name Type Description Default data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def insert_first ( self , data : Any ) -> _Position : \"\"\"Add item at the head of the list :param data: item to insert :returns: the position of the added item \"\"\" pass insert_last ( self , data ) Add item at the tail of the list Parameters: Name Type Description Default data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def insert_last ( self , data : Any ) -> _Position : \"\"\"Add item at the tail of the list :param data: item to insert :returns: the position of the added item \"\"\" pass is_empty ( self ) Return True if list is empty, else False Returns: Type Description bool True if list is empty, else False Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def is_empty ( self ) -> bool : \"\"\"Return True if list is empty, else False :return: True if list is empty, else False \"\"\" pass remove ( self , position ) Delete item at a specific position Parameters: Name Type Description Default position _Position position containing item to be deleted required Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def remove ( self , position : _Position ) -> Any : \"\"\"Delete item at a specific position :param position: position containing item to be deleted :returns: the deleted item \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this list\" ) remove_after ( self , position ) Delete item just after the passed position Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def remove_after ( self , position : _Position ) -> Any : \"\"\"Delete item just after the passed position :param position: reference position :returns: the deleted item \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this list\" ) remove_before ( self , position ) Delete item just before the passed position Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def remove_before ( self , position : _Position ) -> Any : \"\"\"Delete item just before the passed position :param position: reference position :returns: the deleted item \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this list\" ) remove_first ( self ) Delete item at the head of the list Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_linked_list.py def remove_first ( self ) -> Any : \"\"\"Delete item at the head of the list :returns: the deleted item \"\"\" pass remove_last ( self ) Delete item at the tail of the list Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def remove_last ( self ) -> Any : \"\"\"Delete item at the tail of the list :returns: the deleted item \"\"\" pass replace ( self , position , data ) Replace item at a specific position. Time complexity: O(1). Parameters: Name Type Description Default position _Position reference position required data Any item to replace the existing item at the reference position required Returns: Type Description Any the item replaced from the reference position Source code in positional_linked_lists/positional_linked_list.py def replace ( self , position : _Position , data : Any ) -> Any : \"\"\"Replace item at a specific position. Time complexity: O(1). :param position: reference position :param data: item to replace the existing item at the reference position :returns: the item replaced from the reference position \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this list\" ) node = position . manipulate_node ( self , \"_validate_node\" , * []) current_data = node . data node . data = data return current_data","title":"Positional Linked List ADT"},{"location":"data_structures/positional_linked_lists/positional_linked_list/#data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList","text":"A positional linked list is a linked list whose nodes are identifiable by their position within the list. Using the position of a node, operations such as insertion, retrieval, and deletion of elements can be performed on neighbouring nodes without the need to traverse the list from its head or tail to that specific position. A positional linked list can be implemented based on any linked list data structure, such as singly linked list, doubly linked list, etc. The operations that can be performed on the neighbouring nodes of a certain position, for a running time of O(1), are limited to the directions of traversal offered by the data structure used to implement the positional linked list. When using a linked list data structure where each node has a reference to the node succeeding it but not the one preceding it, only operations referencing the next neighbours of a specific position are achievable at constant running time. If the linked data structure contains nodes where each node contains references to both its previous and next nodes, operations referencing both the previous and next neighbours of a specific position are achievable at constant running time.","title":"PositionalLinkedList"},{"location":"data_structures/positional_linked_lists/positional_linked_list/#data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList.append","text":"Alias of insert_last Parameters: Name Type Description Default data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_linked_list.py def append ( self , data : Any ) -> _Position : \"\"\"Alias of insert_last :param data: item to insert :returns: the position of the added item \"\"\" return self . insert_last ( data )","title":"append()"},{"location":"data_structures/positional_linked_lists/positional_linked_list/#data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList.get_after","text":"Return the position just after the passed position, None if the referenced after position doesn't exist Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Optional[data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList._Position] the position just after the passed position Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def get_after ( self , position : _Position ) -> Union [ _Position , None ]: \"\"\"Return the position just after the passed position, None if the referenced after position doesn't exist :param position: reference position :returns: the position just after the passed position \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this list\" )","title":"get_after()"},{"location":"data_structures/positional_linked_lists/positional_linked_list/#data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList.get_before","text":"Return the position just before the passed position, None if the referenced before position doesn't exist Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Optional[data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList._Position] the position just before the passed position Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def get_before ( self , position : _Position ) -> Union [ _Position , None ]: \"\"\"Return the position just before the passed position, None if the referenced before position doesn't exist :param position: reference position :returns: the position just before the passed position \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this list\" )","title":"get_before()"},{"location":"data_structures/positional_linked_lists/positional_linked_list/#data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList.get_first","text":"Return the position of the item at the head of the list, None if the list is empty Returns: Type Description Optional[data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList._Position] the position of the item at the head of the list Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def get_first ( self ) -> Union [ _Position , None ]: \"\"\"Return the position of the item at the head of the list, None if the list is empty :returns: the position of the item at the head of the list \"\"\" pass","title":"get_first()"},{"location":"data_structures/positional_linked_lists/positional_linked_list/#data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList.get_last","text":"Return the position of the item at the tail of the list, None if the list is empty Returns: Type Description Optional[data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList._Position] the position of the item at the tail of the list Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def get_last ( self ) -> Union [ _Position , None ]: \"\"\"Return the position of the item at the tail of the list, None if the list is empty :returns: the position of the item at the tail of the list \"\"\" pass","title":"get_last()"},{"location":"data_structures/positional_linked_lists/positional_linked_list/#data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList.insert_after","text":"Add item after the defined position within the list Parameters: Name Type Description Default position _Position reference position required data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def insert_after ( self , position : _Position , data : Any ) -> _Position : \"\"\"Add item after the defined position within the list :param position: reference position :param data: item to insert :returns: the position of the added item \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this list\" )","title":"insert_after()"},{"location":"data_structures/positional_linked_lists/positional_linked_list/#data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList.insert_before","text":"Add item before the defined position within the list Parameters: Name Type Description Default position _Position reference position required data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def insert_before ( self , position : _Position , data : Any ) -> _Position : \"\"\"Add item before the defined position within the list :param position: reference position :param data: item to insert :returns: the position of the added item \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this list\" )","title":"insert_before()"},{"location":"data_structures/positional_linked_lists/positional_linked_list/#data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList.insert_first","text":"Add item at the head of the list Parameters: Name Type Description Default data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def insert_first ( self , data : Any ) -> _Position : \"\"\"Add item at the head of the list :param data: item to insert :returns: the position of the added item \"\"\" pass","title":"insert_first()"},{"location":"data_structures/positional_linked_lists/positional_linked_list/#data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList.insert_last","text":"Add item at the tail of the list Parameters: Name Type Description Default data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def insert_last ( self , data : Any ) -> _Position : \"\"\"Add item at the tail of the list :param data: item to insert :returns: the position of the added item \"\"\" pass","title":"insert_last()"},{"location":"data_structures/positional_linked_lists/positional_linked_list/#data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList.is_empty","text":"Return True if list is empty, else False Returns: Type Description bool True if list is empty, else False Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def is_empty ( self ) -> bool : \"\"\"Return True if list is empty, else False :return: True if list is empty, else False \"\"\" pass","title":"is_empty()"},{"location":"data_structures/positional_linked_lists/positional_linked_list/#data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList.remove","text":"Delete item at a specific position Parameters: Name Type Description Default position _Position position containing item to be deleted required Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def remove ( self , position : _Position ) -> Any : \"\"\"Delete item at a specific position :param position: position containing item to be deleted :returns: the deleted item \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this list\" )","title":"remove()"},{"location":"data_structures/positional_linked_lists/positional_linked_list/#data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList.remove_after","text":"Delete item just after the passed position Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def remove_after ( self , position : _Position ) -> Any : \"\"\"Delete item just after the passed position :param position: reference position :returns: the deleted item \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this list\" )","title":"remove_after()"},{"location":"data_structures/positional_linked_lists/positional_linked_list/#data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList.remove_before","text":"Delete item just before the passed position Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def remove_before ( self , position : _Position ) -> Any : \"\"\"Delete item just before the passed position :param position: reference position :returns: the deleted item \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this list\" )","title":"remove_before()"},{"location":"data_structures/positional_linked_lists/positional_linked_list/#data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList.remove_first","text":"Delete item at the head of the list Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_linked_list.py def remove_first ( self ) -> Any : \"\"\"Delete item at the head of the list :returns: the deleted item \"\"\" pass","title":"remove_first()"},{"location":"data_structures/positional_linked_lists/positional_linked_list/#data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList.remove_last","text":"Delete item at the tail of the list Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_linked_list.py @abstractmethod def remove_last ( self ) -> Any : \"\"\"Delete item at the tail of the list :returns: the deleted item \"\"\" pass","title":"remove_last()"},{"location":"data_structures/positional_linked_lists/positional_linked_list/#data_structures.positional_linked_lists.positional_linked_list.PositionalLinkedList.replace","text":"Replace item at a specific position. Time complexity: O(1). Parameters: Name Type Description Default position _Position reference position required data Any item to replace the existing item at the reference position required Returns: Type Description Any the item replaced from the reference position Source code in positional_linked_lists/positional_linked_list.py def replace ( self , position : _Position , data : Any ) -> Any : \"\"\"Replace item at a specific position. Time complexity: O(1). :param position: reference position :param data: item to replace the existing item at the reference position :returns: the item replaced from the reference position \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this list\" ) node = position . manipulate_node ( self , \"_validate_node\" , * []) current_data = node . data node . data = data return current_data","title":"replace()"},{"location":"data_structures/positional_linked_lists/positional_singly_linked_list/","text":"PositionalSinglyLinkedList ( PositionalLinkedList , SinglyLinkedList ) A positional singly linked list is a positional list implemented based on a singly linked list Instantiate a positional singly linked list object >>> a_list = PositionalSinglyLinkedList() Append an item to the list >>> position = a_list.append(0) >>> position.get_data() 0 The L.append(x) method is an alias of L.insert_last(x) >>> position = a_list.insert_last(1) >>> position.get_data() 1 Insert an item at the head of the list >>> position = a_list.insert_first(2) >>> position.get_data() 2 Insert an item just before a certain position in the list >>> new_position = a_list.insert_before(position, 3) >>> new_position.get_data() 3 Insert an item just after a certain position in the list >>> new_position = a_list.insert_after(position, 4) >>> new_position.get_data() 4 Replace item at a specific position >>> a_list.replace(position, 100) 2 Check if a positional singly linked list is empty >>> a_list.is_empty() False >>> PositionalSinglyLinkedList().is_empty() True Get first item of the list >>> position = a_list.get_first() >>> position.get_data() 3 Get last item of the list >>> position = a_list.get_last() >>> position.get_data() 1 Get item just before a certain position of the list >>> position = a_list.get_last() >>> before_position = a_list.get_before(position) >>> before_position.get_data() 0 Get item just after a certain position of the list >>> position = a_list.get_first() >>> after_position = a_list.get_after(position) >>> after_position.get_data() 100 Delete item just before a certain position from the list >>> a_list.remove_before(after_position) 3 Delete item just after a certain position from the list >>> a_list.remove_after(after_position) 4 Delete item in a certain position from the list >>> position = a_list.get_first() >>> a_list.remove(position) 100 Delete first item from the list >>> a_list.remove_first() 0 Delete last item from the list >>> a_list.remove_last() 1 get_after ( self , position ) Return the position just after the passed position, None if the referenced after position doesn't exist Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Optional[positional_linked_list.PositionalLinkedList._Position] the position just after the passed position Source code in positional_linked_lists/positional_singly_linked_list.py def get_after ( self , position : PositionalLinkedList . _Position ) -> Union [ PositionalLinkedList . _Position , None ]: super () . get_after ( position ) node = position . manipulate_node ( self , \"_validate_node\" , * []) if node is None : return None node_to_get = node . next_node if isinstance ( node_to_get , SinglyLinkedList . _SentinelNode ): return None else : return PositionalLinkedList . _Position ( self , node_to_get ) get_before ( self , position ) Return the position just before the passed position, None if the referenced before position doesn't exist Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Optional[positional_linked_list.PositionalLinkedList._Position] the position just before the passed position Source code in positional_linked_lists/positional_singly_linked_list.py def get_before ( self , position : PositionalLinkedList . _Position ) -> Union [ PositionalLinkedList . _Position , None ]: super () . get_before ( position ) node = position . manipulate_node ( self , \"_validate_node\" , * []) if node is None : return None previous_node = self . _head current_node = previous_node . next_node while current_node . data != node . data : previous_node = current_node current_node = current_node . next_node if isinstance ( previous_node , SinglyLinkedList . _SentinelNode ): return None else : return PositionalLinkedList . _Position ( self , previous_node ) get_first ( self ) Return the position of the item at the head of the list, None if the list is empty Returns: Type Description Optional[positional_linked_list.PositionalLinkedList._Position] the position of the item at the head of the list Source code in positional_linked_lists/positional_singly_linked_list.py def get_first ( self ) -> Union [ PositionalLinkedList . _Position , None ]: if self . _length == 0 : return None return PositionalLinkedList . _Position ( self , self . _head . next_node ) get_last ( self ) Return the position of the item at the tail of the list, None if the list is empty Returns: Type Description Optional[positional_linked_list.PositionalLinkedList._Position] the position of the item at the tail of the list Source code in positional_linked_lists/positional_singly_linked_list.py def get_last ( self ) -> Union [ PositionalLinkedList . _Position , None ]: if self . _length == 0 : return None current_node = self . _head . next_node while not isinstance ( current_node . next_node , SinglyLinkedList . _SentinelNode ): current_node = current_node . next_node return PositionalLinkedList . _Position ( self , current_node ) insert_after ( self , position , data ) Add item after the defined position within the list Parameters: Name Type Description Default position _Position reference position required data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_singly_linked_list.py def insert_after ( self , position : PositionalLinkedList . _Position , data : Any ) -> PositionalLinkedList . _Position : super () . insert_after ( position , data ) self . _length += 1 new_node = SinglyLinkedList . _Node ( data ) node = position . manipulate_node ( self , \"_validate_node\" , * []) SinglyLinkedList . _insert_between ( new_node , node , node . next_node ) return PositionalLinkedList . _Position ( self , new_node ) insert_before ( self , position , data ) Add item before the defined position within the list Parameters: Name Type Description Default position _Position reference position required data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_singly_linked_list.py def insert_before ( self , position : PositionalLinkedList . _Position , data : Any ) -> PositionalLinkedList . _Position : super () . insert_before ( position , data ) self . _length += 1 new_node = SinglyLinkedList . _Node ( data ) node = position . manipulate_node ( self , \"_validate_node\" , * []) previous_node = self . _head current_node = previous_node . next_node while current_node . data != node . data : previous_node = current_node current_node = current_node . next_node SinglyLinkedList . _insert_between ( new_node , previous_node , node ) return PositionalLinkedList . _Position ( self , new_node ) insert_first ( self , data ) Add item at the head of the list Parameters: Name Type Description Default data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_singly_linked_list.py def insert_first ( self , data : Any ) -> PositionalLinkedList . _Position : SinglyLinkedList . insert_first ( self , data ) return PositionalLinkedList . _Position ( self , self . _head . next_node ) insert_last ( self , data ) Add item at the tail of the list Parameters: Name Type Description Default data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_singly_linked_list.py def insert_last ( self , data : Any ) -> PositionalLinkedList . _Position : SinglyLinkedList . insert_last ( self , data ) current_node = self . _head . next_node while not isinstance ( current_node . next_node , SinglyLinkedList . _SentinelNode ): current_node = current_node . next_node return PositionalLinkedList . _Position ( self , current_node ) is_empty ( self ) Return True if list is empty, else False Returns: Type Description bool True if list is empty, else False Source code in positional_linked_lists/positional_singly_linked_list.py def is_empty ( self ) -> bool : return self . _length == 0 remove ( self , position ) Delete item at a specific position Parameters: Name Type Description Default position _Position position containing item to be deleted required Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_singly_linked_list.py def remove ( self , position : PositionalLinkedList . _Position ) -> Any : super () . remove ( position ) self . _length -= 1 node = position . manipulate_node ( self , \"_validate_node\" , * []) _ = position . manipulate_variables ( self , \"_invalidate_position\" , * []) previous_node = self . _head current_node = previous_node . next_node while current_node . data != node . data : previous_node = current_node current_node = current_node . next_node SinglyLinkedList . _remove_between ( previous_node , node . next_node ) return node . data remove_after ( self , position ) Delete item just after the passed position Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_singly_linked_list.py def remove_after ( self , position : PositionalLinkedList . _Position ) -> Any : super () . remove_after ( position ) node = position . manipulate_node ( self , \"_validate_node\" , * []) node_to_delete = node . next_node if isinstance ( node_to_delete , SinglyLinkedList . _SentinelNode ): return None self . _length -= 1 SinglyLinkedList . _remove_between ( node , node_to_delete . next_node ) return node_to_delete . data remove_before ( self , position ) Delete item just before the passed position Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_singly_linked_list.py def remove_before ( self , position : PositionalLinkedList . _Position ) -> Any : super () . remove_before ( position ) node = position . manipulate_node ( self , \"_validate_node\" , * []) pre_previous_node = None previous_node = self . _head current_node = previous_node . next_node while current_node . data != node . data : pre_previous_node = previous_node previous_node = current_node current_node = current_node . next_node if isinstance ( previous_node , SinglyLinkedList . _SentinelNode ): return None self . _length -= 1 SinglyLinkedList . _remove_between ( pre_previous_node , node ) return previous_node . data remove_first ( self ) Delete item at the head of the list Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_singly_linked_list.py def remove_first ( self ) -> Any : if self . _length == 0 : return None node_to_delete = self . _head . next_node SinglyLinkedList . remove_first ( self ) return node_to_delete . data remove_last ( self ) Delete item at the tail of the list Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_singly_linked_list.py def remove_last ( self ) -> Any : if self . _length == 0 : return None node_to_delete = self . _head . next_node while not isinstance ( node_to_delete . next_node , SinglyLinkedList . _SentinelNode ): node_to_delete = node_to_delete . next_node SinglyLinkedList . remove_last ( self ) return node_to_delete . data","title":"Positional Singly Linked List"},{"location":"data_structures/positional_linked_lists/positional_singly_linked_list/#data_structures.positional_linked_lists.positional_singly_linked_list.PositionalSinglyLinkedList","text":"A positional singly linked list is a positional list implemented based on a singly linked list Instantiate a positional singly linked list object >>> a_list = PositionalSinglyLinkedList() Append an item to the list >>> position = a_list.append(0) >>> position.get_data() 0 The L.append(x) method is an alias of L.insert_last(x) >>> position = a_list.insert_last(1) >>> position.get_data() 1 Insert an item at the head of the list >>> position = a_list.insert_first(2) >>> position.get_data() 2 Insert an item just before a certain position in the list >>> new_position = a_list.insert_before(position, 3) >>> new_position.get_data() 3 Insert an item just after a certain position in the list >>> new_position = a_list.insert_after(position, 4) >>> new_position.get_data() 4 Replace item at a specific position >>> a_list.replace(position, 100) 2 Check if a positional singly linked list is empty >>> a_list.is_empty() False >>> PositionalSinglyLinkedList().is_empty() True Get first item of the list >>> position = a_list.get_first() >>> position.get_data() 3 Get last item of the list >>> position = a_list.get_last() >>> position.get_data() 1 Get item just before a certain position of the list >>> position = a_list.get_last() >>> before_position = a_list.get_before(position) >>> before_position.get_data() 0 Get item just after a certain position of the list >>> position = a_list.get_first() >>> after_position = a_list.get_after(position) >>> after_position.get_data() 100 Delete item just before a certain position from the list >>> a_list.remove_before(after_position) 3 Delete item just after a certain position from the list >>> a_list.remove_after(after_position) 4 Delete item in a certain position from the list >>> position = a_list.get_first() >>> a_list.remove(position) 100 Delete first item from the list >>> a_list.remove_first() 0 Delete last item from the list >>> a_list.remove_last() 1","title":"PositionalSinglyLinkedList"},{"location":"data_structures/positional_linked_lists/positional_singly_linked_list/#data_structures.positional_linked_lists.positional_singly_linked_list.PositionalSinglyLinkedList.get_after","text":"Return the position just after the passed position, None if the referenced after position doesn't exist Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Optional[positional_linked_list.PositionalLinkedList._Position] the position just after the passed position Source code in positional_linked_lists/positional_singly_linked_list.py def get_after ( self , position : PositionalLinkedList . _Position ) -> Union [ PositionalLinkedList . _Position , None ]: super () . get_after ( position ) node = position . manipulate_node ( self , \"_validate_node\" , * []) if node is None : return None node_to_get = node . next_node if isinstance ( node_to_get , SinglyLinkedList . _SentinelNode ): return None else : return PositionalLinkedList . _Position ( self , node_to_get )","title":"get_after()"},{"location":"data_structures/positional_linked_lists/positional_singly_linked_list/#data_structures.positional_linked_lists.positional_singly_linked_list.PositionalSinglyLinkedList.get_before","text":"Return the position just before the passed position, None if the referenced before position doesn't exist Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Optional[positional_linked_list.PositionalLinkedList._Position] the position just before the passed position Source code in positional_linked_lists/positional_singly_linked_list.py def get_before ( self , position : PositionalLinkedList . _Position ) -> Union [ PositionalLinkedList . _Position , None ]: super () . get_before ( position ) node = position . manipulate_node ( self , \"_validate_node\" , * []) if node is None : return None previous_node = self . _head current_node = previous_node . next_node while current_node . data != node . data : previous_node = current_node current_node = current_node . next_node if isinstance ( previous_node , SinglyLinkedList . _SentinelNode ): return None else : return PositionalLinkedList . _Position ( self , previous_node )","title":"get_before()"},{"location":"data_structures/positional_linked_lists/positional_singly_linked_list/#data_structures.positional_linked_lists.positional_singly_linked_list.PositionalSinglyLinkedList.get_first","text":"Return the position of the item at the head of the list, None if the list is empty Returns: Type Description Optional[positional_linked_list.PositionalLinkedList._Position] the position of the item at the head of the list Source code in positional_linked_lists/positional_singly_linked_list.py def get_first ( self ) -> Union [ PositionalLinkedList . _Position , None ]: if self . _length == 0 : return None return PositionalLinkedList . _Position ( self , self . _head . next_node )","title":"get_first()"},{"location":"data_structures/positional_linked_lists/positional_singly_linked_list/#data_structures.positional_linked_lists.positional_singly_linked_list.PositionalSinglyLinkedList.get_last","text":"Return the position of the item at the tail of the list, None if the list is empty Returns: Type Description Optional[positional_linked_list.PositionalLinkedList._Position] the position of the item at the tail of the list Source code in positional_linked_lists/positional_singly_linked_list.py def get_last ( self ) -> Union [ PositionalLinkedList . _Position , None ]: if self . _length == 0 : return None current_node = self . _head . next_node while not isinstance ( current_node . next_node , SinglyLinkedList . _SentinelNode ): current_node = current_node . next_node return PositionalLinkedList . _Position ( self , current_node )","title":"get_last()"},{"location":"data_structures/positional_linked_lists/positional_singly_linked_list/#data_structures.positional_linked_lists.positional_singly_linked_list.PositionalSinglyLinkedList.insert_after","text":"Add item after the defined position within the list Parameters: Name Type Description Default position _Position reference position required data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_singly_linked_list.py def insert_after ( self , position : PositionalLinkedList . _Position , data : Any ) -> PositionalLinkedList . _Position : super () . insert_after ( position , data ) self . _length += 1 new_node = SinglyLinkedList . _Node ( data ) node = position . manipulate_node ( self , \"_validate_node\" , * []) SinglyLinkedList . _insert_between ( new_node , node , node . next_node ) return PositionalLinkedList . _Position ( self , new_node )","title":"insert_after()"},{"location":"data_structures/positional_linked_lists/positional_singly_linked_list/#data_structures.positional_linked_lists.positional_singly_linked_list.PositionalSinglyLinkedList.insert_before","text":"Add item before the defined position within the list Parameters: Name Type Description Default position _Position reference position required data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_singly_linked_list.py def insert_before ( self , position : PositionalLinkedList . _Position , data : Any ) -> PositionalLinkedList . _Position : super () . insert_before ( position , data ) self . _length += 1 new_node = SinglyLinkedList . _Node ( data ) node = position . manipulate_node ( self , \"_validate_node\" , * []) previous_node = self . _head current_node = previous_node . next_node while current_node . data != node . data : previous_node = current_node current_node = current_node . next_node SinglyLinkedList . _insert_between ( new_node , previous_node , node ) return PositionalLinkedList . _Position ( self , new_node )","title":"insert_before()"},{"location":"data_structures/positional_linked_lists/positional_singly_linked_list/#data_structures.positional_linked_lists.positional_singly_linked_list.PositionalSinglyLinkedList.insert_first","text":"Add item at the head of the list Parameters: Name Type Description Default data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_singly_linked_list.py def insert_first ( self , data : Any ) -> PositionalLinkedList . _Position : SinglyLinkedList . insert_first ( self , data ) return PositionalLinkedList . _Position ( self , self . _head . next_node )","title":"insert_first()"},{"location":"data_structures/positional_linked_lists/positional_singly_linked_list/#data_structures.positional_linked_lists.positional_singly_linked_list.PositionalSinglyLinkedList.insert_last","text":"Add item at the tail of the list Parameters: Name Type Description Default data Any item to insert required Returns: Type Description _Position the position of the added item Source code in positional_linked_lists/positional_singly_linked_list.py def insert_last ( self , data : Any ) -> PositionalLinkedList . _Position : SinglyLinkedList . insert_last ( self , data ) current_node = self . _head . next_node while not isinstance ( current_node . next_node , SinglyLinkedList . _SentinelNode ): current_node = current_node . next_node return PositionalLinkedList . _Position ( self , current_node )","title":"insert_last()"},{"location":"data_structures/positional_linked_lists/positional_singly_linked_list/#data_structures.positional_linked_lists.positional_singly_linked_list.PositionalSinglyLinkedList.is_empty","text":"Return True if list is empty, else False Returns: Type Description bool True if list is empty, else False Source code in positional_linked_lists/positional_singly_linked_list.py def is_empty ( self ) -> bool : return self . _length == 0","title":"is_empty()"},{"location":"data_structures/positional_linked_lists/positional_singly_linked_list/#data_structures.positional_linked_lists.positional_singly_linked_list.PositionalSinglyLinkedList.remove","text":"Delete item at a specific position Parameters: Name Type Description Default position _Position position containing item to be deleted required Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_singly_linked_list.py def remove ( self , position : PositionalLinkedList . _Position ) -> Any : super () . remove ( position ) self . _length -= 1 node = position . manipulate_node ( self , \"_validate_node\" , * []) _ = position . manipulate_variables ( self , \"_invalidate_position\" , * []) previous_node = self . _head current_node = previous_node . next_node while current_node . data != node . data : previous_node = current_node current_node = current_node . next_node SinglyLinkedList . _remove_between ( previous_node , node . next_node ) return node . data","title":"remove()"},{"location":"data_structures/positional_linked_lists/positional_singly_linked_list/#data_structures.positional_linked_lists.positional_singly_linked_list.PositionalSinglyLinkedList.remove_after","text":"Delete item just after the passed position Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_singly_linked_list.py def remove_after ( self , position : PositionalLinkedList . _Position ) -> Any : super () . remove_after ( position ) node = position . manipulate_node ( self , \"_validate_node\" , * []) node_to_delete = node . next_node if isinstance ( node_to_delete , SinglyLinkedList . _SentinelNode ): return None self . _length -= 1 SinglyLinkedList . _remove_between ( node , node_to_delete . next_node ) return node_to_delete . data","title":"remove_after()"},{"location":"data_structures/positional_linked_lists/positional_singly_linked_list/#data_structures.positional_linked_lists.positional_singly_linked_list.PositionalSinglyLinkedList.remove_before","text":"Delete item just before the passed position Parameters: Name Type Description Default position _Position reference position required Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_singly_linked_list.py def remove_before ( self , position : PositionalLinkedList . _Position ) -> Any : super () . remove_before ( position ) node = position . manipulate_node ( self , \"_validate_node\" , * []) pre_previous_node = None previous_node = self . _head current_node = previous_node . next_node while current_node . data != node . data : pre_previous_node = previous_node previous_node = current_node current_node = current_node . next_node if isinstance ( previous_node , SinglyLinkedList . _SentinelNode ): return None self . _length -= 1 SinglyLinkedList . _remove_between ( pre_previous_node , node ) return previous_node . data","title":"remove_before()"},{"location":"data_structures/positional_linked_lists/positional_singly_linked_list/#data_structures.positional_linked_lists.positional_singly_linked_list.PositionalSinglyLinkedList.remove_first","text":"Delete item at the head of the list Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_singly_linked_list.py def remove_first ( self ) -> Any : if self . _length == 0 : return None node_to_delete = self . _head . next_node SinglyLinkedList . remove_first ( self ) return node_to_delete . data","title":"remove_first()"},{"location":"data_structures/positional_linked_lists/positional_singly_linked_list/#data_structures.positional_linked_lists.positional_singly_linked_list.PositionalSinglyLinkedList.remove_last","text":"Delete item at the tail of the list Returns: Type Description Any the deleted item Source code in positional_linked_lists/positional_singly_linked_list.py def remove_last ( self ) -> Any : if self . _length == 0 : return None node_to_delete = self . _head . next_node while not isinstance ( node_to_delete . next_node , SinglyLinkedList . _SentinelNode ): node_to_delete = node_to_delete . next_node SinglyLinkedList . remove_last ( self ) return node_to_delete . data","title":"remove_last()"},{"location":"data_structures/priority_queues/priority_queue/","text":"PriorityQueue ( ABC ) A priority queue is a queue ADT that supports insertion (enqueueing) of elements at one end and removal (dequeueing) of elements from the opposite end, with the extra attribute of priority of each element it contains, meaning an element can move closer to the front of the queue if the elements in front of it are of less precedence than itself. __len__ ( self ) special Get the total number of elements stored in the queue Returns: Type Description int count of elements in queue Source code in priority_queues/priority_queue.py @abstractmethod def __len__ ( self ) -> int : \"\"\"Get the total number of elements stored in the queue :returns: count of elements in queue \"\"\" pass dequeue ( self ) Remove first element of the queue and return it Returns: Type Description Any first element of queue Source code in priority_queues/priority_queue.py @abstractmethod def dequeue ( self ) -> Any : \"\"\"Remove first element of the queue and return it :return: first element of queue \"\"\" pass enqueue ( self , x , priority ) Insert an element to the end of the queue Parameters: Name Type Description Default x Any element to add to the queue required priority Union[int, float] value that determines precedence of x in relation to the rest of the elements in the queue required Source code in priority_queues/priority_queue.py @abstractmethod def enqueue ( self , x : Any , priority : Union [ int , float ]) -> None : \"\"\"Insert an element to the end of the queue :param x: element to add to the queue :param priority: value that determines precedence of x in relation to the rest of the elements in the queue \"\"\" pass get_first ( self ) Return first element of the queue without removing it Returns: Type Description Any first element of queue Source code in priority_queues/priority_queue.py @abstractmethod def get_first ( self ) -> Any : \"\"\"Return first element of the queue without removing it :return: first element of queue \"\"\" pass is_empty ( self ) Check if queue contains no elements Returns: Type Description bool True if queue is empty, else False Source code in priority_queues/priority_queue.py @abstractmethod def is_empty ( self ) -> bool : \"\"\"Check if queue contains no elements :return: True if queue is empty, else False \"\"\" pass","title":"Priority Queue ADT"},{"location":"data_structures/priority_queues/priority_queue/#data_structures.priority_queues.priority_queue.PriorityQueue","text":"A priority queue is a queue ADT that supports insertion (enqueueing) of elements at one end and removal (dequeueing) of elements from the opposite end, with the extra attribute of priority of each element it contains, meaning an element can move closer to the front of the queue if the elements in front of it are of less precedence than itself.","title":"PriorityQueue"},{"location":"data_structures/priority_queues/priority_queue/#data_structures.priority_queues.priority_queue.PriorityQueue.__len__","text":"Get the total number of elements stored in the queue Returns: Type Description int count of elements in queue Source code in priority_queues/priority_queue.py @abstractmethod def __len__ ( self ) -> int : \"\"\"Get the total number of elements stored in the queue :returns: count of elements in queue \"\"\" pass","title":"__len__()"},{"location":"data_structures/priority_queues/priority_queue/#data_structures.priority_queues.priority_queue.PriorityQueue.dequeue","text":"Remove first element of the queue and return it Returns: Type Description Any first element of queue Source code in priority_queues/priority_queue.py @abstractmethod def dequeue ( self ) -> Any : \"\"\"Remove first element of the queue and return it :return: first element of queue \"\"\" pass","title":"dequeue()"},{"location":"data_structures/priority_queues/priority_queue/#data_structures.priority_queues.priority_queue.PriorityQueue.enqueue","text":"Insert an element to the end of the queue Parameters: Name Type Description Default x Any element to add to the queue required priority Union[int, float] value that determines precedence of x in relation to the rest of the elements in the queue required Source code in priority_queues/priority_queue.py @abstractmethod def enqueue ( self , x : Any , priority : Union [ int , float ]) -> None : \"\"\"Insert an element to the end of the queue :param x: element to add to the queue :param priority: value that determines precedence of x in relation to the rest of the elements in the queue \"\"\" pass","title":"enqueue()"},{"location":"data_structures/priority_queues/priority_queue/#data_structures.priority_queues.priority_queue.PriorityQueue.get_first","text":"Return first element of the queue without removing it Returns: Type Description Any first element of queue Source code in priority_queues/priority_queue.py @abstractmethod def get_first ( self ) -> Any : \"\"\"Return first element of the queue without removing it :return: first element of queue \"\"\" pass","title":"get_first()"},{"location":"data_structures/priority_queues/priority_queue/#data_structures.priority_queues.priority_queue.PriorityQueue.is_empty","text":"Check if queue contains no elements Returns: Type Description bool True if queue is empty, else False Source code in priority_queues/priority_queue.py @abstractmethod def is_empty ( self ) -> bool : \"\"\"Check if queue contains no elements :return: True if queue is empty, else False \"\"\" pass","title":"is_empty()"},{"location":"data_structures/priority_queues/sorted_list_priority_queue/","text":"SortedListPriorityQueue ( PriorityQueue ) A sorted list priority queue is a priority queue implemented using python's list data structure that contains sorted items __len__ ( self ) special Get the total number of elements stored in the queue >>> a_queue = SortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> len(a_queue) 1 Returns: Type Description int count of elements in queue Source code in priority_queues/sorted_list_priority_queue.py def __len__ ( self ) -> int : \"\"\"Get the total number of elements stored in the queue >>> a_queue = SortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> len(a_queue) 1 :returns: count of elements in queue \"\"\" return len ( self . __data_store ) dequeue ( self ) Remove first element of the queue and return it >>> a_queue = SortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> a_queue.dequeue() (1, 2) Returns: Type Description Any first element of queue Source code in priority_queues/sorted_list_priority_queue.py def dequeue ( self ) -> Any : \"\"\"Remove first element of the queue and return it >>> a_queue = SortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> a_queue.dequeue() (1, 2) :return: first element of queue \"\"\" if self . is_empty (): raise Empty ( \"Queue is empty\" ) return self . __data_store . pop ( 0 ), self . __priority_store . pop ( 0 ) enqueue ( self , x , priority ) Insert an element to the end of the queue >>> a_queue = SortedListPriorityQueue() >>> a_queue.enqueue(1, 2) Parameters: Name Type Description Default x Any element to add to the queue required priority Union[int, float] value that determines precedence of x in relation to the rest of the elements in the queue required Source code in priority_queues/sorted_list_priority_queue.py def enqueue ( self , x : Any , priority : Union [ int , float ]) -> None : \"\"\"Insert an element to the end of the queue >>> a_queue = SortedListPriorityQueue() >>> a_queue.enqueue(1, 2) :param x: element to add to the queue :param priority: value that determines precedence of x in relation to the rest of the elements in the queue \"\"\" current_idx = - 1 if self . _minimum_priority_queue : for i , p in enumerate ( self . __priority_store ): if priority < p : current_idx = i break else : for i , p in enumerate ( self . __priority_store ): if priority > p : current_idx = i break if current_idx == - 1 : self . __priority_store . append ( priority ) self . __data_store . append ( x ) else : self . __priority_store . insert ( current_idx , priority ) self . __data_store . insert ( current_idx , x ) get_first ( self ) Return first element of the queue without removing it >>> a_queue = SortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> a_queue.get_first() (1, 2) Returns: Type Description Any first element of queue Source code in priority_queues/sorted_list_priority_queue.py def get_first ( self ) -> Any : \"\"\"Return first element of the queue without removing it >>> a_queue = SortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> a_queue.get_first() (1, 2) :return: first element of queue \"\"\" if self . is_empty (): raise Empty ( \"Queue is empty\" ) return self . __data_store [ 0 ], self . __priority_store [ 0 ] is_empty ( self ) Check if queue contains no elements >>> a_queue = SortedListPriorityQueue() >>> a_queue.is_empty() True >>> a_queue.enqueue(1, 2) >>> a_queue.is_empty() False Returns: Type Description bool True if queue is empty, else False Source code in priority_queues/sorted_list_priority_queue.py def is_empty ( self ) -> bool : \"\"\"Check if queue contains no elements >>> a_queue = SortedListPriorityQueue() >>> a_queue.is_empty() True >>> a_queue.enqueue(1, 2) >>> a_queue.is_empty() False :return: True if queue is empty, else False \"\"\" return len ( self . __data_store ) == 0","title":"Sorted List Priority Queue"},{"location":"data_structures/priority_queues/sorted_list_priority_queue/#data_structures.priority_queues.sorted_list_priority_queue.SortedListPriorityQueue","text":"A sorted list priority queue is a priority queue implemented using python's list data structure that contains sorted items","title":"SortedListPriorityQueue"},{"location":"data_structures/priority_queues/sorted_list_priority_queue/#data_structures.priority_queues.sorted_list_priority_queue.SortedListPriorityQueue.__len__","text":"Get the total number of elements stored in the queue >>> a_queue = SortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> len(a_queue) 1 Returns: Type Description int count of elements in queue Source code in priority_queues/sorted_list_priority_queue.py def __len__ ( self ) -> int : \"\"\"Get the total number of elements stored in the queue >>> a_queue = SortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> len(a_queue) 1 :returns: count of elements in queue \"\"\" return len ( self . __data_store )","title":"__len__()"},{"location":"data_structures/priority_queues/sorted_list_priority_queue/#data_structures.priority_queues.sorted_list_priority_queue.SortedListPriorityQueue.dequeue","text":"Remove first element of the queue and return it >>> a_queue = SortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> a_queue.dequeue() (1, 2) Returns: Type Description Any first element of queue Source code in priority_queues/sorted_list_priority_queue.py def dequeue ( self ) -> Any : \"\"\"Remove first element of the queue and return it >>> a_queue = SortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> a_queue.dequeue() (1, 2) :return: first element of queue \"\"\" if self . is_empty (): raise Empty ( \"Queue is empty\" ) return self . __data_store . pop ( 0 ), self . __priority_store . pop ( 0 )","title":"dequeue()"},{"location":"data_structures/priority_queues/sorted_list_priority_queue/#data_structures.priority_queues.sorted_list_priority_queue.SortedListPriorityQueue.enqueue","text":"Insert an element to the end of the queue >>> a_queue = SortedListPriorityQueue() >>> a_queue.enqueue(1, 2) Parameters: Name Type Description Default x Any element to add to the queue required priority Union[int, float] value that determines precedence of x in relation to the rest of the elements in the queue required Source code in priority_queues/sorted_list_priority_queue.py def enqueue ( self , x : Any , priority : Union [ int , float ]) -> None : \"\"\"Insert an element to the end of the queue >>> a_queue = SortedListPriorityQueue() >>> a_queue.enqueue(1, 2) :param x: element to add to the queue :param priority: value that determines precedence of x in relation to the rest of the elements in the queue \"\"\" current_idx = - 1 if self . _minimum_priority_queue : for i , p in enumerate ( self . __priority_store ): if priority < p : current_idx = i break else : for i , p in enumerate ( self . __priority_store ): if priority > p : current_idx = i break if current_idx == - 1 : self . __priority_store . append ( priority ) self . __data_store . append ( x ) else : self . __priority_store . insert ( current_idx , priority ) self . __data_store . insert ( current_idx , x )","title":"enqueue()"},{"location":"data_structures/priority_queues/sorted_list_priority_queue/#data_structures.priority_queues.sorted_list_priority_queue.SortedListPriorityQueue.get_first","text":"Return first element of the queue without removing it >>> a_queue = SortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> a_queue.get_first() (1, 2) Returns: Type Description Any first element of queue Source code in priority_queues/sorted_list_priority_queue.py def get_first ( self ) -> Any : \"\"\"Return first element of the queue without removing it >>> a_queue = SortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> a_queue.get_first() (1, 2) :return: first element of queue \"\"\" if self . is_empty (): raise Empty ( \"Queue is empty\" ) return self . __data_store [ 0 ], self . __priority_store [ 0 ]","title":"get_first()"},{"location":"data_structures/priority_queues/sorted_list_priority_queue/#data_structures.priority_queues.sorted_list_priority_queue.SortedListPriorityQueue.is_empty","text":"Check if queue contains no elements >>> a_queue = SortedListPriorityQueue() >>> a_queue.is_empty() True >>> a_queue.enqueue(1, 2) >>> a_queue.is_empty() False Returns: Type Description bool True if queue is empty, else False Source code in priority_queues/sorted_list_priority_queue.py def is_empty ( self ) -> bool : \"\"\"Check if queue contains no elements >>> a_queue = SortedListPriorityQueue() >>> a_queue.is_empty() True >>> a_queue.enqueue(1, 2) >>> a_queue.is_empty() False :return: True if queue is empty, else False \"\"\" return len ( self . __data_store ) == 0","title":"is_empty()"},{"location":"data_structures/priority_queues/unsorted_list_priority_queue/","text":"UnsortedListPriorityQueue ( PriorityQueue ) An unsorted list priority queue is a priority queue implemented using python's list data structure that contains unsorted items __len__ ( self ) special Get the total number of elements stored in the queue >>> a_queue = UnsortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> len(a_queue) 1 Returns: Type Description int count of elements in queue Source code in priority_queues/unsorted_list_priority_queue.py def __len__ ( self ) -> int : \"\"\"Get the total number of elements stored in the queue >>> a_queue = UnsortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> len(a_queue) 1 :returns: count of elements in queue \"\"\" return len ( self . __data_store ) dequeue ( self ) Remove first element of the queue and return it >>> a_queue = UnsortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> a_queue.dequeue() (1, 2) Returns: Type Description Any first element of queue Source code in priority_queues/unsorted_list_priority_queue.py def dequeue ( self ) -> Any : \"\"\"Remove first element of the queue and return it >>> a_queue = UnsortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> a_queue.dequeue() (1, 2) :return: first element of queue \"\"\" if self . is_empty (): raise Empty ( \"Queue is empty\" ) current_idx = 0 current_priority = self . __priority_store [ 0 ] if self . _minimum_priority_queue : for i , priority in enumerate ( self . __priority_store ): if priority < current_priority : current_idx = i current_priority = priority else : for i , priority in enumerate ( self . __priority_store ): if priority > current_priority : current_idx = i current_priority = priority return self . __data_store . pop ( current_idx ), self . __priority_store . pop ( current_idx ) enqueue ( self , x , priority ) Insert an element to the end of the queue >>> a_queue = UnsortedListPriorityQueue() >>> a_queue.enqueue(1, 2) Parameters: Name Type Description Default x Any element to add to the queue required priority Union[int, float] value that determines precedence of x in relation to the rest of the elements in the queue required Source code in priority_queues/unsorted_list_priority_queue.py def enqueue ( self , x : Any , priority : Union [ int , float ]) -> None : \"\"\"Insert an element to the end of the queue >>> a_queue = UnsortedListPriorityQueue() >>> a_queue.enqueue(1, 2) :param x: element to add to the queue :param priority: value that determines precedence of x in relation to the rest of the elements in the queue \"\"\" self . __data_store . append ( x ) self . __priority_store . append ( priority ) get_first ( self ) Return first element of the queue without removing it >>> a_queue = UnsortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> a_queue.get_first() (1, 2) Returns: Type Description Any first element of queue Source code in priority_queues/unsorted_list_priority_queue.py def get_first ( self ) -> Any : \"\"\"Return first element of the queue without removing it >>> a_queue = UnsortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> a_queue.get_first() (1, 2) :return: first element of queue \"\"\" if self . is_empty (): raise Empty ( \"Queue is empty\" ) current_priority = self . __priority_store [ 0 ] current_element_value = self . __data_store [ 0 ] if self . _minimum_priority_queue : for i , priority in enumerate ( self . __priority_store ): if priority < current_priority : current_priority = priority current_element_value = self . __data_store [ i ] else : for i , priority in enumerate ( self . __priority_store ): if priority > current_priority : current_priority = priority current_element_value = self . __data_store [ i ] return current_element_value , current_priority is_empty ( self ) Check if queue contains no elements >>> a_queue = UnsortedListPriorityQueue() >>> a_queue.is_empty() True >>> a_queue.enqueue(1, 2) >>> a_queue.is_empty() False Returns: Type Description bool True if queue is empty, else False Source code in priority_queues/unsorted_list_priority_queue.py def is_empty ( self ) -> bool : \"\"\"Check if queue contains no elements >>> a_queue = UnsortedListPriorityQueue() >>> a_queue.is_empty() True >>> a_queue.enqueue(1, 2) >>> a_queue.is_empty() False :return: True if queue is empty, else False \"\"\" return len ( self . __data_store ) == 0","title":"Unsorted List Priority Queue"},{"location":"data_structures/priority_queues/unsorted_list_priority_queue/#data_structures.priority_queues.unsorted_list_priority_queue.UnsortedListPriorityQueue","text":"An unsorted list priority queue is a priority queue implemented using python's list data structure that contains unsorted items","title":"UnsortedListPriorityQueue"},{"location":"data_structures/priority_queues/unsorted_list_priority_queue/#data_structures.priority_queues.unsorted_list_priority_queue.UnsortedListPriorityQueue.__len__","text":"Get the total number of elements stored in the queue >>> a_queue = UnsortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> len(a_queue) 1 Returns: Type Description int count of elements in queue Source code in priority_queues/unsorted_list_priority_queue.py def __len__ ( self ) -> int : \"\"\"Get the total number of elements stored in the queue >>> a_queue = UnsortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> len(a_queue) 1 :returns: count of elements in queue \"\"\" return len ( self . __data_store )","title":"__len__()"},{"location":"data_structures/priority_queues/unsorted_list_priority_queue/#data_structures.priority_queues.unsorted_list_priority_queue.UnsortedListPriorityQueue.dequeue","text":"Remove first element of the queue and return it >>> a_queue = UnsortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> a_queue.dequeue() (1, 2) Returns: Type Description Any first element of queue Source code in priority_queues/unsorted_list_priority_queue.py def dequeue ( self ) -> Any : \"\"\"Remove first element of the queue and return it >>> a_queue = UnsortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> a_queue.dequeue() (1, 2) :return: first element of queue \"\"\" if self . is_empty (): raise Empty ( \"Queue is empty\" ) current_idx = 0 current_priority = self . __priority_store [ 0 ] if self . _minimum_priority_queue : for i , priority in enumerate ( self . __priority_store ): if priority < current_priority : current_idx = i current_priority = priority else : for i , priority in enumerate ( self . __priority_store ): if priority > current_priority : current_idx = i current_priority = priority return self . __data_store . pop ( current_idx ), self . __priority_store . pop ( current_idx )","title":"dequeue()"},{"location":"data_structures/priority_queues/unsorted_list_priority_queue/#data_structures.priority_queues.unsorted_list_priority_queue.UnsortedListPriorityQueue.enqueue","text":"Insert an element to the end of the queue >>> a_queue = UnsortedListPriorityQueue() >>> a_queue.enqueue(1, 2) Parameters: Name Type Description Default x Any element to add to the queue required priority Union[int, float] value that determines precedence of x in relation to the rest of the elements in the queue required Source code in priority_queues/unsorted_list_priority_queue.py def enqueue ( self , x : Any , priority : Union [ int , float ]) -> None : \"\"\"Insert an element to the end of the queue >>> a_queue = UnsortedListPriorityQueue() >>> a_queue.enqueue(1, 2) :param x: element to add to the queue :param priority: value that determines precedence of x in relation to the rest of the elements in the queue \"\"\" self . __data_store . append ( x ) self . __priority_store . append ( priority )","title":"enqueue()"},{"location":"data_structures/priority_queues/unsorted_list_priority_queue/#data_structures.priority_queues.unsorted_list_priority_queue.UnsortedListPriorityQueue.get_first","text":"Return first element of the queue without removing it >>> a_queue = UnsortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> a_queue.get_first() (1, 2) Returns: Type Description Any first element of queue Source code in priority_queues/unsorted_list_priority_queue.py def get_first ( self ) -> Any : \"\"\"Return first element of the queue without removing it >>> a_queue = UnsortedListPriorityQueue() >>> a_queue.enqueue(1, 2) >>> a_queue.get_first() (1, 2) :return: first element of queue \"\"\" if self . is_empty (): raise Empty ( \"Queue is empty\" ) current_priority = self . __priority_store [ 0 ] current_element_value = self . __data_store [ 0 ] if self . _minimum_priority_queue : for i , priority in enumerate ( self . __priority_store ): if priority < current_priority : current_priority = priority current_element_value = self . __data_store [ i ] else : for i , priority in enumerate ( self . __priority_store ): if priority > current_priority : current_priority = priority current_element_value = self . __data_store [ i ] return current_element_value , current_priority","title":"get_first()"},{"location":"data_structures/priority_queues/unsorted_list_priority_queue/#data_structures.priority_queues.unsorted_list_priority_queue.UnsortedListPriorityQueue.is_empty","text":"Check if queue contains no elements >>> a_queue = UnsortedListPriorityQueue() >>> a_queue.is_empty() True >>> a_queue.enqueue(1, 2) >>> a_queue.is_empty() False Returns: Type Description bool True if queue is empty, else False Source code in priority_queues/unsorted_list_priority_queue.py def is_empty ( self ) -> bool : \"\"\"Check if queue contains no elements >>> a_queue = UnsortedListPriorityQueue() >>> a_queue.is_empty() True >>> a_queue.enqueue(1, 2) >>> a_queue.is_empty() False :return: True if queue is empty, else False \"\"\" return len ( self . __data_store ) == 0","title":"is_empty()"},{"location":"data_structures/queues/list_queue/","text":"ListQueue ( Queue ) A queue implemented using python's list data structure __len__ ( self ) special Get the total number of elements stored in the queue >>> a_queue = ListQueue() >>> a_queue.enqueue(1) >>> len(a_queue) 1 Returns: Type Description int count of elements in queue Source code in queues/list_queue.py def __len__ ( self ) -> int : \"\"\"Get the total number of elements stored in the queue >>> a_queue = ListQueue() >>> a_queue.enqueue(1) >>> len(a_queue) 1 :returns: count of elements in queue \"\"\" return len ( self . __data_store ) dequeue ( self ) Remove first element of the queue and return it >>> a_queue = ListQueue() >>> a_queue.enqueue(1) >>> a_queue.dequeue() 1 Returns: Type Description Any first element of queue Source code in queues/list_queue.py def dequeue ( self ) -> Any : \"\"\"Remove first element of the queue and return it >>> a_queue = ListQueue() >>> a_queue.enqueue(1) >>> a_queue.dequeue() 1 :return: first element of queue \"\"\" if self . is_empty (): raise Empty ( \"Queue is empty\" ) return self . __data_store . pop ( 0 ) enqueue ( self , x ) Insert an element to the end of the queue >>> a_queue = ListQueue() >>> a_queue.enqueue(1) Parameters: Name Type Description Default x Any element to add to the queue required Source code in queues/list_queue.py def enqueue ( self , x : Any ) -> None : \"\"\"Insert an element to the end of the queue >>> a_queue = ListQueue() >>> a_queue.enqueue(1) :param x: element to add to the queue \"\"\" self . __data_store . append ( x ) get_first ( self ) Return first element of the queue without removing it >>> a_queue = ListQueue() >>> a_queue.enqueue(1) >>> a_queue.get_first() 1 Returns: Type Description Any first element of queue Source code in queues/list_queue.py def get_first ( self ) -> Any : \"\"\"Return first element of the queue without removing it >>> a_queue = ListQueue() >>> a_queue.enqueue(1) >>> a_queue.get_first() 1 :return: first element of queue \"\"\" if self . is_empty (): raise Empty ( \"Queue is empty\" ) return self . __data_store [ 0 ] is_empty ( self ) Check if queue contains no elements >>> a_queue = ListQueue() >>> a_queue.is_empty() True >>> a_queue.enqueue(1) >>> a_queue.is_empty() False Returns: Type Description bool True if queue is empty, else False Source code in queues/list_queue.py def is_empty ( self ) -> bool : \"\"\"Check if queue contains no elements >>> a_queue = ListQueue() >>> a_queue.is_empty() True >>> a_queue.enqueue(1) >>> a_queue.is_empty() False :return: True if queue is empty, else False \"\"\" return len ( self . __data_store ) == 0","title":"List Queue"},{"location":"data_structures/queues/list_queue/#data_structures.queues.list_queue.ListQueue","text":"A queue implemented using python's list data structure","title":"ListQueue"},{"location":"data_structures/queues/list_queue/#data_structures.queues.list_queue.ListQueue.__len__","text":"Get the total number of elements stored in the queue >>> a_queue = ListQueue() >>> a_queue.enqueue(1) >>> len(a_queue) 1 Returns: Type Description int count of elements in queue Source code in queues/list_queue.py def __len__ ( self ) -> int : \"\"\"Get the total number of elements stored in the queue >>> a_queue = ListQueue() >>> a_queue.enqueue(1) >>> len(a_queue) 1 :returns: count of elements in queue \"\"\" return len ( self . __data_store )","title":"__len__()"},{"location":"data_structures/queues/list_queue/#data_structures.queues.list_queue.ListQueue.dequeue","text":"Remove first element of the queue and return it >>> a_queue = ListQueue() >>> a_queue.enqueue(1) >>> a_queue.dequeue() 1 Returns: Type Description Any first element of queue Source code in queues/list_queue.py def dequeue ( self ) -> Any : \"\"\"Remove first element of the queue and return it >>> a_queue = ListQueue() >>> a_queue.enqueue(1) >>> a_queue.dequeue() 1 :return: first element of queue \"\"\" if self . is_empty (): raise Empty ( \"Queue is empty\" ) return self . __data_store . pop ( 0 )","title":"dequeue()"},{"location":"data_structures/queues/list_queue/#data_structures.queues.list_queue.ListQueue.enqueue","text":"Insert an element to the end of the queue >>> a_queue = ListQueue() >>> a_queue.enqueue(1) Parameters: Name Type Description Default x Any element to add to the queue required Source code in queues/list_queue.py def enqueue ( self , x : Any ) -> None : \"\"\"Insert an element to the end of the queue >>> a_queue = ListQueue() >>> a_queue.enqueue(1) :param x: element to add to the queue \"\"\" self . __data_store . append ( x )","title":"enqueue()"},{"location":"data_structures/queues/list_queue/#data_structures.queues.list_queue.ListQueue.get_first","text":"Return first element of the queue without removing it >>> a_queue = ListQueue() >>> a_queue.enqueue(1) >>> a_queue.get_first() 1 Returns: Type Description Any first element of queue Source code in queues/list_queue.py def get_first ( self ) -> Any : \"\"\"Return first element of the queue without removing it >>> a_queue = ListQueue() >>> a_queue.enqueue(1) >>> a_queue.get_first() 1 :return: first element of queue \"\"\" if self . is_empty (): raise Empty ( \"Queue is empty\" ) return self . __data_store [ 0 ]","title":"get_first()"},{"location":"data_structures/queues/list_queue/#data_structures.queues.list_queue.ListQueue.is_empty","text":"Check if queue contains no elements >>> a_queue = ListQueue() >>> a_queue.is_empty() True >>> a_queue.enqueue(1) >>> a_queue.is_empty() False Returns: Type Description bool True if queue is empty, else False Source code in queues/list_queue.py def is_empty ( self ) -> bool : \"\"\"Check if queue contains no elements >>> a_queue = ListQueue() >>> a_queue.is_empty() True >>> a_queue.enqueue(1) >>> a_queue.is_empty() False :return: True if queue is empty, else False \"\"\" return len ( self . __data_store ) == 0","title":"is_empty()"},{"location":"data_structures/queues/queue/","text":"Queue ( ABC ) A queue is a First-In-First-Out ADT that supports insertion (enqueueing) of elements at one end and removal (dequeueing) of elements from the opposite end. The order in which elements are enqueued is maintained when dequeueing them. __len__ ( self ) special Get the total number of elements stored in the queue Returns: Type Description int count of elements in queue Source code in queues/queue_custom.py @abstractmethod def __len__ ( self ) -> int : \"\"\"Get the total number of elements stored in the queue :returns: count of elements in queue \"\"\" pass dequeue ( self ) Remove first element of the queue and return it Returns: Type Description Any first element of queue Source code in queues/queue_custom.py @abstractmethod def dequeue ( self ) -> Any : \"\"\"Remove first element of the queue and return it :return: first element of queue \"\"\" pass enqueue ( self , x ) Insert an element to the end of the queue Parameters: Name Type Description Default x Any element to add to the queue required Source code in queues/queue_custom.py @abstractmethod def enqueue ( self , x : Any ) -> None : \"\"\"Insert an element to the end of the queue :param x: element to add to the queue \"\"\" pass get_first ( self ) Return first element of the queue without removing it Returns: Type Description Any first element of queue Source code in queues/queue_custom.py @abstractmethod def get_first ( self ) -> Any : \"\"\"Return first element of the queue without removing it :return: first element of queue \"\"\" pass is_empty ( self ) Check if queue contains no elements Returns: Type Description bool True if queue is empty, else False Source code in queues/queue_custom.py @abstractmethod def is_empty ( self ) -> bool : \"\"\"Check if queue contains no elements :return: True if queue is empty, else False \"\"\" pass","title":"Queue ADT"},{"location":"data_structures/queues/queue/#data_structures.queues.queue_custom.Queue","text":"A queue is a First-In-First-Out ADT that supports insertion (enqueueing) of elements at one end and removal (dequeueing) of elements from the opposite end. The order in which elements are enqueued is maintained when dequeueing them.","title":"Queue"},{"location":"data_structures/queues/queue/#data_structures.queues.queue_custom.Queue.__len__","text":"Get the total number of elements stored in the queue Returns: Type Description int count of elements in queue Source code in queues/queue_custom.py @abstractmethod def __len__ ( self ) -> int : \"\"\"Get the total number of elements stored in the queue :returns: count of elements in queue \"\"\" pass","title":"__len__()"},{"location":"data_structures/queues/queue/#data_structures.queues.queue_custom.Queue.dequeue","text":"Remove first element of the queue and return it Returns: Type Description Any first element of queue Source code in queues/queue_custom.py @abstractmethod def dequeue ( self ) -> Any : \"\"\"Remove first element of the queue and return it :return: first element of queue \"\"\" pass","title":"dequeue()"},{"location":"data_structures/queues/queue/#data_structures.queues.queue_custom.Queue.enqueue","text":"Insert an element to the end of the queue Parameters: Name Type Description Default x Any element to add to the queue required Source code in queues/queue_custom.py @abstractmethod def enqueue ( self , x : Any ) -> None : \"\"\"Insert an element to the end of the queue :param x: element to add to the queue \"\"\" pass","title":"enqueue()"},{"location":"data_structures/queues/queue/#data_structures.queues.queue_custom.Queue.get_first","text":"Return first element of the queue without removing it Returns: Type Description Any first element of queue Source code in queues/queue_custom.py @abstractmethod def get_first ( self ) -> Any : \"\"\"Return first element of the queue without removing it :return: first element of queue \"\"\" pass","title":"get_first()"},{"location":"data_structures/queues/queue/#data_structures.queues.queue_custom.Queue.is_empty","text":"Check if queue contains no elements Returns: Type Description bool True if queue is empty, else False Source code in queues/queue_custom.py @abstractmethod def is_empty ( self ) -> bool : \"\"\"Check if queue contains no elements :return: True if queue is empty, else False \"\"\" pass","title":"is_empty()"},{"location":"data_structures/stacks/list_stack/","text":"ListStack ( Stack ) A stack implemented using python's list data structure __len__ ( self ) special Get the total number of elements stored in the stack >>> a_stack = ListStack() >>> a_stack.push(1) >>> len(a_stack) 1 Returns: Type Description int count of elements in stack Source code in stacks/list_stack.py def __len__ ( self ) -> int : \"\"\"Get the total number of elements stored in the stack >>> a_stack = ListStack() >>> a_stack.push(1) >>> len(a_stack) 1 :returns: count of elements in stack \"\"\" return len ( self . __data_store ) is_empty ( self ) Check if stack contains no elements >>> a_stack = ListStack() >>> a_stack.is_empty() True >>> a_stack.push(1) >>> a_stack.is_empty() False Returns: Type Description bool True if stack is empty, else False Source code in stacks/list_stack.py def is_empty ( self ) -> bool : \"\"\"Check if stack contains no elements >>> a_stack = ListStack() >>> a_stack.is_empty() True >>> a_stack.push(1) >>> a_stack.is_empty() False :return: True if stack is empty, else False \"\"\" return len ( self . __data_store ) == 0 peek ( self ) Get element at the top of the stack without removing it >>> a_stack = ListStack() >>> a_stack.push(1) >>> a_stack.peek() 1 Returns: Type Description Any element at top of stack Source code in stacks/list_stack.py def peek ( self ) -> Any : \"\"\"Get element at the top of the stack without removing it >>> a_stack = ListStack() >>> a_stack.push(1) >>> a_stack.peek() 1 :return: element at top of stack \"\"\" if self . is_empty (): raise Empty ( \"Stack is empty\" ) return self . __data_store [ - 1 ] pop ( self ) Get element at the top of the stack, and remove it from the stack >>> a_stack = ListStack() >>> a_stack.push(1) >>> a_stack.pop() 1 Returns: Type Description Any element at top of stack Source code in stacks/list_stack.py def pop ( self ) -> Any : \"\"\"Get element at the top of the stack, and remove it from the stack >>> a_stack = ListStack() >>> a_stack.push(1) >>> a_stack.pop() 1 :return: element at top of stack \"\"\" if self . is_empty (): raise Empty ( \"Stack is empty\" ) return self . __data_store . pop () push ( self , x ) Insert element x to the top of the stack >>> a_stack = ListStack() >>> a_stack.push(1) Parameters: Name Type Description Default x Any element to add to the stack required Source code in stacks/list_stack.py def push ( self , x : Any ): \"\"\"Insert element x to the top of the stack >>> a_stack = ListStack() >>> a_stack.push(1) :param x: element to add to the stack \"\"\" self . __data_store . append ( x )","title":"List Stack"},{"location":"data_structures/stacks/list_stack/#data_structures.stacks.list_stack.ListStack","text":"A stack implemented using python's list data structure","title":"ListStack"},{"location":"data_structures/stacks/list_stack/#data_structures.stacks.list_stack.ListStack.__len__","text":"Get the total number of elements stored in the stack >>> a_stack = ListStack() >>> a_stack.push(1) >>> len(a_stack) 1 Returns: Type Description int count of elements in stack Source code in stacks/list_stack.py def __len__ ( self ) -> int : \"\"\"Get the total number of elements stored in the stack >>> a_stack = ListStack() >>> a_stack.push(1) >>> len(a_stack) 1 :returns: count of elements in stack \"\"\" return len ( self . __data_store )","title":"__len__()"},{"location":"data_structures/stacks/list_stack/#data_structures.stacks.list_stack.ListStack.is_empty","text":"Check if stack contains no elements >>> a_stack = ListStack() >>> a_stack.is_empty() True >>> a_stack.push(1) >>> a_stack.is_empty() False Returns: Type Description bool True if stack is empty, else False Source code in stacks/list_stack.py def is_empty ( self ) -> bool : \"\"\"Check if stack contains no elements >>> a_stack = ListStack() >>> a_stack.is_empty() True >>> a_stack.push(1) >>> a_stack.is_empty() False :return: True if stack is empty, else False \"\"\" return len ( self . __data_store ) == 0","title":"is_empty()"},{"location":"data_structures/stacks/list_stack/#data_structures.stacks.list_stack.ListStack.peek","text":"Get element at the top of the stack without removing it >>> a_stack = ListStack() >>> a_stack.push(1) >>> a_stack.peek() 1 Returns: Type Description Any element at top of stack Source code in stacks/list_stack.py def peek ( self ) -> Any : \"\"\"Get element at the top of the stack without removing it >>> a_stack = ListStack() >>> a_stack.push(1) >>> a_stack.peek() 1 :return: element at top of stack \"\"\" if self . is_empty (): raise Empty ( \"Stack is empty\" ) return self . __data_store [ - 1 ]","title":"peek()"},{"location":"data_structures/stacks/list_stack/#data_structures.stacks.list_stack.ListStack.pop","text":"Get element at the top of the stack, and remove it from the stack >>> a_stack = ListStack() >>> a_stack.push(1) >>> a_stack.pop() 1 Returns: Type Description Any element at top of stack Source code in stacks/list_stack.py def pop ( self ) -> Any : \"\"\"Get element at the top of the stack, and remove it from the stack >>> a_stack = ListStack() >>> a_stack.push(1) >>> a_stack.pop() 1 :return: element at top of stack \"\"\" if self . is_empty (): raise Empty ( \"Stack is empty\" ) return self . __data_store . pop ()","title":"pop()"},{"location":"data_structures/stacks/list_stack/#data_structures.stacks.list_stack.ListStack.push","text":"Insert element x to the top of the stack >>> a_stack = ListStack() >>> a_stack.push(1) Parameters: Name Type Description Default x Any element to add to the stack required Source code in stacks/list_stack.py def push ( self , x : Any ): \"\"\"Insert element x to the top of the stack >>> a_stack = ListStack() >>> a_stack.push(1) :param x: element to add to the stack \"\"\" self . __data_store . append ( x )","title":"push()"},{"location":"data_structures/stacks/stack/","text":"Stack ( ABC ) A stack is a Last-In-First-Out ADT that supports insertion (pushing) and removal (popping) of elements from the same end. The order in which elements are pushed into the stack is reversed when popping out elements from the stack. __len__ ( self ) special Get the total number of elements stored in the stack Returns: Type Description int count of elements in stack Source code in stacks/stack.py @abstractmethod def __len__ ( self ) -> int : \"\"\"Get the total number of elements stored in the stack :returns: count of elements in stack \"\"\" pass is_empty ( self ) Check if stack contains no elements Returns: Type Description bool True if stack is empty, else False Source code in stacks/stack.py @abstractmethod def is_empty ( self ) -> bool : \"\"\"Check if stack contains no elements :return: True if stack is empty, else False \"\"\" pass peek ( self ) Get element at the top of the stack without removing it Returns: Type Description Any element at top of stack Source code in stacks/stack.py @abstractmethod def peek ( self ) -> Any : \"\"\"Get element at the top of the stack without removing it :return: element at top of stack \"\"\" pass pop ( self ) Get element at the top of the stack, and remove it from the stack Returns: Type Description Any element at top of stack Source code in stacks/stack.py @abstractmethod def pop ( self ) -> Any : \"\"\"Get element at the top of the stack, and remove it from the stack :return: element at top of stack \"\"\" pass push ( self , x ) Insert element x to the top of the stack Parameters: Name Type Description Default x Any element to add to the stack required Source code in stacks/stack.py @abstractmethod def push ( self , x : Any ) -> None : \"\"\"Insert element x to the top of the stack :param x: element to add to the stack \"\"\" pass","title":"Stack ADT"},{"location":"data_structures/stacks/stack/#data_structures.stacks.stack.Stack","text":"A stack is a Last-In-First-Out ADT that supports insertion (pushing) and removal (popping) of elements from the same end. The order in which elements are pushed into the stack is reversed when popping out elements from the stack.","title":"Stack"},{"location":"data_structures/stacks/stack/#data_structures.stacks.stack.Stack.__len__","text":"Get the total number of elements stored in the stack Returns: Type Description int count of elements in stack Source code in stacks/stack.py @abstractmethod def __len__ ( self ) -> int : \"\"\"Get the total number of elements stored in the stack :returns: count of elements in stack \"\"\" pass","title":"__len__()"},{"location":"data_structures/stacks/stack/#data_structures.stacks.stack.Stack.is_empty","text":"Check if stack contains no elements Returns: Type Description bool True if stack is empty, else False Source code in stacks/stack.py @abstractmethod def is_empty ( self ) -> bool : \"\"\"Check if stack contains no elements :return: True if stack is empty, else False \"\"\" pass","title":"is_empty()"},{"location":"data_structures/stacks/stack/#data_structures.stacks.stack.Stack.peek","text":"Get element at the top of the stack without removing it Returns: Type Description Any element at top of stack Source code in stacks/stack.py @abstractmethod def peek ( self ) -> Any : \"\"\"Get element at the top of the stack without removing it :return: element at top of stack \"\"\" pass","title":"peek()"},{"location":"data_structures/stacks/stack/#data_structures.stacks.stack.Stack.pop","text":"Get element at the top of the stack, and remove it from the stack Returns: Type Description Any element at top of stack Source code in stacks/stack.py @abstractmethod def pop ( self ) -> Any : \"\"\"Get element at the top of the stack, and remove it from the stack :return: element at top of stack \"\"\" pass","title":"pop()"},{"location":"data_structures/stacks/stack/#data_structures.stacks.stack.Stack.push","text":"Insert element x to the top of the stack Parameters: Name Type Description Default x Any element to add to the stack required Source code in stacks/stack.py @abstractmethod def push ( self , x : Any ) -> None : \"\"\"Insert element x to the top of the stack :param x: element to add to the stack \"\"\" pass","title":"push()"},{"location":"data_structures/trees/avl_tree/","text":"AVLTree ( BinarySearchTree ) An AVL tree is a binary search tree that is balanced. Whenever an item is inserted or deleted, the tree rebalances itself. This ensures an a worst case search time of O(logn). Instantiate an AVL tree object >>> tree = AVLTree() Insert an item to the tree >>> tree.insert(5, 500) >>> tree.insert(4, 400) >>> tree.insert(6, 600) >>> tree.insert(10, 10000) Check if a tree is empty >>> tree.is_empty() False >>> AVLTree().is_empty() True Get root position >>> root = tree.get_root() Get item corresponding to a certain position >>> root.get_data() (5, 500) Check if a position is owned by some tree >>> root.is_owned_by(tree) True >>> root.is_owned_by(AVLTree()) False Get children of some position >>> children = tree.get_children(root) >>> [i.get_data() for i in children] [(4, 400), (6, 600)] Get left child of some position >>> left_child = tree.get_left_child(root) >>> left_child.get_data() (4, 400) Get right child of some position >>> right_child = tree.get_right_child(root) >>> right_child.get_data() (6, 600) Delete item from the tree >>> position_to_delete = tree.get_right_child(right_child) >>> tree.delete(position_to_delete) Check if a position contains the root >>> tree.is_root(root) True >>> tree.is_root(left_child) False Check if a position contains a leaf node >>> tree.is_leaf(left_child) True >>> tree.is_leaf(root) False Get parent of some position >>> tree.get_parent(left_child).get_data() (5, 500) >>> tree.get_parent(root) is None True Get siblings of some position >>> siblings = tree.get_siblings(left_child) >>> [i.get_data() for i in siblings] [(6, 600)] Get height of some position >>> tree.get_height_of_node(left_child) 0 >>> tree.get_height_of_node(root) 1 Get height of tree >>> tree.get_height_of_tree() 1 Get depth of some position >>> tree.get_depth_of_node(left_child) 1 >>> tree.get_depth_of_node(root) 0 Get depth of tree >>> tree.get_depth_of_tree() 1 Get level of some position >>> tree.get_level_of_node(left_child) 2 >>> tree.get_level_of_node(root) 1 Get length of tree >>> len(tree) 3 >>> len(AVLTree()) 0 Get string reresentation of tree >>> tree 5(4, 6) >>> str(tree) '5(4, 6)' Get tree iterable >>> tree_iterable = iter(tree) >>> next(tree_iterable).get_data() (5, 500) Get next item of tree iterator >>> next(tree).get_data() (4, 400) delete ( self , position ) Delete a value from the tree Parameters: Name Type Description Default position _Position position containing the node to be removed from the tree required Source code in trees/avl_tree.py def delete ( self , position : Tree . _Position ): super () . delete ( position ) self . __balance_tree () insert ( self , key , value ) Insert a value into the tree Parameters: Name Type Description Default key unique identifier of the item to be added to the tree required value item to be added to the tree required Source code in trees/avl_tree.py def insert ( self , key , value ): super () . insert ( key , value ) self . __balance_tree ()","title":"AVL Tree"},{"location":"data_structures/trees/avl_tree/#data_structures.trees.avl_tree.AVLTree","text":"An AVL tree is a binary search tree that is balanced. Whenever an item is inserted or deleted, the tree rebalances itself. This ensures an a worst case search time of O(logn). Instantiate an AVL tree object >>> tree = AVLTree() Insert an item to the tree >>> tree.insert(5, 500) >>> tree.insert(4, 400) >>> tree.insert(6, 600) >>> tree.insert(10, 10000) Check if a tree is empty >>> tree.is_empty() False >>> AVLTree().is_empty() True Get root position >>> root = tree.get_root() Get item corresponding to a certain position >>> root.get_data() (5, 500) Check if a position is owned by some tree >>> root.is_owned_by(tree) True >>> root.is_owned_by(AVLTree()) False Get children of some position >>> children = tree.get_children(root) >>> [i.get_data() for i in children] [(4, 400), (6, 600)] Get left child of some position >>> left_child = tree.get_left_child(root) >>> left_child.get_data() (4, 400) Get right child of some position >>> right_child = tree.get_right_child(root) >>> right_child.get_data() (6, 600) Delete item from the tree >>> position_to_delete = tree.get_right_child(right_child) >>> tree.delete(position_to_delete) Check if a position contains the root >>> tree.is_root(root) True >>> tree.is_root(left_child) False Check if a position contains a leaf node >>> tree.is_leaf(left_child) True >>> tree.is_leaf(root) False Get parent of some position >>> tree.get_parent(left_child).get_data() (5, 500) >>> tree.get_parent(root) is None True Get siblings of some position >>> siblings = tree.get_siblings(left_child) >>> [i.get_data() for i in siblings] [(6, 600)] Get height of some position >>> tree.get_height_of_node(left_child) 0 >>> tree.get_height_of_node(root) 1 Get height of tree >>> tree.get_height_of_tree() 1 Get depth of some position >>> tree.get_depth_of_node(left_child) 1 >>> tree.get_depth_of_node(root) 0 Get depth of tree >>> tree.get_depth_of_tree() 1 Get level of some position >>> tree.get_level_of_node(left_child) 2 >>> tree.get_level_of_node(root) 1 Get length of tree >>> len(tree) 3 >>> len(AVLTree()) 0 Get string reresentation of tree >>> tree 5(4, 6) >>> str(tree) '5(4, 6)' Get tree iterable >>> tree_iterable = iter(tree) >>> next(tree_iterable).get_data() (5, 500) Get next item of tree iterator >>> next(tree).get_data() (4, 400)","title":"AVLTree"},{"location":"data_structures/trees/avl_tree/#data_structures.trees.avl_tree.AVLTree.delete","text":"Delete a value from the tree Parameters: Name Type Description Default position _Position position containing the node to be removed from the tree required Source code in trees/avl_tree.py def delete ( self , position : Tree . _Position ): super () . delete ( position ) self . __balance_tree ()","title":"delete()"},{"location":"data_structures/trees/avl_tree/#data_structures.trees.avl_tree.AVLTree.insert","text":"Insert a value into the tree Parameters: Name Type Description Default key unique identifier of the item to be added to the tree required value item to be added to the tree required Source code in trees/avl_tree.py def insert ( self , key , value ): super () . insert ( key , value ) self . __balance_tree ()","title":"insert()"},{"location":"data_structures/trees/binary_expression_tree/","text":"BinaryExpressionTree ( BinaryTree ) A binary expression tree is a binary tree used to parse mathematical expressions. Operators are contained within the internal nodes of the tree, whereas the operands occupy the leaves. By using such a parse tree, complex mathematical expressions with numerous operators and operands can be easily evaluated, as the expression is divided into smaller parts made up of only two operands and a single operator. Instantiate a binary expression tree object >>> tree = BinaryExpressionTree() Evaluate expressions, when tree parsing is based on infix notation >>> tree.evaluate(\"(2+2-23)\", BinaryExpressionTree.Notation.Infix) -19.0 >>> tree.evaluate(\"((434+42-2)*(43+4-2))\", BinaryExpressionTree.Notation.Infix) 21330.0 Evaluate expressions, when tree parsing is based on prefix notation >>> tree.evaluate(\"(2+2-23)\", BinaryExpressionTree.Notation.Prefix) -19.0 >>> tree.evaluate(\"((434+42-2)*(43+4-2))\", BinaryExpressionTree.Notation.Prefix) 21330.0 Evaluate expressions, when tree parsing is based on postfix notation >>> tree.evaluate(\"(2+2-23)\", BinaryExpressionTree.Notation.Postfix) -19.0 >>> tree.evaluate(\"((434+42-2)*(43+4-2))\", BinaryExpressionTree.Notation.Postfix) 21330.0 Notation ( Enum ) An enumeration. evaluate ( self , expression , notation =< Notation . Infix : 1 > ) Return the solution to a mathematical expression Parameters: Name Type Description Default expression str the expression to be solved required notation Notation the notation to use when building the parse tree <Notation.Infix: 1> Returns: Type Description float the solution to the passed expression Source code in trees/binary_expression_tree.py def evaluate ( self , expression : str , notation : Notation = Notation . Infix ) -> float : \"\"\"Return the solution to a mathematical expression :param expression: the expression to be solved :param notation: the notation to use when building the parse tree :returns: the solution to the passed expression \"\"\" def evaluate_helper ( node : BinaryTree . _Node ): try : if node . children == [ None , None ]: return float ( node . key ) except AttributeError : raise SyntaxError left_result = evaluate_helper ( node . children [ 0 ]) right_result = evaluate_helper ( node . children [ 1 ]) operator = node . key if operator == \"+\" : return left_result + right_result elif operator == \"-\" : return left_result - right_result elif operator == \"*\" : return left_result * right_result elif operator == \"/\" : return left_result / right_result else : raise ValueError ( f \"' { operator } ' is not a valid operator\" ) self . __refresh () self . __parse ( expression , notation ) if self . is_empty (): return 0.0 else : return evaluate_helper ( self . _root ) insert ( self , data , _ = None ) Insert a value into the tree. Operators and operands inserted need to follow the infix notation when using this method. Parameters: Name Type Description Default data str item to be added to the tree required _ this parameter is not used, and is thus ignored None Source code in trees/binary_expression_tree.py def insert ( self , data : str , _ = None ) -> None : \"\"\"Insert a value into the tree. Operators and operands inserted need to follow the infix notation when using this method. :param data: item to be added to the tree :param _: this parameter is not used, and is thus ignored \"\"\" self . __insert_infix ( data )","title":"Binary Expression Tree"},{"location":"data_structures/trees/binary_expression_tree/#data_structures.trees.binary_expression_tree.BinaryExpressionTree","text":"A binary expression tree is a binary tree used to parse mathematical expressions. Operators are contained within the internal nodes of the tree, whereas the operands occupy the leaves. By using such a parse tree, complex mathematical expressions with numerous operators and operands can be easily evaluated, as the expression is divided into smaller parts made up of only two operands and a single operator. Instantiate a binary expression tree object >>> tree = BinaryExpressionTree() Evaluate expressions, when tree parsing is based on infix notation >>> tree.evaluate(\"(2+2-23)\", BinaryExpressionTree.Notation.Infix) -19.0 >>> tree.evaluate(\"((434+42-2)*(43+4-2))\", BinaryExpressionTree.Notation.Infix) 21330.0 Evaluate expressions, when tree parsing is based on prefix notation >>> tree.evaluate(\"(2+2-23)\", BinaryExpressionTree.Notation.Prefix) -19.0 >>> tree.evaluate(\"((434+42-2)*(43+4-2))\", BinaryExpressionTree.Notation.Prefix) 21330.0 Evaluate expressions, when tree parsing is based on postfix notation >>> tree.evaluate(\"(2+2-23)\", BinaryExpressionTree.Notation.Postfix) -19.0 >>> tree.evaluate(\"((434+42-2)*(43+4-2))\", BinaryExpressionTree.Notation.Postfix) 21330.0","title":"BinaryExpressionTree"},{"location":"data_structures/trees/binary_expression_tree/#data_structures.trees.binary_expression_tree.BinaryExpressionTree.Notation","text":"An enumeration.","title":"Notation"},{"location":"data_structures/trees/binary_expression_tree/#data_structures.trees.binary_expression_tree.BinaryExpressionTree.evaluate","text":"Return the solution to a mathematical expression Parameters: Name Type Description Default expression str the expression to be solved required notation Notation the notation to use when building the parse tree <Notation.Infix: 1> Returns: Type Description float the solution to the passed expression Source code in trees/binary_expression_tree.py def evaluate ( self , expression : str , notation : Notation = Notation . Infix ) -> float : \"\"\"Return the solution to a mathematical expression :param expression: the expression to be solved :param notation: the notation to use when building the parse tree :returns: the solution to the passed expression \"\"\" def evaluate_helper ( node : BinaryTree . _Node ): try : if node . children == [ None , None ]: return float ( node . key ) except AttributeError : raise SyntaxError left_result = evaluate_helper ( node . children [ 0 ]) right_result = evaluate_helper ( node . children [ 1 ]) operator = node . key if operator == \"+\" : return left_result + right_result elif operator == \"-\" : return left_result - right_result elif operator == \"*\" : return left_result * right_result elif operator == \"/\" : return left_result / right_result else : raise ValueError ( f \"' { operator } ' is not a valid operator\" ) self . __refresh () self . __parse ( expression , notation ) if self . is_empty (): return 0.0 else : return evaluate_helper ( self . _root )","title":"evaluate()"},{"location":"data_structures/trees/binary_expression_tree/#data_structures.trees.binary_expression_tree.BinaryExpressionTree.insert","text":"Insert a value into the tree. Operators and operands inserted need to follow the infix notation when using this method. Parameters: Name Type Description Default data str item to be added to the tree required _ this parameter is not used, and is thus ignored None Source code in trees/binary_expression_tree.py def insert ( self , data : str , _ = None ) -> None : \"\"\"Insert a value into the tree. Operators and operands inserted need to follow the infix notation when using this method. :param data: item to be added to the tree :param _: this parameter is not used, and is thus ignored \"\"\" self . __insert_infix ( data )","title":"insert()"},{"location":"data_structures/trees/binary_search_tree/","text":"BinarySearchTree ( BinaryTree ) A binary search tree is a binary tree whose left child of each node contain an item less in value than itself, and the right child an item higher in value than itself. An in-order traversal of the binary search tree results to items arranged in ascending order. Instantiate a binary search tree object >>> tree = BinarySearchTree() Insert an item to the tree >>> tree.insert(5, 500) >>> tree.insert(4, 400) >>> tree.insert(6, 600) >>> tree.insert(10, 1000) Check if a tree is empty >>> tree.is_empty() False >>> BinarySearchTree().is_empty() True Get root position >>> root = tree.get_root() Get item corresponding to a certain position >>> root.get_data() (5, 500) Check if a position is owned by some tree >>> root.is_owned_by(tree) True >>> root.is_owned_by(BinarySearchTree()) False Get children of some position >>> children = tree.get_children(root) >>> [i.get_data() for i in children] [(4, 400), (6, 600)] Get left child of some position >>> left_child = tree.get_left_child(root) >>> left_child.get_data() (4, 400) Get right child of some position >>> right_child = tree.get_right_child(root) >>> right_child.get_data() (6, 600) Delete an item from the tree >>> position_to_delete = tree.get_right_child(right_child) >>> tree.delete(position_to_delete) Check if a position contains the root >>> tree.is_root(root) True >>> tree.is_root(left_child) False Check if a position contains a leaf node >>> tree.is_leaf(left_child) True >>> tree.is_leaf(root) False Get parent of some position >>> tree.get_parent(left_child).get_data() (5, 500) >>> tree.get_parent(root) is None True Get siblings of some position >>> siblings = tree.get_siblings(left_child) >>> [i.get_data() for i in siblings] [(6, 600)] Get height of some position >>> tree.get_height_of_node(left_child) 0 >>> tree.get_height_of_node(root) 1 Get height of tree >>> tree.get_height_of_tree() 1 Get depth of some position >>> tree.get_depth_of_node(left_child) 1 >>> tree.get_depth_of_node(root) 0 Get depth of tree >>> tree.get_depth_of_tree() 1 Get level of some position >>> tree.get_level_of_node(left_child) 2 >>> tree.get_level_of_node(root) 1 Get length of tree >>> len(tree) 3 >>> len(BinarySearchTree()) 0 Get string reresentation of tree >>> tree 5(4, 6) >>> str(tree) '5(4, 6)' Get tree iterable >>> tree_iterable = iter(tree) >>> next(tree_iterable).get_data() (5, 500) Get next item of tree iterator >>> next(tree).get_data() (4, 400) insert ( self , key , value ) Insert a value into the tree Parameters: Name Type Description Default key unique identifier of the item to be added to the tree required value item to be added to the tree required Source code in trees/binary_search_tree.py def insert ( self , key , value ): super () . insert ( key , value ) node = Tree . _Node ( key , value , children = [ None , None ]) if self . is_empty (): self . _root = node else : current_node = self . _root previous_node = current_node . parent while current_node is not None : previous_node = current_node left_child = current_node . children [ 0 ] right_child = current_node . children [ 1 ] if key == current_node . key : raise ValueError ( \"Key already exists in tree\" ) elif key > current_node . key : current_node = right_child else : current_node = left_child node . parent = previous_node if key > previous_node . key : previous_node . children [ 1 ] = node else : previous_node . children [ 0 ] = node search ( self , key ) Return the position of a key within the tree, or None if the value doesn't exist in the tree. Time complexity: O(n). Parameters: Name Type Description Default key the key to search required Returns: Type Description Optional[tree.Tree._Position] the position of the item if it exists in the tree, else None Source code in trees/binary_search_tree.py def search ( self , key ) -> Union [ BinaryTree . _Position , None ]: \"\"\"Return the position of a key within the tree, or None if the value doesn't exist in the tree. Time complexity: O(n). :param key: the key to search :returns: the position of the item if it exists in the tree, else None \"\"\" if self . is_empty (): raise Empty ( \"Tree is empty\" ) current_node = self . _root while current_node is not None : left_child = current_node . children [ 0 ] right_child = current_node . children [ 1 ] if key == current_node . key : break elif key > current_node . key : current_node = right_child else : current_node = left_child if current_node is None : return None else : return Tree . _Position ( self , current_node )","title":"Binary Search Tree"},{"location":"data_structures/trees/binary_search_tree/#data_structures.trees.binary_search_tree.BinarySearchTree","text":"A binary search tree is a binary tree whose left child of each node contain an item less in value than itself, and the right child an item higher in value than itself. An in-order traversal of the binary search tree results to items arranged in ascending order. Instantiate a binary search tree object >>> tree = BinarySearchTree() Insert an item to the tree >>> tree.insert(5, 500) >>> tree.insert(4, 400) >>> tree.insert(6, 600) >>> tree.insert(10, 1000) Check if a tree is empty >>> tree.is_empty() False >>> BinarySearchTree().is_empty() True Get root position >>> root = tree.get_root() Get item corresponding to a certain position >>> root.get_data() (5, 500) Check if a position is owned by some tree >>> root.is_owned_by(tree) True >>> root.is_owned_by(BinarySearchTree()) False Get children of some position >>> children = tree.get_children(root) >>> [i.get_data() for i in children] [(4, 400), (6, 600)] Get left child of some position >>> left_child = tree.get_left_child(root) >>> left_child.get_data() (4, 400) Get right child of some position >>> right_child = tree.get_right_child(root) >>> right_child.get_data() (6, 600) Delete an item from the tree >>> position_to_delete = tree.get_right_child(right_child) >>> tree.delete(position_to_delete) Check if a position contains the root >>> tree.is_root(root) True >>> tree.is_root(left_child) False Check if a position contains a leaf node >>> tree.is_leaf(left_child) True >>> tree.is_leaf(root) False Get parent of some position >>> tree.get_parent(left_child).get_data() (5, 500) >>> tree.get_parent(root) is None True Get siblings of some position >>> siblings = tree.get_siblings(left_child) >>> [i.get_data() for i in siblings] [(6, 600)] Get height of some position >>> tree.get_height_of_node(left_child) 0 >>> tree.get_height_of_node(root) 1 Get height of tree >>> tree.get_height_of_tree() 1 Get depth of some position >>> tree.get_depth_of_node(left_child) 1 >>> tree.get_depth_of_node(root) 0 Get depth of tree >>> tree.get_depth_of_tree() 1 Get level of some position >>> tree.get_level_of_node(left_child) 2 >>> tree.get_level_of_node(root) 1 Get length of tree >>> len(tree) 3 >>> len(BinarySearchTree()) 0 Get string reresentation of tree >>> tree 5(4, 6) >>> str(tree) '5(4, 6)' Get tree iterable >>> tree_iterable = iter(tree) >>> next(tree_iterable).get_data() (5, 500) Get next item of tree iterator >>> next(tree).get_data() (4, 400)","title":"BinarySearchTree"},{"location":"data_structures/trees/binary_search_tree/#data_structures.trees.binary_search_tree.BinarySearchTree.insert","text":"Insert a value into the tree Parameters: Name Type Description Default key unique identifier of the item to be added to the tree required value item to be added to the tree required Source code in trees/binary_search_tree.py def insert ( self , key , value ): super () . insert ( key , value ) node = Tree . _Node ( key , value , children = [ None , None ]) if self . is_empty (): self . _root = node else : current_node = self . _root previous_node = current_node . parent while current_node is not None : previous_node = current_node left_child = current_node . children [ 0 ] right_child = current_node . children [ 1 ] if key == current_node . key : raise ValueError ( \"Key already exists in tree\" ) elif key > current_node . key : current_node = right_child else : current_node = left_child node . parent = previous_node if key > previous_node . key : previous_node . children [ 1 ] = node else : previous_node . children [ 0 ] = node","title":"insert()"},{"location":"data_structures/trees/binary_search_tree/#data_structures.trees.binary_search_tree.BinarySearchTree.search","text":"Return the position of a key within the tree, or None if the value doesn't exist in the tree. Time complexity: O(n). Parameters: Name Type Description Default key the key to search required Returns: Type Description Optional[tree.Tree._Position] the position of the item if it exists in the tree, else None Source code in trees/binary_search_tree.py def search ( self , key ) -> Union [ BinaryTree . _Position , None ]: \"\"\"Return the position of a key within the tree, or None if the value doesn't exist in the tree. Time complexity: O(n). :param key: the key to search :returns: the position of the item if it exists in the tree, else None \"\"\" if self . is_empty (): raise Empty ( \"Tree is empty\" ) current_node = self . _root while current_node is not None : left_child = current_node . children [ 0 ] right_child = current_node . children [ 1 ] if key == current_node . key : break elif key > current_node . key : current_node = right_child else : current_node = left_child if current_node is None : return None else : return Tree . _Position ( self , current_node )","title":"search()"},{"location":"data_structures/trees/binary_tree/","text":"BinaryTree ( Tree ) A binary tree is a tree whose nodes contain a maximum of two children, the left child and the right child. The order of the children of any node is such that the left child has precedence over the right child. Binary tree vocabularies include, but are not limited to: Proper/full binary tree - a binary tree whose nodes each have zero or two children Balanced binary tree - a binary tree whose left and right subtrees heights differ by a maximum of one, with each of the left and right subtrees being recursively balanced Complete binary tree - a binary tree whose levels are completely filled, except possibly for the last level whose nodes must be as far left as possible Perfect binary tree - a binary tree whose internal nodes each contain two children, and the leaves are contained within the same level get_left_child ( self , position ) Return the left child of the given position. Time complexity: O(1). Parameters: Name Type Description Default position _Position position containing the node whose left child is being sought required Returns: Type Description Optional[tree.Tree._Position] the position of the left child of the node contained in the passed position. None if the position has no left child. Source code in trees/binary_tree.py def get_left_child ( self , position : Tree . _Position ) -> Union [ Tree . _Position , None ]: \"\"\"Return the left child of the given position. Time complexity: O(1). :param position: position containing the node whose left child is being sought :returns: the position of the left child of the node contained in the passed position. None if the position has no left child. \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) node = position . manipulate_node ( self , \"_validate_node\" ) children = node . children if children is None : return None else : left_child = children [ 0 ] return Tree . _Position ( self , left_child ) if left_child is not None else None get_right_child ( self , position ) Return the right child of the given position. Time complexity: O(1). Parameters: Name Type Description Default position _Position position containing the node whose right child is being sought required Returns: Type Description Optional[tree.Tree._Position] the position of the right child of the node contained in the passed position. None if the position has no right child. Source code in trees/binary_tree.py def get_right_child ( self , position : Tree . _Position ) -> Union [ Tree . _Position , None ]: \"\"\"Return the right child of the given position. Time complexity: O(1). :param position: position containing the node whose right child is being sought :returns: the position of the right child of the node contained in the passed position. None if the position has no right child. \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) node = position . manipulate_node ( self , \"_validate_node\" ) children = node . children if children is None : return None else : right_child = children [ 1 ] return ( Tree . _Position ( self , right_child ) if right_child is not None else None ) insert ( self , key , value ) Insert a value into the tree Parameters: Name Type Description Default key unique identifier of the item to be added to the tree required value item to be added to the tree required Source code in trees/binary_tree.py @abstractmethod def insert ( self , key , value ): super () . insert ( key , value ) traverse_subtree_in_order ( self , position ) In-order traverse subtree whose root is the passed position and return a generator of the positions it contains Parameters: Name Type Description Default position _Position position containing the node that's the root of the subtree to be traversed required Returns: Type Description Generator a generator of the positions Source code in trees/binary_tree.py def traverse_subtree_in_order ( self , position : Tree . _Position ) -> Generator : \"\"\"In-order traverse subtree whose root is the passed position and return a generator of the positions it contains :param position: position containing the node that's the root of the subtree to be traversed :returns: a generator of the positions \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) left_child = self . get_left_child ( position ) right_child = self . get_right_child ( position ) if left_child is not None : for i in self . traverse_subtree_in_order ( left_child ): yield i yield position if right_child is not None : for i in self . traverse_subtree_in_order ( right_child ): yield i traverse_tree_in_order ( self ) In-order traverse tree and return a generator of the positions it contains Returns: Type Description Generator a generator of the positions Source code in trees/binary_tree.py def traverse_tree_in_order ( self ) -> Generator : \"\"\"In-order traverse tree and return a generator of the positions it contains :returns: a generator of the positions \"\"\" position = self . get_root () if position is not None : for i in self . traverse_subtree_in_order ( position ): yield i","title":"Binary Tree ADT"},{"location":"data_structures/trees/binary_tree/#data_structures.trees.binary_tree.BinaryTree","text":"A binary tree is a tree whose nodes contain a maximum of two children, the left child and the right child. The order of the children of any node is such that the left child has precedence over the right child. Binary tree vocabularies include, but are not limited to: Proper/full binary tree - a binary tree whose nodes each have zero or two children Balanced binary tree - a binary tree whose left and right subtrees heights differ by a maximum of one, with each of the left and right subtrees being recursively balanced Complete binary tree - a binary tree whose levels are completely filled, except possibly for the last level whose nodes must be as far left as possible Perfect binary tree - a binary tree whose internal nodes each contain two children, and the leaves are contained within the same level","title":"BinaryTree"},{"location":"data_structures/trees/binary_tree/#data_structures.trees.binary_tree.BinaryTree.get_left_child","text":"Return the left child of the given position. Time complexity: O(1). Parameters: Name Type Description Default position _Position position containing the node whose left child is being sought required Returns: Type Description Optional[tree.Tree._Position] the position of the left child of the node contained in the passed position. None if the position has no left child. Source code in trees/binary_tree.py def get_left_child ( self , position : Tree . _Position ) -> Union [ Tree . _Position , None ]: \"\"\"Return the left child of the given position. Time complexity: O(1). :param position: position containing the node whose left child is being sought :returns: the position of the left child of the node contained in the passed position. None if the position has no left child. \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) node = position . manipulate_node ( self , \"_validate_node\" ) children = node . children if children is None : return None else : left_child = children [ 0 ] return Tree . _Position ( self , left_child ) if left_child is not None else None","title":"get_left_child()"},{"location":"data_structures/trees/binary_tree/#data_structures.trees.binary_tree.BinaryTree.get_right_child","text":"Return the right child of the given position. Time complexity: O(1). Parameters: Name Type Description Default position _Position position containing the node whose right child is being sought required Returns: Type Description Optional[tree.Tree._Position] the position of the right child of the node contained in the passed position. None if the position has no right child. Source code in trees/binary_tree.py def get_right_child ( self , position : Tree . _Position ) -> Union [ Tree . _Position , None ]: \"\"\"Return the right child of the given position. Time complexity: O(1). :param position: position containing the node whose right child is being sought :returns: the position of the right child of the node contained in the passed position. None if the position has no right child. \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) node = position . manipulate_node ( self , \"_validate_node\" ) children = node . children if children is None : return None else : right_child = children [ 1 ] return ( Tree . _Position ( self , right_child ) if right_child is not None else None )","title":"get_right_child()"},{"location":"data_structures/trees/binary_tree/#data_structures.trees.binary_tree.BinaryTree.insert","text":"Insert a value into the tree Parameters: Name Type Description Default key unique identifier of the item to be added to the tree required value item to be added to the tree required Source code in trees/binary_tree.py @abstractmethod def insert ( self , key , value ): super () . insert ( key , value )","title":"insert()"},{"location":"data_structures/trees/binary_tree/#data_structures.trees.binary_tree.BinaryTree.traverse_subtree_in_order","text":"In-order traverse subtree whose root is the passed position and return a generator of the positions it contains Parameters: Name Type Description Default position _Position position containing the node that's the root of the subtree to be traversed required Returns: Type Description Generator a generator of the positions Source code in trees/binary_tree.py def traverse_subtree_in_order ( self , position : Tree . _Position ) -> Generator : \"\"\"In-order traverse subtree whose root is the passed position and return a generator of the positions it contains :param position: position containing the node that's the root of the subtree to be traversed :returns: a generator of the positions \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) left_child = self . get_left_child ( position ) right_child = self . get_right_child ( position ) if left_child is not None : for i in self . traverse_subtree_in_order ( left_child ): yield i yield position if right_child is not None : for i in self . traverse_subtree_in_order ( right_child ): yield i","title":"traverse_subtree_in_order()"},{"location":"data_structures/trees/binary_tree/#data_structures.trees.binary_tree.BinaryTree.traverse_tree_in_order","text":"In-order traverse tree and return a generator of the positions it contains Returns: Type Description Generator a generator of the positions Source code in trees/binary_tree.py def traverse_tree_in_order ( self ) -> Generator : \"\"\"In-order traverse tree and return a generator of the positions it contains :returns: a generator of the positions \"\"\" position = self . get_root () if position is not None : for i in self . traverse_subtree_in_order ( position ): yield i","title":"traverse_tree_in_order()"},{"location":"data_structures/trees/tree/","text":"Tree ( ABC ) A tree is a hierarchical collection of nodes containing items, with each node having a unique parent and zero, one or many children items. The topmost element in a non-empty tree, the root, has no parent. Tree vocabularies include, but are not limited to: Root - the topmost element in a non-empty tree, it has no parent Leaf - a node with zero children Siblings - nodes that share a parent node Edge - a pair of nodes such the one is the parent of the other Path - a collection of nodes such that any pair of adjacent nodes have a parent/child relationship Height - number of edges between a node and it's furthest leaf Depth - number of edges between a node and the root Level - number of nodes in the path between a node and the root, inclusive of both the node itself and the root Ordered tree - a tree with a meaningful organisation among its nodes such that its nodes can be arranged in a linear manner from first to last __iter__ ( self ) special Return a tree iterable Returns: Type Description Iterable tree iterable Source code in trees/tree.py def __iter__ ( self ) -> Iterable : \"\"\"Return a tree iterable :return: tree iterable \"\"\" return self __len__ ( self ) special Return total number of items in tree Returns: Type Description int count of items in tree Source code in trees/tree.py def __len__ ( self ) -> int : \"\"\"Return total number of items in tree :return: count of items in tree \"\"\" return self . _length __next__ ( self ) special Return next position of tree iterator, implemented based on level-order traversal Returns: Type Description _Position next position Exceptions: Type Description StopIteration when the cursor denoting the current position surpasses the last position of the tree Source code in trees/tree.py def __next__ ( self ) -> _Position : \"\"\"Return next position of tree iterator, implemented based on level-order traversal :return: next position :raises StopIteration: when the cursor denoting the current position surpasses the last position of the tree \"\"\" if self . __generator is None : self . __generator = self . traverse_tree_level_order () try : next_position = next ( self . __generator ) except StopIteration as e : self . __generator = None raise e return next_position __repr__ ( self ) special Return a string representation of the tree Returns: Type Description str the string representation of the tree Source code in trees/tree.py def __repr__ ( self ) -> str : \"\"\"Return a string representation of the tree :return: the string representation of the tree \"\"\" def helper ( current_position ): children = self . get_children ( current_position ) num_of_children = len ( children ) last_child_idx = num_of_children - 1 data_dict [ \"string_data\" ] += f \" { current_position . get_data ()[ 0 ] } \" for i , j in enumerate ( children ): data_dict [ \"string_data\" ] += \"(\" if i == 0 else \", \" helper ( j ) data_dict [ \"string_data\" ] += \")\" if i == last_child_idx else \"\" if self . is_empty (): return \"\" data_dict = { \"string_data\" : \"\" } helper ( Tree . _Position ( self , self . _root )) return data_dict [ \"string_data\" ] delete ( self , position ) Delete a value from the tree Parameters: Name Type Description Default position _Position position containing the node to be removed from the tree required Source code in trees/tree.py def delete ( self , position : _Position ) -> None : \"\"\"Delete a value from the tree :param position: position containing the node to be removed from the tree \"\"\" self . _length -= 1 if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) def insert_node ( node_to_insert , is_node_left_child , parent_node ): if node_to_insert is not None : node_to_insert . parent = parent_node if is_node_left_child is not None : if is_node_left_child : parent_node . children [ 0 ] = node_to_insert else : parent_node . children [ 1 ] = node_to_insert def delete_node ( node_to_delete , is_root ): parent = node_to_delete . parent left = node_to_delete . children [ 0 ] right = node_to_delete . children [ 1 ] is_left_child = None if parent is None else node_to_delete . key < parent . key if left is None : insert_node ( right , is_left_child , parent ) if is_root : self . _root = right else : current_node = left right_child = current_node . children [ 1 ] if right_child is None : current_node . children [ 1 ] = right insert_node ( current_node , is_left_child , parent ) if is_root : self . _root = current_node else : new_node = Tree . _Node ( right_child . key , right_child . value , children = [ current_node , right ], ) insert_node ( new_node , is_left_child , parent ) if is_root : self . _root = new_node delete_node ( right_child , False ) node = position . manipulate_node ( self , \"_validate_node\" ) is_root_node = self . is_root ( position ) _ = position . manipulate_variables ( self , \"_invalidate_position\" ) delete_node ( node , is_root_node ) get_children ( self , position ) Return the children of the given position. Time complexity: O(1). Parameters: Name Type Description Default position _Position position containing the node whose children are being sought required Returns: Type Description Optional[List[data_structures.trees.tree.Tree._Position]] the positions of the children of the node contained in the passed position. None if the position has no children. Source code in trees/tree.py def get_children ( self , position : _Position ) -> Union [ List [ _Position ], None ]: \"\"\"Return the children of the given position. Time complexity: O(1). :param position: position containing the node whose children are being sought :returns: the positions of the children of the node contained in the passed position. None if the position has no children. \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) node = position . manipulate_node ( self , \"_validate_node\" ) children = node . children if children is None : return None else : return [ Tree . _Position ( self , i ) for i in children if i is not None ] get_depth_of_node ( self , position ) Return the number of edges between a node and the root. Time complexity: O(n). Parameters: Name Type Description Default position _Position position containing the node whose depth is being sought required Returns: Type Description int the number of edges between a node and the root Source code in trees/tree.py def get_depth_of_node ( self , position : _Position ) -> int : \"\"\"Return the number of edges between a node and the root. Time complexity: O(n). :param position: position containing the node whose depth is being sought :returns: the number of edges between a node and the root \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) if self . is_root ( position ): return 0 return 1 + self . get_depth_of_node ( self . get_parent ( position )) get_depth_of_tree ( self ) Return the number of edges between the farthest leaf and the root. Time complexity: O(n). Returns: Type Description int the number of edges between the farthest leaf and the root Source code in trees/tree.py def get_depth_of_tree ( self ) -> int : \"\"\"Return the number of edges between the farthest leaf and the root. Time complexity: O(n). :returns: the number of edges between the farthest leaf and the root \"\"\" return self . get_height_of_tree () get_height_of_node ( self , position ) Return the number of edges between a node and the farthest leaf among its descendants. Time complexity: O(n). Parameters: Name Type Description Default position _Position position containing the node whose height is being sought required Returns: Type Description int the number of edges between a node and the farthest leaf among its descendants Source code in trees/tree.py def get_height_of_node ( self , position : _Position ) -> int : \"\"\"Return the number of edges between a node and the farthest leaf among its descendants. Time complexity: O(n). :param position: position containing the node whose height is being sought :returns: the number of edges between a node and the farthest leaf among its descendants \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) if self . is_leaf ( position ): return 0 return 1 + max ( self . get_height_of_node ( p ) for p in self . get_children ( position )) get_height_of_tree ( self ) Return the number of edges between the root node and the farthest leaf. Time complexity: O(n). Returns: Type Description int the number of edges between the root node and the farthest leaf Source code in trees/tree.py def get_height_of_tree ( self ) -> int : \"\"\"Return the number of edges between the root node and the farthest leaf. Time complexity: O(n). :returns: the number of edges between the root node and the farthest leaf \"\"\" if self . is_empty (): raise Empty ( \"Tree is empty\" ) return self . get_height_of_node ( Tree . _Position ( self , self . _root )) get_level_of_node ( self , position ) Return the number of nodes between a node and the root, inclusive of itself. Time complexity: O(n). Parameters: Name Type Description Default position _Position position containing the node whose level is being sought required Returns: Type Description int the number of nodes between a node and the root, inclusive of itself Source code in trees/tree.py def get_level_of_node ( self , position : _Position ) -> int : \"\"\"Return the number of nodes between a node and the root, inclusive of itself. Time complexity: O(n). :param position: position containing the node whose level is being sought :returns: the number of nodes between a node and the root, inclusive of itself \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) return 1 + self . get_depth_of_node ( position ) get_parent ( self , position ) Return the parent of the given position. Time complexity: O(1). Parameters: Name Type Description Default position _Position position containing the node whose parent is being sought required Returns: Type Description Optional[data_structures.trees.tree.Tree._Position] the position of parent of the node contained in the passed position. None if the position passed contains the root node. Source code in trees/tree.py def get_parent ( self , position : _Position ) -> Union [ _Position , None ]: \"\"\"Return the parent of the given position. Time complexity: O(1). :param position: position containing the node whose parent is being sought :returns: the position of parent of the node contained in the passed position. None if the position passed contains the root node. \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) node = position . manipulate_node ( self , \"_validate_node\" ) if self . is_root ( Tree . _Position ( self , node )): return None else : return Tree . _Position ( self , node . parent ) get_root ( self ) Return the root position. Time complexity: O(1). Returns: Type Description Optional[data_structures.trees.tree.Tree._Position] the root position Source code in trees/tree.py def get_root ( self ) -> Union [ _Position , None ]: \"\"\"Return the root position. Time complexity: O(1). :returns: the root position \"\"\" if self . is_empty (): return None else : return Tree . _Position ( self , self . _root ) get_siblings ( self , position ) Return the siblings of the given position. Time complexity: O(1). Parameters: Name Type Description Default position _Position position containing the node whose children are being sought required Returns: Type Description Optional[List[data_structures.trees.tree.Tree._Position]] the positions of the siblings of the node contained in the passed position Source code in trees/tree.py def get_siblings ( self , position : _Position ) -> Union [ List [ _Position ], None ]: \"\"\"Return the siblings of the given position. Time complexity: O(1). :param position: position containing the node whose children are being sought :returns: the positions of the siblings of the node contained in the passed position \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) node = position . manipulate_node ( self , \"_validate_node\" ) parent = node . parent if parent is None : return [] return [ Tree . _Position ( self , i ) for i in parent . children if i is not node ] insert ( self , key , value ) Insert a value into the tree Parameters: Name Type Description Default key Any unique identifier of the item to be added to the tree required value Any item to be added to the tree required Source code in trees/tree.py @abstractmethod def insert ( self , key : Any , value : Any ) -> None : \"\"\"Insert a value into the tree :param key: unique identifier of the item to be added to the tree :param value: item to be added to the tree \"\"\" self . _length += 1 is_empty ( self ) Return True if tree is empty, else False. Time complexity: O(1). Returns: Type Description bool True if tree is empty, else False Source code in trees/tree.py def is_empty ( self ) -> bool : \"\"\"Return True if tree is empty, else False. Time complexity: O(1). :returns: True if tree is empty, else False \"\"\" return self . _root is None is_leaf ( self , position ) Check if the passed position contains a leaf. Time complexity: O(1). Returns: Type Description bool True if the passed position holds a leaf node, else False Source code in trees/tree.py def is_leaf ( self , position : _Position ) -> bool : \"\"\"Check if the passed position contains a leaf. Time complexity: O(1). :returns: True if the passed position holds a leaf node, else False \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) return len ( self . get_children ( position )) == 0 is_root ( self , position ) Check if the passed position contains the root node. Time complexity: O(1). Returns: Type Description bool True if the passed position holds the root node, else False Source code in trees/tree.py def is_root ( self , position : _Position ) -> bool : \"\"\"Check if the passed position contains the root node. Time complexity: O(1). :returns: True if the passed position holds the root node, else False \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) node = position . manipulate_node ( self , \"_validate_node\" ) return node . parent is None traverse_subtree_level_order ( self , position ) Level-by-level traverse subtree whose root is the passed position and return a generator of the positions it contains Parameters: Name Type Description Default position _Position position containing the node that's the root of the subtree to be traversed required Returns: Type Description Generator a generator of the positions Source code in trees/tree.py def traverse_subtree_level_order ( self , position : _Position ) -> Generator : \"\"\"Level-by-level traverse subtree whose root is the passed position and return a generator of the positions it contains :param position: position containing the node that's the root of the subtree to be traversed :returns: a generator of the positions \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) def helper ( root_node , level ): if root_node is not None : if level == 1 : yield Tree . _Position ( self , root_node ) elif level > 1 : for child in root_node . children : for k in helper ( child , level - 1 ): yield k node = position . manipulate_node ( self , \"_validate_node\" ) number_of_levels = self . get_height_of_node ( position ) + 1 for i in range ( 1 , number_of_levels + 1 ): for j in helper ( node , i ): yield j traverse_subtree_post_order ( self , position ) Post-order traverse subtree whose root is the passed position and return a generator of the positions it contains Parameters: Name Type Description Default position _Position position containing the node that's the root of the subtree to be traversed required Returns: Type Description Generator a generator of the positions Source code in trees/tree.py def traverse_subtree_post_order ( self , position : _Position ) -> Generator : \"\"\"Post-order traverse subtree whose root is the passed position and return a generator of the positions it contains :param position: position containing the node that's the root of the subtree to be traversed :returns: a generator of the positions \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) for i in self . get_children ( position ): for j in self . traverse_subtree_post_order ( i ): yield j yield position traverse_subtree_pre_order ( self , position ) Pre-order traverse subtree whose root is the passed position and return a generator of the positions it contains Parameters: Name Type Description Default position _Position position containing the node that's the root of the subtree to be traversed required Returns: Type Description Generator a generator of the positions Source code in trees/tree.py def traverse_subtree_pre_order ( self , position : _Position ) -> Generator : \"\"\"Pre-order traverse subtree whose root is the passed position and return a generator of the positions it contains :param position: position containing the node that's the root of the subtree to be traversed :returns: a generator of the positions \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) yield position for i in self . get_children ( position ): for j in self . traverse_subtree_pre_order ( i ): yield j traverse_tree_level_order ( self ) Level-by-level traverse tree and return a generator of the positions it contains Returns: Type Description Generator a generator of the positions Source code in trees/tree.py def traverse_tree_level_order ( self ) -> Generator : \"\"\"Level-by-level traverse tree and return a generator of the positions it contains :returns: a generator of the positions \"\"\" position = self . get_root () if position is not None : for i in self . traverse_subtree_level_order ( position ): yield i traverse_tree_post_order ( self ) Post-order traverse tree and return a generator of the positions it contains Returns: Type Description Generator a generator of the positions Source code in trees/tree.py def traverse_tree_post_order ( self ) -> Generator : \"\"\"Post-order traverse tree and return a generator of the positions it contains :returns: a generator of the positions \"\"\" position = self . get_root () if position is not None : for i in self . traverse_subtree_post_order ( position ): yield i traverse_tree_pre_order ( self ) Pre-order traverse tree and return a generator of the positions it contains Returns: Type Description Generator a generator of the positions Source code in trees/tree.py def traverse_tree_pre_order ( self ) -> Generator : \"\"\"Pre-order traverse tree and return a generator of the positions it contains :returns: a generator of the positions \"\"\" position = self . get_root () if position is not None : for i in self . traverse_subtree_pre_order ( position ): yield i","title":"Tree ADT"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree","text":"A tree is a hierarchical collection of nodes containing items, with each node having a unique parent and zero, one or many children items. The topmost element in a non-empty tree, the root, has no parent. Tree vocabularies include, but are not limited to: Root - the topmost element in a non-empty tree, it has no parent Leaf - a node with zero children Siblings - nodes that share a parent node Edge - a pair of nodes such the one is the parent of the other Path - a collection of nodes such that any pair of adjacent nodes have a parent/child relationship Height - number of edges between a node and it's furthest leaf Depth - number of edges between a node and the root Level - number of nodes in the path between a node and the root, inclusive of both the node itself and the root Ordered tree - a tree with a meaningful organisation among its nodes such that its nodes can be arranged in a linear manner from first to last","title":"Tree"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.__iter__","text":"Return a tree iterable Returns: Type Description Iterable tree iterable Source code in trees/tree.py def __iter__ ( self ) -> Iterable : \"\"\"Return a tree iterable :return: tree iterable \"\"\" return self","title":"__iter__()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.__len__","text":"Return total number of items in tree Returns: Type Description int count of items in tree Source code in trees/tree.py def __len__ ( self ) -> int : \"\"\"Return total number of items in tree :return: count of items in tree \"\"\" return self . _length","title":"__len__()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.__next__","text":"Return next position of tree iterator, implemented based on level-order traversal Returns: Type Description _Position next position Exceptions: Type Description StopIteration when the cursor denoting the current position surpasses the last position of the tree Source code in trees/tree.py def __next__ ( self ) -> _Position : \"\"\"Return next position of tree iterator, implemented based on level-order traversal :return: next position :raises StopIteration: when the cursor denoting the current position surpasses the last position of the tree \"\"\" if self . __generator is None : self . __generator = self . traverse_tree_level_order () try : next_position = next ( self . __generator ) except StopIteration as e : self . __generator = None raise e return next_position","title":"__next__()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.__repr__","text":"Return a string representation of the tree Returns: Type Description str the string representation of the tree Source code in trees/tree.py def __repr__ ( self ) -> str : \"\"\"Return a string representation of the tree :return: the string representation of the tree \"\"\" def helper ( current_position ): children = self . get_children ( current_position ) num_of_children = len ( children ) last_child_idx = num_of_children - 1 data_dict [ \"string_data\" ] += f \" { current_position . get_data ()[ 0 ] } \" for i , j in enumerate ( children ): data_dict [ \"string_data\" ] += \"(\" if i == 0 else \", \" helper ( j ) data_dict [ \"string_data\" ] += \")\" if i == last_child_idx else \"\" if self . is_empty (): return \"\" data_dict = { \"string_data\" : \"\" } helper ( Tree . _Position ( self , self . _root )) return data_dict [ \"string_data\" ]","title":"__repr__()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.delete","text":"Delete a value from the tree Parameters: Name Type Description Default position _Position position containing the node to be removed from the tree required Source code in trees/tree.py def delete ( self , position : _Position ) -> None : \"\"\"Delete a value from the tree :param position: position containing the node to be removed from the tree \"\"\" self . _length -= 1 if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) def insert_node ( node_to_insert , is_node_left_child , parent_node ): if node_to_insert is not None : node_to_insert . parent = parent_node if is_node_left_child is not None : if is_node_left_child : parent_node . children [ 0 ] = node_to_insert else : parent_node . children [ 1 ] = node_to_insert def delete_node ( node_to_delete , is_root ): parent = node_to_delete . parent left = node_to_delete . children [ 0 ] right = node_to_delete . children [ 1 ] is_left_child = None if parent is None else node_to_delete . key < parent . key if left is None : insert_node ( right , is_left_child , parent ) if is_root : self . _root = right else : current_node = left right_child = current_node . children [ 1 ] if right_child is None : current_node . children [ 1 ] = right insert_node ( current_node , is_left_child , parent ) if is_root : self . _root = current_node else : new_node = Tree . _Node ( right_child . key , right_child . value , children = [ current_node , right ], ) insert_node ( new_node , is_left_child , parent ) if is_root : self . _root = new_node delete_node ( right_child , False ) node = position . manipulate_node ( self , \"_validate_node\" ) is_root_node = self . is_root ( position ) _ = position . manipulate_variables ( self , \"_invalidate_position\" ) delete_node ( node , is_root_node )","title":"delete()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.get_children","text":"Return the children of the given position. Time complexity: O(1). Parameters: Name Type Description Default position _Position position containing the node whose children are being sought required Returns: Type Description Optional[List[data_structures.trees.tree.Tree._Position]] the positions of the children of the node contained in the passed position. None if the position has no children. Source code in trees/tree.py def get_children ( self , position : _Position ) -> Union [ List [ _Position ], None ]: \"\"\"Return the children of the given position. Time complexity: O(1). :param position: position containing the node whose children are being sought :returns: the positions of the children of the node contained in the passed position. None if the position has no children. \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) node = position . manipulate_node ( self , \"_validate_node\" ) children = node . children if children is None : return None else : return [ Tree . _Position ( self , i ) for i in children if i is not None ]","title":"get_children()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.get_depth_of_node","text":"Return the number of edges between a node and the root. Time complexity: O(n). Parameters: Name Type Description Default position _Position position containing the node whose depth is being sought required Returns: Type Description int the number of edges between a node and the root Source code in trees/tree.py def get_depth_of_node ( self , position : _Position ) -> int : \"\"\"Return the number of edges between a node and the root. Time complexity: O(n). :param position: position containing the node whose depth is being sought :returns: the number of edges between a node and the root \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) if self . is_root ( position ): return 0 return 1 + self . get_depth_of_node ( self . get_parent ( position ))","title":"get_depth_of_node()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.get_depth_of_tree","text":"Return the number of edges between the farthest leaf and the root. Time complexity: O(n). Returns: Type Description int the number of edges between the farthest leaf and the root Source code in trees/tree.py def get_depth_of_tree ( self ) -> int : \"\"\"Return the number of edges between the farthest leaf and the root. Time complexity: O(n). :returns: the number of edges between the farthest leaf and the root \"\"\" return self . get_height_of_tree ()","title":"get_depth_of_tree()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.get_height_of_node","text":"Return the number of edges between a node and the farthest leaf among its descendants. Time complexity: O(n). Parameters: Name Type Description Default position _Position position containing the node whose height is being sought required Returns: Type Description int the number of edges between a node and the farthest leaf among its descendants Source code in trees/tree.py def get_height_of_node ( self , position : _Position ) -> int : \"\"\"Return the number of edges between a node and the farthest leaf among its descendants. Time complexity: O(n). :param position: position containing the node whose height is being sought :returns: the number of edges between a node and the farthest leaf among its descendants \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) if self . is_leaf ( position ): return 0 return 1 + max ( self . get_height_of_node ( p ) for p in self . get_children ( position ))","title":"get_height_of_node()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.get_height_of_tree","text":"Return the number of edges between the root node and the farthest leaf. Time complexity: O(n). Returns: Type Description int the number of edges between the root node and the farthest leaf Source code in trees/tree.py def get_height_of_tree ( self ) -> int : \"\"\"Return the number of edges between the root node and the farthest leaf. Time complexity: O(n). :returns: the number of edges between the root node and the farthest leaf \"\"\" if self . is_empty (): raise Empty ( \"Tree is empty\" ) return self . get_height_of_node ( Tree . _Position ( self , self . _root ))","title":"get_height_of_tree()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.get_level_of_node","text":"Return the number of nodes between a node and the root, inclusive of itself. Time complexity: O(n). Parameters: Name Type Description Default position _Position position containing the node whose level is being sought required Returns: Type Description int the number of nodes between a node and the root, inclusive of itself Source code in trees/tree.py def get_level_of_node ( self , position : _Position ) -> int : \"\"\"Return the number of nodes between a node and the root, inclusive of itself. Time complexity: O(n). :param position: position containing the node whose level is being sought :returns: the number of nodes between a node and the root, inclusive of itself \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) return 1 + self . get_depth_of_node ( position )","title":"get_level_of_node()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.get_parent","text":"Return the parent of the given position. Time complexity: O(1). Parameters: Name Type Description Default position _Position position containing the node whose parent is being sought required Returns: Type Description Optional[data_structures.trees.tree.Tree._Position] the position of parent of the node contained in the passed position. None if the position passed contains the root node. Source code in trees/tree.py def get_parent ( self , position : _Position ) -> Union [ _Position , None ]: \"\"\"Return the parent of the given position. Time complexity: O(1). :param position: position containing the node whose parent is being sought :returns: the position of parent of the node contained in the passed position. None if the position passed contains the root node. \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) node = position . manipulate_node ( self , \"_validate_node\" ) if self . is_root ( Tree . _Position ( self , node )): return None else : return Tree . _Position ( self , node . parent )","title":"get_parent()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.get_root","text":"Return the root position. Time complexity: O(1). Returns: Type Description Optional[data_structures.trees.tree.Tree._Position] the root position Source code in trees/tree.py def get_root ( self ) -> Union [ _Position , None ]: \"\"\"Return the root position. Time complexity: O(1). :returns: the root position \"\"\" if self . is_empty (): return None else : return Tree . _Position ( self , self . _root )","title":"get_root()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.get_siblings","text":"Return the siblings of the given position. Time complexity: O(1). Parameters: Name Type Description Default position _Position position containing the node whose children are being sought required Returns: Type Description Optional[List[data_structures.trees.tree.Tree._Position]] the positions of the siblings of the node contained in the passed position Source code in trees/tree.py def get_siblings ( self , position : _Position ) -> Union [ List [ _Position ], None ]: \"\"\"Return the siblings of the given position. Time complexity: O(1). :param position: position containing the node whose children are being sought :returns: the positions of the siblings of the node contained in the passed position \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) node = position . manipulate_node ( self , \"_validate_node\" ) parent = node . parent if parent is None : return [] return [ Tree . _Position ( self , i ) for i in parent . children if i is not node ]","title":"get_siblings()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.insert","text":"Insert a value into the tree Parameters: Name Type Description Default key Any unique identifier of the item to be added to the tree required value Any item to be added to the tree required Source code in trees/tree.py @abstractmethod def insert ( self , key : Any , value : Any ) -> None : \"\"\"Insert a value into the tree :param key: unique identifier of the item to be added to the tree :param value: item to be added to the tree \"\"\" self . _length += 1","title":"insert()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.is_empty","text":"Return True if tree is empty, else False. Time complexity: O(1). Returns: Type Description bool True if tree is empty, else False Source code in trees/tree.py def is_empty ( self ) -> bool : \"\"\"Return True if tree is empty, else False. Time complexity: O(1). :returns: True if tree is empty, else False \"\"\" return self . _root is None","title":"is_empty()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.is_leaf","text":"Check if the passed position contains a leaf. Time complexity: O(1). Returns: Type Description bool True if the passed position holds a leaf node, else False Source code in trees/tree.py def is_leaf ( self , position : _Position ) -> bool : \"\"\"Check if the passed position contains a leaf. Time complexity: O(1). :returns: True if the passed position holds a leaf node, else False \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) return len ( self . get_children ( position )) == 0","title":"is_leaf()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.is_root","text":"Check if the passed position contains the root node. Time complexity: O(1). Returns: Type Description bool True if the passed position holds the root node, else False Source code in trees/tree.py def is_root ( self , position : _Position ) -> bool : \"\"\"Check if the passed position contains the root node. Time complexity: O(1). :returns: True if the passed position holds the root node, else False \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) node = position . manipulate_node ( self , \"_validate_node\" ) return node . parent is None","title":"is_root()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.traverse_subtree_level_order","text":"Level-by-level traverse subtree whose root is the passed position and return a generator of the positions it contains Parameters: Name Type Description Default position _Position position containing the node that's the root of the subtree to be traversed required Returns: Type Description Generator a generator of the positions Source code in trees/tree.py def traverse_subtree_level_order ( self , position : _Position ) -> Generator : \"\"\"Level-by-level traverse subtree whose root is the passed position and return a generator of the positions it contains :param position: position containing the node that's the root of the subtree to be traversed :returns: a generator of the positions \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) def helper ( root_node , level ): if root_node is not None : if level == 1 : yield Tree . _Position ( self , root_node ) elif level > 1 : for child in root_node . children : for k in helper ( child , level - 1 ): yield k node = position . manipulate_node ( self , \"_validate_node\" ) number_of_levels = self . get_height_of_node ( position ) + 1 for i in range ( 1 , number_of_levels + 1 ): for j in helper ( node , i ): yield j","title":"traverse_subtree_level_order()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.traverse_subtree_post_order","text":"Post-order traverse subtree whose root is the passed position and return a generator of the positions it contains Parameters: Name Type Description Default position _Position position containing the node that's the root of the subtree to be traversed required Returns: Type Description Generator a generator of the positions Source code in trees/tree.py def traverse_subtree_post_order ( self , position : _Position ) -> Generator : \"\"\"Post-order traverse subtree whose root is the passed position and return a generator of the positions it contains :param position: position containing the node that's the root of the subtree to be traversed :returns: a generator of the positions \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) for i in self . get_children ( position ): for j in self . traverse_subtree_post_order ( i ): yield j yield position","title":"traverse_subtree_post_order()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.traverse_subtree_pre_order","text":"Pre-order traverse subtree whose root is the passed position and return a generator of the positions it contains Parameters: Name Type Description Default position _Position position containing the node that's the root of the subtree to be traversed required Returns: Type Description Generator a generator of the positions Source code in trees/tree.py def traverse_subtree_pre_order ( self , position : _Position ) -> Generator : \"\"\"Pre-order traverse subtree whose root is the passed position and return a generator of the positions it contains :param position: position containing the node that's the root of the subtree to be traversed :returns: a generator of the positions \"\"\" if not position . is_owned_by ( self ): raise ValueError ( \"Position doesn't belong to this tree\" ) yield position for i in self . get_children ( position ): for j in self . traverse_subtree_pre_order ( i ): yield j","title":"traverse_subtree_pre_order()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.traverse_tree_level_order","text":"Level-by-level traverse tree and return a generator of the positions it contains Returns: Type Description Generator a generator of the positions Source code in trees/tree.py def traverse_tree_level_order ( self ) -> Generator : \"\"\"Level-by-level traverse tree and return a generator of the positions it contains :returns: a generator of the positions \"\"\" position = self . get_root () if position is not None : for i in self . traverse_subtree_level_order ( position ): yield i","title":"traverse_tree_level_order()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.traverse_tree_post_order","text":"Post-order traverse tree and return a generator of the positions it contains Returns: Type Description Generator a generator of the positions Source code in trees/tree.py def traverse_tree_post_order ( self ) -> Generator : \"\"\"Post-order traverse tree and return a generator of the positions it contains :returns: a generator of the positions \"\"\" position = self . get_root () if position is not None : for i in self . traverse_subtree_post_order ( position ): yield i","title":"traverse_tree_post_order()"},{"location":"data_structures/trees/tree/#data_structures.trees.tree.Tree.traverse_tree_pre_order","text":"Pre-order traverse tree and return a generator of the positions it contains Returns: Type Description Generator a generator of the positions Source code in trees/tree.py def traverse_tree_pre_order ( self ) -> Generator : \"\"\"Pre-order traverse tree and return a generator of the positions it contains :returns: a generator of the positions \"\"\" position = self . get_root () if position is not None : for i in self . traverse_subtree_pre_order ( position ): yield i","title":"traverse_tree_pre_order()"},{"location":"data_structures/trees/trie/","text":"Trie ( Tree ) A trie is a search tree whose nodes each contain a single string character, and have zero or many children. When traversed depth-first, if a complete word is formed, the node at which the path terminates at may be mapped to a value. The root node is unique from the rest of the nodes, in that it doesn't carry any key, or may carry a special key such as an empty string. Tries may be used to predict auto-complete text, where given a certain prefix, all possible combinations of words to complete the prefix can be generated. They may also be used as map structures such as associative arrays, which when passed a string key, return the corresponding value. Instantiate a trie object >>> a_trie = Trie() Inseert a key and its corresponding value to the trie >>> a_trie.insert(\"Hello\", 1) >>> a_trie.insert(\"World\", 2) Check if a trie is empty >>> a_trie.is_empty() False >>> Trie().is_empty() True Get length of some trie >>> len(a_trie) 10 >>> len(Trie()) 0 Get the string representation of some trie >>> a_trie (H(e(l(l(o)))), W(o(r(l(d))))) >>> str(a_trie) '(H(e(l(l(o)))), W(o(r(l(d)))))' Get value associated to some key >>> a_trie[\"Hello\"] 1 >>> a_trie.get_value(\"World\") 2 >>> a_trie[\"Hello, world\"] Traceback (most recent call last): ... KeyError: 'key not present in trie' Replace value associated to some key >>> a_trie[\"Hello\"] = 100 >>> a_trie.replace(\"World\", 200) >>> a_trie[\"Hello, world\"] = 300 Traceback (most recent call last): ... KeyError: 'key not present in trie' Find all strings with some certain prefix >>> a_trie.prefix_search(\"He\") ['Hello'] >>> a_trie.prefix_search(\"qwerty\") [] Delete a key, and thus its corresponding value too, from the trie >>> del a_trie[\"Hello\"] >>> a_trie.delete(\"World\") >>> del a_trie[\"Hello, world\"] Traceback (most recent call last): ... KeyError: 'key not present in trie' __delitem__ ( self , key ) special Alias of delete Source code in trees/trie.py def __delitem__ ( self , key : str ) -> None : \"\"\"Alias of delete\"\"\" self . delete ( key ) __getitem__ ( self , key ) special Alias of get_value Source code in trees/trie.py def __getitem__ ( self , key : str ) -> Any : \"\"\"Alias of get_value\"\"\" return self . get_value ( key ) __setitem__ ( self , key , value ) special Alias of replace Source code in trees/trie.py def __setitem__ ( self , key : str , value : Any ) -> None : \"\"\"Alias of replace\"\"\" self . replace ( key , value ) delete ( self , key ) Delete a key and its corresponding value from the trie Parameters: Name Type Description Default key str key to delete required Source code in trees/trie.py def delete ( self , key : str ) -> None : \"\"\"Delete a key and its corresponding value from the trie :param key: key to delete \"\"\" def not_found_callable (): raise KeyError ( \"key not present in trie\" ) _ , path = self . __get_node_for_key ( key , not_found_callable ) end_of_string_occurrences = 0 while len ( path ) > 1 : node = path . pop () previous_node = path [ - 1 ] if node . end_of_string : if end_of_string_occurrences > 0 : break end_of_string_occurrences += 1 node . value = None node . end_of_string = False if len ( node . children ) > 0 : break else : previous_node . children . remove ( node ) self . _length -= 1 get_value ( self , key ) Return the value associated with a certain key Parameters: Name Type Description Default key str key whose value is being sought required Returns: Type Description Any value corresponding to the passed key Source code in trees/trie.py def get_value ( self , key : str ) -> Any : \"\"\"Return the value associated with a certain key :param key: key whose value is being sought :returns: value corresponding to the passed key \"\"\" def not_found_callable (): raise KeyError ( \"key not present in trie\" ) current_node , _ = self . __get_node_for_key ( key , not_found_callable ) return current_node . value insert ( self , key , value = None ) Insert a key and its corresponding value into the trie Parameters: Name Type Description Default key str key to insert required value Any value corresponding to the key None Source code in trees/trie.py def insert ( self , key : str , value : Any = None ) -> None : \"\"\"Insert a key and its corresponding value into the trie :param key: key to insert :param value: value corresponding to the key \"\"\" def not_found_callable (): pass current_node , _ = self . __get_node_for_key ( key , not_found_callable , create_node = True ) current_node . value = value current_node . end_of_string = True is_empty ( self ) Return True if trie is empty, else False. Time complexity: O(1). Returns: Type Description bool True if trie is empty, else False Source code in trees/trie.py def is_empty ( self ) -> bool : \"\"\"Return True if trie is empty, else False. Time complexity: O(1). :returns: True if trie is empty, else False \"\"\" return self . _length == 0 prefix_search ( self , prefix ) Return all the combinations of words that can be formed from the passed prefix, as per to the trie Parameters: Name Type Description Default prefix str first part of the words being sought required Returns: Type Description List[str] all the combinations of words that can be formed from the passed prefix Source code in trees/trie.py def prefix_search ( self , prefix : str ) -> List [ str ]: \"\"\"Return all the combinations of words that can be formed from the passed prefix, as per to the trie :param prefix: first part of the words being sought :returns: all the combinations of words that can be formed from the passed prefix \"\"\" def not_found_callable (): raise KeyError ( \"key not present in trie\" ) def get_strings_helper ( root_node : Trie . _Node , starting_with : str ): children = root_node . children if root_node . end_of_string : yield starting_with for child in children : for string_data in get_strings_helper ( child , starting_with + child . key ): yield string_data try : current_node , _ = self . __get_node_for_key ( prefix , not_found_callable ) except KeyError : return [] return [ i for i in get_strings_helper ( current_node , prefix )] replace ( self , key , value ) Replace the value of a key with the new passed value Parameters: Name Type Description Default key str key whose value is being replaced required value Any new value that's to replace current value of the passed key required Source code in trees/trie.py def replace ( self , key : str , value : Any ) -> None : \"\"\"Replace the value of a key with the new passed value :param key: key whose value is being replaced :param value: new value that's to replace current value of the passed key \"\"\" def not_found_callable (): raise KeyError ( \"key not present in trie\" ) current_node , _ = self . __get_node_for_key ( key , not_found_callable ) current_node . value = value","title":"Trie"},{"location":"data_structures/trees/trie/#data_structures.trees.trie.Trie","text":"A trie is a search tree whose nodes each contain a single string character, and have zero or many children. When traversed depth-first, if a complete word is formed, the node at which the path terminates at may be mapped to a value. The root node is unique from the rest of the nodes, in that it doesn't carry any key, or may carry a special key such as an empty string. Tries may be used to predict auto-complete text, where given a certain prefix, all possible combinations of words to complete the prefix can be generated. They may also be used as map structures such as associative arrays, which when passed a string key, return the corresponding value. Instantiate a trie object >>> a_trie = Trie() Inseert a key and its corresponding value to the trie >>> a_trie.insert(\"Hello\", 1) >>> a_trie.insert(\"World\", 2) Check if a trie is empty >>> a_trie.is_empty() False >>> Trie().is_empty() True Get length of some trie >>> len(a_trie) 10 >>> len(Trie()) 0 Get the string representation of some trie >>> a_trie (H(e(l(l(o)))), W(o(r(l(d))))) >>> str(a_trie) '(H(e(l(l(o)))), W(o(r(l(d)))))' Get value associated to some key >>> a_trie[\"Hello\"] 1 >>> a_trie.get_value(\"World\") 2 >>> a_trie[\"Hello, world\"] Traceback (most recent call last): ... KeyError: 'key not present in trie' Replace value associated to some key >>> a_trie[\"Hello\"] = 100 >>> a_trie.replace(\"World\", 200) >>> a_trie[\"Hello, world\"] = 300 Traceback (most recent call last): ... KeyError: 'key not present in trie' Find all strings with some certain prefix >>> a_trie.prefix_search(\"He\") ['Hello'] >>> a_trie.prefix_search(\"qwerty\") [] Delete a key, and thus its corresponding value too, from the trie >>> del a_trie[\"Hello\"] >>> a_trie.delete(\"World\") >>> del a_trie[\"Hello, world\"] Traceback (most recent call last): ... KeyError: 'key not present in trie'","title":"Trie"},{"location":"data_structures/trees/trie/#data_structures.trees.trie.Trie.__delitem__","text":"Alias of delete Source code in trees/trie.py def __delitem__ ( self , key : str ) -> None : \"\"\"Alias of delete\"\"\" self . delete ( key )","title":"__delitem__()"},{"location":"data_structures/trees/trie/#data_structures.trees.trie.Trie.__getitem__","text":"Alias of get_value Source code in trees/trie.py def __getitem__ ( self , key : str ) -> Any : \"\"\"Alias of get_value\"\"\" return self . get_value ( key )","title":"__getitem__()"},{"location":"data_structures/trees/trie/#data_structures.trees.trie.Trie.__setitem__","text":"Alias of replace Source code in trees/trie.py def __setitem__ ( self , key : str , value : Any ) -> None : \"\"\"Alias of replace\"\"\" self . replace ( key , value )","title":"__setitem__()"},{"location":"data_structures/trees/trie/#data_structures.trees.trie.Trie.delete","text":"Delete a key and its corresponding value from the trie Parameters: Name Type Description Default key str key to delete required Source code in trees/trie.py def delete ( self , key : str ) -> None : \"\"\"Delete a key and its corresponding value from the trie :param key: key to delete \"\"\" def not_found_callable (): raise KeyError ( \"key not present in trie\" ) _ , path = self . __get_node_for_key ( key , not_found_callable ) end_of_string_occurrences = 0 while len ( path ) > 1 : node = path . pop () previous_node = path [ - 1 ] if node . end_of_string : if end_of_string_occurrences > 0 : break end_of_string_occurrences += 1 node . value = None node . end_of_string = False if len ( node . children ) > 0 : break else : previous_node . children . remove ( node ) self . _length -= 1","title":"delete()"},{"location":"data_structures/trees/trie/#data_structures.trees.trie.Trie.get_value","text":"Return the value associated with a certain key Parameters: Name Type Description Default key str key whose value is being sought required Returns: Type Description Any value corresponding to the passed key Source code in trees/trie.py def get_value ( self , key : str ) -> Any : \"\"\"Return the value associated with a certain key :param key: key whose value is being sought :returns: value corresponding to the passed key \"\"\" def not_found_callable (): raise KeyError ( \"key not present in trie\" ) current_node , _ = self . __get_node_for_key ( key , not_found_callable ) return current_node . value","title":"get_value()"},{"location":"data_structures/trees/trie/#data_structures.trees.trie.Trie.insert","text":"Insert a key and its corresponding value into the trie Parameters: Name Type Description Default key str key to insert required value Any value corresponding to the key None Source code in trees/trie.py def insert ( self , key : str , value : Any = None ) -> None : \"\"\"Insert a key and its corresponding value into the trie :param key: key to insert :param value: value corresponding to the key \"\"\" def not_found_callable (): pass current_node , _ = self . __get_node_for_key ( key , not_found_callable , create_node = True ) current_node . value = value current_node . end_of_string = True","title":"insert()"},{"location":"data_structures/trees/trie/#data_structures.trees.trie.Trie.is_empty","text":"Return True if trie is empty, else False. Time complexity: O(1). Returns: Type Description bool True if trie is empty, else False Source code in trees/trie.py def is_empty ( self ) -> bool : \"\"\"Return True if trie is empty, else False. Time complexity: O(1). :returns: True if trie is empty, else False \"\"\" return self . _length == 0","title":"is_empty()"},{"location":"data_structures/trees/trie/#data_structures.trees.trie.Trie.prefix_search","text":"Return all the combinations of words that can be formed from the passed prefix, as per to the trie Parameters: Name Type Description Default prefix str first part of the words being sought required Returns: Type Description List[str] all the combinations of words that can be formed from the passed prefix Source code in trees/trie.py def prefix_search ( self , prefix : str ) -> List [ str ]: \"\"\"Return all the combinations of words that can be formed from the passed prefix, as per to the trie :param prefix: first part of the words being sought :returns: all the combinations of words that can be formed from the passed prefix \"\"\" def not_found_callable (): raise KeyError ( \"key not present in trie\" ) def get_strings_helper ( root_node : Trie . _Node , starting_with : str ): children = root_node . children if root_node . end_of_string : yield starting_with for child in children : for string_data in get_strings_helper ( child , starting_with + child . key ): yield string_data try : current_node , _ = self . __get_node_for_key ( prefix , not_found_callable ) except KeyError : return [] return [ i for i in get_strings_helper ( current_node , prefix )]","title":"prefix_search()"},{"location":"data_structures/trees/trie/#data_structures.trees.trie.Trie.replace","text":"Replace the value of a key with the new passed value Parameters: Name Type Description Default key str key whose value is being replaced required value Any new value that's to replace current value of the passed key required Source code in trees/trie.py def replace ( self , key : str , value : Any ) -> None : \"\"\"Replace the value of a key with the new passed value :param key: key whose value is being replaced :param value: new value that's to replace current value of the passed key \"\"\" def not_found_callable (): raise KeyError ( \"key not present in trie\" ) current_node , _ = self . __get_node_for_key ( key , not_found_callable ) current_node . value = value","title":"replace()"}]}